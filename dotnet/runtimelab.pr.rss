<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>dotnet/runtimelab Pull Requests</title>
    <description>Pull Requests from https://github.com/dotnet/runtimelab, generated by https://github.com/meziantou/IssuesToRss/</description>
    <managingEditor>meziantousite@outlook.com</managingEditor>
    <ttl>60</ttl>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1993</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1993</link>
      <title>PR: Add green thread api skeleton - @davidwrighton</title>
      <description>&lt;p&gt;Provide a green thread api that just uses threads  (&lt;code&gt;Task.RunAsGreenThread&lt;/code&gt;)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This is probably not completely correct, but if users just call .Wait on the returned tasks, it'll probably be ok.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Also added &lt;code&gt;Thread.IsGreenThread&lt;/code&gt; to check to see if a thread is green.&lt;/p&gt;
</description>
      <pubDate>Thu, 15 Sep 2022 21:29:19 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1991</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1991</link>
      <title>PR: NativeAOT-LLVM: Fix order of catch and second pass + calling finally twice - @yowl</title>
      <description>&lt;p&gt;This PR fixes a couple of issues with the LLVM IL backend for exception handling.  The second pass handler is now called before the catch (oops), and the finally block when adjacent to a catch, is only now called once.&lt;/p&gt;
&lt;p&gt;I expect there are other problems, but at least this fixes 2 big ones and allows&lt;/p&gt;
&lt;p&gt;https://github.com/dotnet/runtimelab/blob/f9cf5b0e52c4645c0a76ad3770d0c63c712c3a05/src/coreclr/nativeaot/System.Private.CoreLib/src/System/Runtime/CompilerServices/ClassConstructorRunner.cs#L109-L115&lt;/p&gt;
&lt;p&gt;to throw without dying in the &lt;code&gt;Release&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Long term wasm-exceptions may help depending on how close the semantics are to .net I guess.&lt;/p&gt;
&lt;p&gt;cc @SingleAccretion&lt;/p&gt;
</description>
      <pubDate>Wed, 14 Sep 2022 00:48:46 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1989</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1989</link>
      <title>PR: NativeAOT-LLVM: Use RhpCheckedAssignRef from RyuJIT backend when location of address is unknown - @yowl</title>
      <description>&lt;p&gt;This PR fixes a problem where the RyuJIT backend is using RhpAssignRef for addresses on the stack, notably when the local var has had an &lt;code&gt;ADD&lt;/code&gt; operation before the &lt;code&gt;STORE_OBJ&lt;/code&gt;.   &lt;code&gt;RhpCheckedAssignRef &lt;/code&gt; is used instead as it is not easily known if the address is on the heap.  This is not the most efficient solution maybe, so input welcome as always.&lt;/p&gt;
&lt;p&gt;Added an assert in &lt;code&gt;RhpAssignRef&lt;/code&gt; to catch this problem when it occurs as opposed to later during a GC collection.&lt;/p&gt;
&lt;p&gt;cc @SingleAccretion&lt;/p&gt;
&lt;p&gt;Fixes #1987&lt;/p&gt;
&lt;p&gt;WIP as I'll wait for #1988 to be merged&lt;/p&gt;
</description>
      <pubDate>Sun, 11 Sep 2022 01:03:31 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1988</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1988</link>
      <title>PR: NativeAOT-LLVM: Change all cases of RhpAssignRef to RhpCheckedAssignRef  - @yowl</title>
      <description>&lt;p&gt;This PR address one cause of memory corruption where the IL-&amp;gt;LLVM backend is using &lt;code&gt;RhpAssignRef&lt;/code&gt; for addresses that may be outside of the heap, e.g. on the shadow stack.  This at least partially addresses #1984 .    All three instances of &lt;code&gt;RhpAssignRef&lt;/code&gt; are changed as it was observed that they are all culprits.&lt;/p&gt;
&lt;p&gt;I didn't create a test as this is difficult to make consistently fail.&lt;/p&gt;
&lt;p&gt;The RyuJIT-&amp;gt;LLVM backend is also doing this, which is why I've not added the assert mentioned in the above issue.  The RyuJIT problem can be looked at separately, #1987&lt;/p&gt;
</description>
      <pubDate>Sat, 10 Sep 2022 22:07:48 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1985</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1985</link>
      <title>PR: Add Green Threads experiment - @cshung</title>
      <description />
      <pubDate>Thu, 08 Sep 2022 18:30:47 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1982</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1982</link>
      <title>PR: Update public pool names - @alexperovich</title>
      <description>&lt;p&gt;This change is required for builds to continue working in the new org, dev.azure.com/dnceng-public.&lt;/p&gt;
</description>
      <pubDate>Thu, 01 Sep 2022 01:58:20 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1981</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1981</link>
      <title>PR: Update public pool names - @alexperovich</title>
      <description>&lt;p&gt;This change is required for builds to continue working in the new org, dev.azure.com/dnceng-public.&lt;/p&gt;
</description>
      <pubDate>Thu, 01 Sep 2022 01:58:15 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1980</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1980</link>
      <title>PR: Update public pool names - @alexperovich</title>
      <description>&lt;p&gt;This change is required for builds to continue working in the new org, dev.azure.com/dnceng-public.&lt;/p&gt;
</description>
      <pubDate>Thu, 01 Sep 2022 01:58:08 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1979</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1979</link>
      <title>PR: Update public pool names - @alexperovich</title>
      <description>&lt;p&gt;This change is required for builds to continue working in the new org, dev.azure.com/dnceng-public.&lt;/p&gt;
</description>
      <pubDate>Thu, 01 Sep 2022 01:58:00 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1978</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1978</link>
      <title>PR: Update public pool names - @alexperovich</title>
      <description>&lt;p&gt;This change is required for builds to continue working in the new org, dev.azure.com/dnceng-public.&lt;/p&gt;
</description>
      <pubDate>Thu, 01 Sep 2022 01:57:55 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1977</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1977</link>
      <title>PR: NativeAOT-LLVM: Add support for GT_CNS_LNG - @yowl</title>
      <description>&lt;p&gt;This PR add support for &lt;code&gt;GT_CNS_LNG&lt;/code&gt;.  I've left in the the possibilty of &lt;code&gt;node-&amp;gt;gtType == TYP_REF&lt;/code&gt; in case this could happen with Wasm64?&lt;/p&gt;
&lt;p&gt;cc @SingleAccretion&lt;/p&gt;
</description>
      <pubDate>Thu, 01 Sep 2022 00:53:15 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1976</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1976</link>
      <title>PR: Rename scratch to hot cold map - @cshung</title>
      <description />
      <pubDate>Wed, 31 Aug 2022 17:51:20 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1975</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1975</link>
      <title>PR: NativeAOT-LLVM: enable the fallback TypeSystemThrowingILEmitter method - @yowl</title>
      <description>&lt;p&gt;This PR enables the method that is emitted in case of a &lt;code&gt;TypeSystemException&lt;/code&gt; in compilation.  It registers the callbacks just once, earlier, in case the method that fails is the first one through &lt;code&gt;corInfo&lt;/code&gt; or if the RyuJIT backend is disabled.  The RyuJIT backend even if disabled is used for the &lt;code&gt;TypeSystemThrowingILEmitter&lt;/code&gt;.  Also sets up the debug info to prevent a null ref.&lt;/p&gt;
&lt;p&gt;cc @SingleAccretion&lt;/p&gt;
</description>
      <pubDate>Wed, 31 Aug 2022 00:15:05 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1974</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1974</link>
      <title>PR: Make sure we don't select the first cold runtime function into the last hot method - @cshung</title>
      <description />
      <pubDate>Mon, 29 Aug 2022 19:02:04 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1973</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1973</link>
      <title>PR: Update the test infra scripts - @cshung</title>
      <description />
      <pubDate>Mon, 29 Aug 2022 18:59:21 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1972</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1972</link>
      <title>PR: NativeAOT-LLVM: upgrade DevOps agent as  win2016 is deprecated - @yowl</title>
      <description>&lt;p&gt;This PR attempts to address #1970 taking the commit https://github.com/dotnet/runtime/commit/e233b7b5b00d9b80f155cd484e246dfc24fdf801&lt;/p&gt;
&lt;p&gt;Thanks @jkotas&lt;/p&gt;
</description>
      <pubDate>Mon, 29 Aug 2022 14:19:04 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1971</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1971</link>
      <title>PR: NativeAOT-LLVM: Add option to disable the RyuJIT backend - @yowl</title>
      <description>&lt;p&gt;This PR adds a codegenopt:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--codegenopt:DisableRyuJit=1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will turn off the RyuJIT backend and force all compilation through the old IL-&amp;gt;LLVM backend.  This can be helpful if a user encounters a problem with the evolving RyuJIT backend that is not present in the IL backend.&lt;/p&gt;
&lt;p&gt;cc @SingleAccretion&lt;/p&gt;
</description>
      <pubDate>Mon, 29 Aug 2022 13:16:58 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1969</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1969</link>
      <title>PR: NativeAOT-LLVM: Allow inlining to handle SPK_ByValue for TARGET_WASM - @yowl</title>
      <description>&lt;p&gt;Continuing https://github.com/dotnet/runtimelab/issues/1859 this PR allows for return types of &lt;code&gt;SPK_ByValue&lt;/code&gt; when inlining.&lt;/p&gt;
&lt;p&gt;For this IL&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;// [S.P.CoreLib]System.DateTimeOffset..cctor()
.method void .cctor() cil managed
{
  // Code size: 66
  .maxstack 2

  IL_0000:  ldc.i4.0
  IL_0001:  conv.i8
  IL_0002:  ldsfld      valuetype System.TimeSpan System.TimeSpan::Zero
  IL_0007:  newobj      instance void System.DateTimeOffset::.ctor(int64, valuetype System.TimeSpan)
  IL_000C:  stsfld      valuetype System.DateTimeOffset System.DateTimeOffset::MinValue
  IL_0011:  ldc.i8      3155378975999999999
  IL_001A:  ldsfld      valuetype System.TimeSpan System.TimeSpan::Zero
  IL_001F:  newobj      instance void System.DateTimeOffset::.ctor(int64, valuetype System.TimeSpan)
  IL_0024:  stsfld      valuetype System.DateTimeOffset System.DateTimeOffset::MaxValue
  IL_0029:  ldc.i8      621355968000000000
  IL_0032:  ldsfld      valuetype System.TimeSpan System.TimeSpan::Zero
  IL_0037:  newobj      instance void System.DateTimeOffset::.ctor(int64, valuetype System.TimeSpan)
  IL_003C:  stsfld      valuetype System.DateTimeOffset System.DateTimeOffset::UnixEpoch
  IL_0041:  ret
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We get in the  IR during inlining: a call to &lt;code&gt;System.DateTimeOffset.ValidateDate&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    [ 4]  14 (0x00e) call 06000A93
In Compiler::impImportCall: opcode is call, kind=0, callRetType is struct, structSize is 8
Calling impNormStructVal on:
               [000075] ------------              *  LCL_VAR   struct&amp;lt;System.TimeSpan, 8&amp;gt; V03 tmp3
resulting tree:
               [000078] n-----------              *  OBJ       struct&amp;lt;System.TimeSpan, 8&amp;gt;
               [000077] ------------              \--*  ADDR      byref
               [000075] -------N----                 \--*  LCL_VAR   struct&amp;lt;System.TimeSpan, 8&amp;gt; V03 tmp3
Calling impNormStructVal on:
               [000074] ------------              *  LCL_VAR   struct&amp;lt;System.DateTime, 8&amp;gt; V04 tmp4
resulting tree:
               [000080] n-----------              *  OBJ       struct&amp;lt;System.DateTime, 8&amp;gt;
               [000079] ------------              \--*  ADDR      byref
               [000074] -------N----                 \--*  LCL_VAR   struct&amp;lt;System.DateTime, 8&amp;gt; V04 tmp4


               [000076] I-C-G-------              *  CALL      struct System.DateTimeOffset.ValidateDate (exactContextHnd=0x4000000000420029)
               [000080] n----------- arg0         +--*  OBJ       struct&amp;lt;System.DateTime, 8&amp;gt;
               [000079] ------------              |  \--*  ADDR      byref
               [000074] -------N----              |     \--*  LCL_VAR   struct&amp;lt;System.DateTime, 8&amp;gt; V04 tmp4
               [000078] n----------- arg1         \--*  OBJ       struct&amp;lt;System.TimeSpan, 8&amp;gt;
               [000077] ------------                 \--*  ADDR      byref
               [000075] -------N----                    \--*  LCL_VAR   struct&amp;lt;System.TimeSpan, 8&amp;gt; V03 tmp3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which hits the assert at &lt;a href="https://github.com/dotnet/runtimelab/blob/d6e61cf66532f2741f26123bbe5228dfcd33449d/src/coreclr/jit/fginline.cpp#L632"&gt;fginline.cpp 635&lt;/a&gt; as &lt;code&gt;SPK_ByValue&lt;/code&gt;, for node 76, is not an option for TARGET_WASM. LLVM/Wasm should be able to do that.
I enabled &lt;code&gt;SPK_ByValue&lt;/code&gt; as a return type that requires no work in &lt;code&gt;fgUpdateInlineReturnExpressionPlaceHolder&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;That's not enough to compile the input IL: we hit the promoted struct problem, but I can do that separately.&lt;/p&gt;
&lt;p&gt;cc @SingleAccretion&lt;/p&gt;
</description>
      <pubDate>Sat, 27 Aug 2022 20:18:37 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1968</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1968</link>
      <title>PR: NativeAOT-LLVM: do not mark the shadow stack as a local on the llvm stack if not referenced - @yowl</title>
      <description>&lt;p&gt;Continuing #1859 this PR addresses the first issue hit in that PR: https://github.com/dotnet/runtimelab/issues/1859#issue-1160716397&lt;/p&gt;
&lt;p&gt;For the IL:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// [S.P.CoreLib]System.Reflection.Module+&amp;lt;&amp;gt;c..ctor()
.method instance void .ctor() cil managed
{
  // Code size: 7
  .maxstack 8

  IL_0000:  ldarg.0
  IL_0001:  call        instance void System.Object::.ctor()
  IL_0006:  ret
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We get the IR&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;------------ BB01 [000..007) (return), preds={} succs={}
N001 (  0,  0) [000002] ------------                 RETURN    void   $c0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The call is inlined if I read the log properly, and &lt;code&gt;$c0&lt;/code&gt; is &lt;code&gt;{MemOpaque:NotInLoop}&lt;/code&gt; &amp;lt;- I don't know what that means, is it the reason for inlining?&lt;/p&gt;
&lt;p&gt;Anyway, that fails currently for the reason in the original disucssion: it tries to create an LLVM &lt;code&gt;alloca&lt;/code&gt; for the shadow stack which is not referenced and &lt;code&gt;getLlvmArgInfoForArgIx&lt;/code&gt; hits an assert.&lt;/p&gt;
&lt;p&gt;With this change the final LLVM is&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;define void @S_P_CoreLib_System_Reflection_Module___c___ctor(i8* %0) {
Prolog:
  br label %1

1:                                                ; preds = %Prolog
  ret void
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;cc @SingleAccretion&lt;/p&gt;
</description>
      <pubDate>Sat, 27 Aug 2022 15:16:59 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1967</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1967</link>
      <title>PR: Fix some mistakes in `docs/using-nativeaot/interop.md` - @just-ero</title>
      <description>&lt;p&gt;Simply some typo fixes, as well as trying to keep the language in line with existing documentation.&lt;/p&gt;
</description>
      <pubDate>Fri, 26 Aug 2022 05:54:39 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1966</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1966</link>
      <title>PR: NativeAOT-LLVM: Allow `RyuJitCompilation` to turn off tail calls - @yowl</title>
      <description>&lt;p&gt;As the first part of progressing #1859 this PR allows tail calls to be turned off based on the method signature.&lt;/p&gt;
&lt;p&gt;For &lt;code&gt;object.ToString&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;IL&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// object.ToString()
.method instance string ToString() cil managed
{
  // Code size: 12
  .maxstack 8

  IL_0000:  ldarg.0
  IL_0001:  call        instance class System.Type System.Object::GetType()
  IL_0006:  callvirt    instance string System.Object::ToString()
  IL_000B:  ret
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;callvirt/ret&lt;/code&gt; are identified as a tail call&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    [ 1]   6 (0x006) callvirt 06000268
 (Implicit Tail call: prefixFlags |= PREFIX_TAILCALL_IMPLICIT)
In Compiler::impImportCall: opcode is callvirt, kind=4, callRetType is ref, structSize is 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It would be nice to allow tail calls in Wasm, LLVM has tail convention, but Wasm can't do it when the type needs to go in a return slot on the shadow stack, so to allow tail calls for simple types that can go on the LLVM stack, but turn it off for return types that need a shadow stack slot, this PR adds a virtual call to &lt;code&gt;RyuJitCompilation&lt;/code&gt; that LLVM can override and turn off the tail call.  This wont prevent the assert at https://github.com/dotnet/runtimelab/blob/706c9c1ad1f4d3d150d08cd02d4ac507d02302f9/src/coreclr/jit/llvm.cpp#L2753 for simple types, but should clear the way for adding LLVM tail convention for simple types.&lt;/p&gt;
</description>
      <pubDate>Thu, 25 Aug 2022 02:35:44 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1963</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1963</link>
      <title>PR: Test infrastructure integration - @cshung</title>
      <description />
      <pubDate>Fri, 19 Aug 2022 19:37:16 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1962</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1962</link>
      <title>PR: Merge remote-tracking branch 'lab-upstream/runtime-main' into feature/hot-cold-splitting - @cshung</title>
      <description />
      <pubDate>Thu, 18 Aug 2022 02:23:11 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1960</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1960</link>
      <title>PR: Validation for RuntimeFunctions and change to unwindinfo - @EugenioPena</title>
      <description>&lt;p&gt;Added a function to validate the information for RuntimeFunctions via asserts that make sure they're correctly sorted, their intervals don't overlap, and their PersonalityRoutineRVA is the same, as stated in issue #1955. Also modified UnwindInfo so that whenever the CHAININFO flag is on we don't generate the personality routine, as it was showing the RVA to the hot function instead of the Personality Routine.&lt;/p&gt;
</description>
      <pubDate>Mon, 15 Aug 2022 20:38:25 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1958</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1958</link>
      <title>PR: Fix chained unwind info for stack alloc scenarios - @cshung</title>
      <description />
      <pubDate>Sun, 14 Aug 2022 03:19:15 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1957</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1957</link>
      <title>PR: Sort the cold nodes consistently to re-enable optimizer - @cshung</title>
      <description />
      <pubDate>Thu, 11 Aug 2022 17:42:21 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1956</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1956</link>
      <title>PR: Disable ReadyToRunFileLayoutOptimizer - @cshung</title>
      <description>&lt;p&gt;In a crossgen2 test run, the flag &lt;code&gt;--method-layout:random&lt;/code&gt; is specified and it impacts the correctness of &lt;code&gt;--hot-cold-splitting&lt;/code&gt;. Eventually, we need to fix that in #1954, disabling it for now.&lt;/p&gt;
</description>
      <pubDate>Sun, 07 Aug 2022 22:52:43 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1953</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1953</link>
      <title>PR: Fix Standalone template's official build and publishing - @joperezr</title>
      <description>&lt;p&gt;Fixing Standalone template so that it is able to successfully have an official build and publish packages.&lt;/p&gt;
</description>
      <pubDate>Fri, 05 Aug 2022 21:27:00 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1952</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1952</link>
      <title>PR: Fixing Internal pool names in yaml to unblock official build - @joperezr</title>
      <description>&lt;p&gt;FYI: @MosheWolberg @ericstj&lt;/p&gt;
</description>
      <pubDate>Fri, 05 Aug 2022 17:03:52 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1951</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1951</link>
      <title>PR: Fixed indexing error - @EugenioPena</title>
      <description>&lt;p&gt;Fixed an indexing error that would cause the index to be -1, which would cause some test failures when reproducing the steps stated on issue #1950. Did this by validating that the number of functions in the scratch map wasn't 0 before calling &lt;code&gt;HotColdMappingLookupTable::LookupMappingForMethod&lt;/code&gt;.&lt;/p&gt;
</description>
      <pubDate>Thu, 04 Aug 2022 22:22:07 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1949</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1949</link>
      <title>PR: Fixes to R2RDump so it won't crash when functions aren't split - @EugenioPena</title>
      <description>&lt;p&gt;Fixes issue #1947 where the R2RDump would crash when functions weren't split by modifying some indices that were wrong from my PR #1945. Also changed slightly the way in which the number of functions is counted when the code is split.&lt;/p&gt;
</description>
      <pubDate>Wed, 03 Aug 2022 00:11:24 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1945</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1945</link>
      <title>PR: Fixes to R2RDump to dump respective hot/cold parts together - @EugenioPena</title>
      <description>&lt;p&gt;Fixes #1908 where functions wouldn't be dumped with their respective methods. Made changes to ReadyToRunReader.cs in the functions EnsureMethods and CountRuntimeFunctions, as well as to ReadyToRunMethods.cs, adding ColdRuntimeFunctionId and ColdRuntimeFunctionCount properties, as well as changing ParseRuntimeFunctions to iterate through both the hot and cold functions.&lt;/p&gt;
</description>
      <pubDate>Thu, 28 Jul 2022 18:27:29 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1944</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1944</link>
      <title>PR: Move inline switch table check to fginline.cpp - @amanasifkhalid</title>
      <description>&lt;p&gt;Follow-up to #1937 : According to @AndyAyersMS, we should disable hot/cold splitting in the root compiler if its inlinee compiler finds a switch table only if the inline succeeds. Thus, the logic to disable &lt;code&gt;opts.compProcedureSplitting&lt;/code&gt; in the root compiler has been moved to a common place in &lt;code&gt;fginline.cpp&lt;/code&gt; for propagating compiler arguments. This change does not reproduce the related regression exposed by #1937 when stress-splitting &lt;code&gt;System.Private.CoreLib&lt;/code&gt;.&lt;/p&gt;
</description>
      <pubDate>Tue, 26 Jul 2022 23:05:59 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1943</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1943</link>
      <title>PR: Convert Scratch lookup to binary search - @amanasifkhalid</title>
      <description>&lt;p&gt;Preliminary work for #1903: Before making any design changes, we should try using binary search over the Scratch table, and profile the performance gain. I likely won't have time to fully pursue this task, but we can at least get rid of the linear search for now.&lt;/p&gt;
</description>
      <pubDate>Thu, 21 Jul 2022 22:25:17 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1942</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1942</link>
      <title>PR: Fix GetUnwindInfoHelper so that we will not get a chained unwind info - @amanasifkhalid</title>
      <description>&lt;p&gt;When unwinding from cold main method code, we risk breaking invariants the security stack walk cache assumes -- the cache does not expect chained unwind info, and thus can return incorrect results later if not handled. We handle this by simply invalidating the cache; assuming cold code is rarely executed, this should not happen frequently.&lt;/p&gt;
</description>
      <pubDate>Wed, 20 Jul 2022 17:00:07 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1940</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1940</link>
      <title>PR: Fix codeman to support split-eh - @EugenioPena</title>
      <description>&lt;p&gt;This PR fixes the last two tasks on issue #1918. The first one consists of correctly calculating the cold size to account for multiple functions in ReadyToRunJitManager:: JitTokenToMethodRegionInfo. The second one fixes the calculation of m_relOffset in ReadyToRunJitManager::JitCodeToMethodInfo.&lt;/p&gt;
</description>
      <pubDate>Wed, 20 Jul 2022 00:56:53 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1939</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1939</link>
      <title>PR: Fix duplicate Scratch generation - @amanasifkhalid</title>
      <description>&lt;p&gt;This PR fixes a bug where the Scratch table could be generated multiple times when the dependency graph computes its dependencies in parallel. &lt;code&gt;NodeFactory.GenerateScratch()&lt;/code&gt; has been updated to prevent duplicate generation.&lt;/p&gt;
</description>
      <pubDate>Tue, 19 Jul 2022 23:49:01 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1938</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1938</link>
      <title>PR: Patched Fields Branch - @MosheWolberg</title>
      <description>&lt;p&gt;I got feedback about pushing more atomic PR's but I had already prepped this one to go, so going forward I'll try being better about it.&lt;/p&gt;
&lt;p&gt;Added Fields.
Also added inheritance which was necessary for fields.
Quite a lot of NIT changes because I added StyleCop to my project.
@joperezr&lt;/p&gt;
</description>
      <pubDate>Tue, 19 Jul 2022 23:09:05 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1937</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1937</link>
      <title>PR: Disable splitting for switch tables when inlining - @amanasifkhalid</title>
      <description>&lt;p&gt;Due to an implementation limitation, the JIT disables hot/cold splitting for functions that may contain switch tables. However, this limitation could be bypassed if we inline a function containing switch tables: &lt;code&gt;opts.compProcedureSplitting&lt;/code&gt; would be disabled for the inlining compiler, but not for the parent compiler, which could result in the switch table being incorrectly split. This PR prevents this from happening by disabling &lt;code&gt;opts.compProcedureSplitting&lt;/code&gt; for the parent compiler.&lt;/p&gt;
</description>
      <pubDate>Tue, 19 Jul 2022 20:47:27 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1936</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1936</link>
      <title>PR: Generate Scratch only if there is cold code - @amanasifkhalid</title>
      <description>&lt;p&gt;Fixes #1906 by generating the Scratch table only if a call to &lt;code&gt;CorInfoImpl.CompileMethod()&lt;/code&gt; results in cold code being generated. This work does not require any changes in the VM, as iterations over the Scratch table already check the table's size before accessing it, thus avoiding any null pointer dereferences.&lt;/p&gt;
&lt;p&gt;Below is an excerpt from the R2R dump for &lt;code&gt;CoreLab&lt;/code&gt;, showcasing the Scratch table exists:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Type:  ManifestAssemblyMvids (118)
RelativeVirtualAddress: 0x0000180C
Size: 0 bytes

_______________________________________________

Type:  Scratch (119)
RelativeVirtualAddress: 0x00001853
Size: 8 bytes
1,0


======================== R2R Methods ========================
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After editing &lt;code&gt;CoreLab\Program.cs&lt;/code&gt; so that the sole function is empty (and thus does not have any cold code), the R2R dump excerpt looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Type:  ManifestAssemblyMvids (118)
RelativeVirtualAddress: 0x000017C4
Size: 0 bytes


======================== R2R Methods ========================
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Thu, 14 Jul 2022 22:36:05 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1934</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1934</link>
      <title>PR: Emit cold nodes last without relying on ClassCode - @amanasifkhalid</title>
      <description>&lt;p&gt;This PR addresses #1912 by removing &lt;code&gt;MethodColdCodeNode&lt;/code&gt;'s dependency on its ClassCode to be emitted after all hot nodes in the PE execution section. When emitting &lt;code&gt;ObjectNodes&lt;/code&gt;, &lt;code&gt;MethodColdCodeNodes&lt;/code&gt; are stashed in a list, and all other &lt;code&gt;ObjectNodes&lt;/code&gt; are emitted first. Finally, all &lt;code&gt;MethodColdCodeNodes&lt;/code&gt; in the list are emitted to the end of the execution section. This implementation removes the need for another execution section.&lt;/p&gt;
</description>
      <pubDate>Wed, 13 Jul 2022 17:14:36 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1933</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1933</link>
      <title>PR: Custom attributes - @MosheWolberg</title>
      <description>&lt;p&gt;This is the core functionality for Custom Attributes.&lt;/p&gt;
&lt;p&gt;At present, only Custom Attributes on types are supported but that extending to Assemblies, Members etc. shouldn't be difficult since the foundation is in place.
I reorganized several key parts of the projects:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Most storage and all construction of metadata was centralized into the ModuleBuilder class.
This made more sense than the previous local construction the metadata of each type, member etc within itself - a lot of metadata across types may overlap (for example, assembly refs) so constructing data in the central module made sense and also simplifies the code going forward.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Actual metadata writing moved to static Metadata Helper class.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Signature construction moved to Signature Helper class.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;And then I added necessary code for Custom Attributes, (porting needed encoder classes as well like Custom Attribute Builder).&lt;/p&gt;
&lt;p&gt;Fields are next but I want to tie up a few loose ends before then (I'll share a list of them) - mainly, the SignatureEncoder class is currently just a basic prototype I built much earlier but to support more complex things like arrays in signatures I should port the real SignatureEnconder.&lt;/p&gt;
</description>
      <pubDate>Mon, 11 Jul 2022 23:18:41 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1931</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1931</link>
      <title>PR: Fix Personality Routine generation - @cshung</title>
      <description>&lt;p&gt;After I spent some time debugging the cold funclet exception handling scenarios, I believe the personality routines are also needed for each cold funclet.&lt;/p&gt;
&lt;p&gt;@amanasifkhalid, @EugenioPena&lt;/p&gt;
</description>
      <pubDate>Sun, 10 Jul 2022 17:37:06 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1930</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1930</link>
      <title>PR: Fix unwind info for cold EH funclets on ARM64 - @amanasifkhalid</title>
      <description>&lt;p&gt;Follow-up to #1923. When reserving and allocating unwind info on ARM64, we now consider the possibility that EH funclets are in the cold section. Below are some examples of reserving/allocating unwind info with this new behavior:&lt;/p&gt;
&lt;p&gt;Main body split, no EH funclets:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;reserveUnwindInfo(isFunclet=false, isColdCode=false, unwindSize=0xc)
reserveUnwindInfo(isFunclet=false, isColdCode=true, unwindSize=0x10)

allocUnwindInfo(pHotCode=0x00000231387F5530, pColdCode=0x0000000000000000, startOffset=0x0, endOffset=0x1c, unwindSize=0xc, pUnwindBlock=0x000002313AC97674, funKind=0 (main function))
allocUnwindInfo(pHotCode=0x00000231387F5530, pColdCode=0x00000231387F2A40, startOffset=0x0, endOffset=0x4c, unwindSize=0x10, pUnwindBlock=0x000002313AA80A57, funKind=0 (main function))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Main body split, with cold EH funclets:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;reserveUnwindInfo(isFunclet=false, isColdCode=false, unwindSize=0x10)
reserveUnwindInfo(isFunclet=false, isColdCode=true, unwindSize=0x1c)
reserveUnwindInfo(isFunclet=true, isColdCode=true, unwindSize=0xc)

allocUnwindInfo(pHotCode=0x0000028CBABC5420, pColdCode=0x0000000000000000, startOffset=0x0, endOffset=0x58, unwindSize=0x10, pUnwindBlock=0x0000028CBD150D70, funKind=0 (main function))
allocUnwindInfo(pHotCode=0x0000028CBABC5420, pColdCode=0x0000028CBC82BC70, startOffset=0x0, endOffset=0x4d0, unwindSize=0x1c, pUnwindBlock=0x0000028CBD3DEC83, funKind=0 (main function))
allocUnwindInfo(pHotCode=0x0000028CBABC5420, pColdCode=0x0000028CBC82BC70, startOffset=0x4d0, endOffset=0x560, unwindSize=0xc, pUnwindBlock=0x0000028CBD150ED1, funKind=1 (handler))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Main body NOT split, with cold EH funclets:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;reserveUnwindInfo(isFunclet=false, isColdCode=false, unwindSize=0x10)
reserveUnwindInfo(isFunclet=true, isColdCode=true, unwindSize=0xc)
reserveUnwindInfo(isFunclet=true, isColdCode=true, unwindSize=0xc)
reserveUnwindInfo(isFunclet=true, isColdCode=true, unwindSize=0xc)
reserveUnwindInfo(isFunclet=true, isColdCode=true, unwindSize=0xc)

allocUnwindInfo(pHotCode=0x0000024CCC700300, pColdCode=0x0000000000000000, startOffset=0x0, endOffset=0x588, unwindSize=0x10, pUnwindBlock=0x0000024CCE21BC27, funKind=0 (main function))
allocUnwindInfo(pHotCode=0x0000024CCC700300, pColdCode=0x0000024CCC7008F0, startOffset=0x0, endOffset=0x38, unwindSize=0xc, pUnwindBlock=0x0000024CCE21BD8C, funKind=1 (handler))
allocUnwindInfo(pHotCode=0x0000024CCC700300, pColdCode=0x0000024CCC7008F0, startOffset=0x38, endOffset=0x60, unwindSize=0xc, pUnwindBlock=0x0000024CCE21BEEC, funKind=1 (handler))
allocUnwindInfo(pHotCode=0x0000024CCC700300, pColdCode=0x0000024CCC7008F0, startOffset=0x60, endOffset=0x128, unwindSize=0xc, pUnwindBlock=0x0000024CCE21C04C, funKind=1 (handler))
allocUnwindInfo(pHotCode=0x0000024CCC700300, pColdCode=0x0000024CCC7008F0, startOffset=0x128, endOffset=0x160, unwindSize=0xc, pUnwindBlock=0x0000024CCE21C1AC, funKind=1 (handler))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I apologize if I'm stating the obvious here, but note that when the main body is split, &lt;code&gt;unwindSize &amp;gt; 0&lt;/code&gt; for the cold part's unwind info; it looks like we don't use chained unwind info on ARM64. If this is true, then we will likely have to modify the Scratch table's lookup implementation to correctly find cold functions/funclets on ARM64.&lt;/p&gt;
</description>
      <pubDate>Fri, 08 Jul 2022 18:00:38 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1929</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1929</link>
      <title>PR: Support cold EH funclets in VM - @amanasifkhalid</title>
      <description>&lt;p&gt;This PR closes out the remaining tasks in #1918 by adding support for hot/cold splitting of EH funclets in the VM. This support requires the following changes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In &lt;code&gt;ReadyToRunJitManager::JitCodeToMethodInfo&lt;/code&gt;, when searching the Scratch table for the corresponding hot MethodIndex of a given cold MethodIndex, we now handle MethodIndices of cold EH funclets that aren't in the table (i.e. when part of the main body is split).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReadyToRunJitManager::IsFunclet&lt;/code&gt; now returns true for cold EH funclets that are in the Scratch table.&lt;/li&gt;
&lt;/ul&gt;
</description>
      <pubDate>Thu, 07 Jul 2022 21:32:43 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1926</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1926</link>
      <title>PR: Support EH funclet splitting in Crossgen2 - @amanasifkhalid</title>
      <description>&lt;p&gt;Opening this to share initial Crossgen2 work with @cshung , @EugenioPena .&lt;/p&gt;
&lt;p&gt;(EH splitting is enabled in the JIT, so expect pipelines to fail for now).&lt;/p&gt;
</description>
      <pubDate>Sat, 02 Jul 2022 00:07:10 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1923</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1923</link>
      <title>PR: Fix unwind info generation for EH funclets - @amanasifkhalid</title>
      <description>&lt;p&gt;This PR addresses the second task in #1918 by fixing unwind info generation for EH funclets in the JIT on x64. Additionally, a bug was found in &lt;code&gt;fgDetermineFirstColdBlock&lt;/code&gt; where a block after &lt;code&gt;fgFirstFuncletBB&lt;/code&gt; could be selected as a candidate for &lt;code&gt;fgFirstColdBlock&lt;/code&gt;, potentially splitting the funclet section; this has been fixed by adding some additional logic to short-circuit the search if we reach the first funclet block.&lt;/p&gt;
&lt;p&gt;Note that these changes apply specifically to x64; at some point, similar changes will be needed for ARM64, etc. I can do this work in a follow-up PR.&lt;/p&gt;
&lt;p&gt;Below are some examples of unwind info generation for functions with EH, collected from various JIT dumps:&lt;/p&gt;
&lt;p&gt;Function with no splitting, plus hot EH funclets:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Hot  code size = 0x263 bytes
Cold code size = 0x0 bytes
reserveUnwindInfo(isFunclet=false, isColdCode=false, unwindSize=0xe)
reserveUnwindInfo(isFunclet=true, isColdCode=false, unwindSize=0xe)
...
Unwind Info:
  &amp;gt;&amp;gt; Start offset   : 0x000000 (not in unwind data)
  &amp;gt;&amp;gt;   End offset   : 0x000230 (not in unwind data)
  Version           : 1
  Flags             : 0x00
  SizeOfProlog      : 0x08
  CountOfUnwindCodes: 5
  FrameRegister     : none (0)
  FrameOffset       : N/A (no FrameRegister) (Value=0)
  UnwindCodes       :
    CodeOffset: 0x08 UnwindOp: UWOP_ALLOC_SMALL (2)     OpInfo: 12 * 8 + 8 = 104 = 0x68
    CodeOffset: 0x04 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rbx (3)
    CodeOffset: 0x03 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rsi (6)
    CodeOffset: 0x02 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rdi (7)
    CodeOffset: 0x01 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rbp (5)
allocUnwindInfo(pHotCode=0x000001F9E1B23250, pColdCode=0x0000000000000000, startOffset=0x0, endOffset=0x230, unwindSize=0xe, pUnwindBlock=0x000001F9E3D63122, funKind=0 (main function))
Unwind Info:
  &amp;gt;&amp;gt; Start offset   : 0x000230 (not in unwind data)
  &amp;gt;&amp;gt;   End offset   : 0x000261 (not in unwind data)
  Version           : 1
  Flags             : 0x00
  SizeOfProlog      : 0x08
  CountOfUnwindCodes: 5
  FrameRegister     : none (0)
  FrameOffset       : N/A (no FrameRegister) (Value=0)
  UnwindCodes       :
    CodeOffset: 0x08 UnwindOp: UWOP_ALLOC_SMALL (2)     OpInfo: 4 * 8 + 8 = 40 = 0x28
    CodeOffset: 0x04 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rbx (3)
    CodeOffset: 0x03 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rsi (6)
    CodeOffset: 0x02 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rdi (7)
    CodeOffset: 0x01 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rbp (5)
allocUnwindInfo(pHotCode=0x000001F9E1B23250, pColdCode=0x0000000000000000, startOffset=0x230, endOffset=0x261, unwindSize=0xe, pUnwindBlock=0x000001F9E3D6335A, funKind=1 (handler))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Function with main body split, plus cold EH funclets:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Hot  code size = 0x35B bytes
Cold code size = 0x106 bytes
reserveUnwindInfo(isFunclet=false, isColdCode=false, unwindSize=0x18)
reserveUnwindInfo(isFunclet=false, isColdCode=true, unwindSize=0x0)
reserveUnwindInfo(isFunclet=true, isColdCode=true, unwindSize=0x16)
...
Unwind Info:
  &amp;gt;&amp;gt; Start offset   : 0x000000 (not in unwind data)
  &amp;gt;&amp;gt;   End offset   : 0x00035b (not in unwind data)
  Version           : 1
  Flags             : 0x00
  SizeOfProlog      : 0x13
  CountOfUnwindCodes: 10
  FrameRegister     : none (0)
  FrameOffset       : N/A (no FrameRegister) (Value=0)
  UnwindCodes       :
    CodeOffset: 0x13 UnwindOp: UWOP_ALLOC_LARGE (1)     OpInfo: 0 - Scaled small  
      Size: 17 * 8 = 136 = 0x00088
    CodeOffset: 0x0C UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rbx (3)
    CodeOffset: 0x0B UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rsi (6)
    CodeOffset: 0x0A UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rdi (7)
    CodeOffset: 0x09 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: r12 (12)
    CodeOffset: 0x07 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: r13 (13)
    CodeOffset: 0x05 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: r14 (14)
    CodeOffset: 0x03 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: r15 (15)
    CodeOffset: 0x01 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rbp (5)
allocUnwindInfo(pHotCode=0x000001F9E1BDF760, pColdCode=0x0000000000000000, startOffset=0x0, endOffset=0x35b, unwindSize=0x18, pUnwindBlock=0x000001F9E3D61168, funKind=0 (main function))
Unwind Info COLD:
  &amp;gt;&amp;gt; Start offset   : 0x00035b (not in unwind data)
  &amp;gt;&amp;gt;   End offset   : 0x000401 (not in unwind data)
allocUnwindInfo(pHotCode=0x000001F9E1BDF760, pColdCode=0x000001F9E1BDFB20, startOffset=0x0, endOffset=0xa6, unwindSize=0x0, pUnwindBlock=0x0000000000000000, funKind=0 (main function))
Unwind Info COLD:
  &amp;gt;&amp;gt; Start offset   : 0x000401 (not in unwind data)
  &amp;gt;&amp;gt;   End offset   : 0x000461 (not in unwind data)
allocUnwindInfo(pHotCode=0x000001F9E1BDF760, pColdCode=0x000001F9E1BDFB20, startOffset=0xa6, endOffset=0x106, unwindSize=0x0, pUnwindBlock=0x0000000000000000, funKind=1 (handler))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Function with main body NOT split, plus cold EH funclets:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Hot  code size = 0x467 bytes
Cold code size = 0x124 bytes
reserveUnwindInfo(isFunclet=false, isColdCode=false, unwindSize=0x10)
reserveUnwindInfo(isFunclet=true, isColdCode=true, unwindSize=0xe)
reserveUnwindInfo(isFunclet=true, isColdCode=true, unwindSize=0xe)
reserveUnwindInfo(isFunclet=true, isColdCode=true, unwindSize=0xe)
reserveUnwindInfo(isFunclet=true, isColdCode=true, unwindSize=0xe)
...
Unwind Info:
  &amp;gt;&amp;gt; Start offset   : 0x000000 (not in unwind data)
  &amp;gt;&amp;gt;   End offset   : 0x000467 (not in unwind data)
  Version           : 1
  Flags             : 0x00
  SizeOfProlog      : 0x0B
  CountOfUnwindCodes: 6
  FrameRegister     : none (0)
  FrameOffset       : N/A (no FrameRegister) (Value=0)
  UnwindCodes       :
    CodeOffset: 0x0B UnwindOp: UWOP_ALLOC_LARGE (1)     OpInfo: 0 - Scaled small  
      Size: 17 * 8 = 136 = 0x00088
    CodeOffset: 0x04 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rbx (3)
    CodeOffset: 0x03 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rsi (6)
    CodeOffset: 0x02 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rdi (7)
    CodeOffset: 0x01 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rbp (5)
allocUnwindInfo(pHotCode=0x000001F9E3EBE480, pColdCode=0x0000000000000000, startOffset=0x0, endOffset=0x467, unwindSize=0x10, pUnwindBlock=0x000001F9E4178288, funKind=0 (main function))
Unwind Info COLD:
  &amp;gt;&amp;gt; Start offset   : 0x000467 (not in unwind data)
  &amp;gt;&amp;gt;   End offset   : 0x00049b (not in unwind data)
allocUnwindInfo(pHotCode=0x000001F9E3EBE480, pColdCode=0x000001F9E3989DB0, startOffset=0x0, endOffset=0x34, unwindSize=0x0, pUnwindBlock=0x0000000000000000, funKind=1 (handler))
Unwind Info COLD:
  &amp;gt;&amp;gt; Start offset   : 0x00049b (not in unwind data)
  &amp;gt;&amp;gt;   End offset   : 0x0004c5 (not in unwind data)
allocUnwindInfo(pHotCode=0x000001F9E3EBE480, pColdCode=0x000001F9E3989DB0, startOffset=0x34, endOffset=0x5e, unwindSize=0x0, pUnwindBlock=0x0000000000000000, funKind=1 (handler))
Unwind Info COLD:
  &amp;gt;&amp;gt; Start offset   : 0x0004c5 (not in unwind data)
  &amp;gt;&amp;gt;   End offset   : 0x000557 (not in unwind data)
allocUnwindInfo(pHotCode=0x000001F9E3EBE480, pColdCode=0x000001F9E3989DB0, startOffset=0x5e, endOffset=0xf0, unwindSize=0x0, pUnwindBlock=0x0000000000000000, funKind=1 (handler))
Unwind Info COLD:
  &amp;gt;&amp;gt; Start offset   : 0x000557 (not in unwind data)
  &amp;gt;&amp;gt;   End offset   : 0x00058b (not in unwind data)
allocUnwindInfo(pHotCode=0x000001F9E3EBE480, pColdCode=0x000001F9E3989DB0, startOffset=0xf0, endOffset=0x124, unwindSize=0x0, pUnwindBlock=0x0000000000000000, funKind=1 (handler))
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Fri, 01 Jul 2022 01:51:44 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1922</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1922</link>
      <title>PR: Disable compProcedureSplittingEH in debug - @amanasifkhalid</title>
      <description>&lt;p&gt;Moving the code to disable &lt;code&gt;compProcedureSplittingEH&lt;/code&gt; only in Debug mode (mea culpa).&lt;/p&gt;
</description>
      <pubDate>Thu, 30 Jun 2022 18:09:24 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1921</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1921</link>
      <title>PR: R2RDump dump scratch table - @cshung</title>
      <description>&lt;p&gt;Here is a really simple implementation to dump the scratch table in R2RDump.&lt;/p&gt;
&lt;p&gt;Hopefully it can help with debugging issues.&lt;/p&gt;
</description>
      <pubDate>Thu, 30 Jun 2022 17:53:56 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1920</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1920</link>
      <title>PR: Disable EH splitting by default - @amanasifkhalid</title>
      <description>&lt;p&gt;To avoid blocking the &lt;code&gt;feature/hot-cold-splitting&lt;/code&gt; branch while implementing support for EH splitting, disable it by default.&lt;/p&gt;
</description>
      <pubDate>Thu, 30 Jun 2022 17:36:06 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1919</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1919</link>
      <title>PR: Pull from runtime-main to enable EH splitting - @amanasifkhalid</title>
      <description>&lt;p&gt;Pulling from runtime-main so we can start implementing support for hot/cold splitting of EH funclets. To avoid blocking testing, I plan to add a commit disabling EH funclet splitting by default (simply by setting &lt;code&gt;COMPlus_JitNoProcedureSplittingEH=&amp;quot;*&amp;quot;&lt;/code&gt; by default).&lt;/p&gt;
</description>
      <pubDate>Thu, 30 Jun 2022 17:30:12 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1917</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1917</link>
      <title>PR: Reflection Based Testing + Removed LinkedList - @MosheWolberg</title>
      <description>&lt;p&gt;Implemented a new testing methodology that uses reflection based off discussions with Aaron.
Changed the way method handles are added to Type definitions (no more LinkedList) based off discussions with Jan which resolved bugs in edge cases.&lt;/p&gt;
</description>
      <pubDate>Fri, 24 Jun 2022 21:52:34 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1916</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1916</link>
      <title>PR: Generated the cold code in the proper session - @EugenioPena</title>
      <description>&lt;p&gt;Fixes https://github.com/dotnet/runtimelab/issues/1901&lt;/p&gt;
&lt;p&gt;Validated the correct OS target to generate the code in the proper session depending on whether it's Unix or Windows.&lt;/p&gt;
</description>
      <pubDate>Wed, 22 Jun 2022 18:39:11 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1915</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1915</link>
      <title>PR: Add Hot-Cold splitting experiment - @cshung</title>
      <description />
      <pubDate>Wed, 22 Jun 2022 18:37:26 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1914</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1914</link>
      <title>PR: Update branding and owners for hot-cold splitting  - @hoyosjs</title>
      <description />
      <pubDate>Wed, 22 Jun 2022 00:51:22 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1900</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1900</link>
      <title>PR: Initial hot cold splitting support for crossgen2/VM - @cshung</title>
      <description>&lt;p&gt;This PR marks the start of the work to get crossgen2 to support hot/cold splitting.&lt;/p&gt;
&lt;p&gt;Here are the changes:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Added a section named &lt;code&gt;Scratch&lt;/code&gt;, to be described in (13) below for more detail.&lt;/li&gt;
&lt;li&gt;Create the &lt;code&gt;_methodColdCode&lt;/code&gt; from &lt;code&gt;_coldCode&lt;/code&gt; and &lt;code&gt;_coldCodeRelocs&lt;/code&gt; during &lt;code&gt;PublishCode&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Null &lt;code&gt;_methodColdCode&lt;/code&gt; and empty &lt;code&gt;_coldCodeRelocs&lt;/code&gt; during &lt;code&gt;CompileMethodCleanup&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Create &lt;code&gt;_methodColdCode&lt;/code&gt; during &lt;code&gt;allocMem&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Change &lt;code&gt;reserveUnwindInfo&lt;/code&gt; to ignore unwind reservation for &lt;code&gt;coldCode&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Change &lt;code&gt;allocUnwindInfo&lt;/code&gt; to ignore unwindInfo allocation for 0 bytes.&lt;/li&gt;
&lt;li&gt;Change &lt;code&gt;findKnownBlocks&lt;/code&gt; to return &lt;code&gt;_coldCodeReloc&lt;/code&gt; when &lt;code&gt;BlockType.ColdCode&lt;/code&gt; is asked for.&lt;/li&gt;
&lt;li&gt;Change &lt;code&gt;recordRelocation&lt;/code&gt; to set &lt;code&gt;relocTarget&lt;/code&gt; to &lt;code&gt;_methodColdCodeNode&lt;/code&gt; when &lt;code&gt;BlockType.ColdCode&lt;/code&gt; is asked for.&lt;/li&gt;
&lt;li&gt;Implement &lt;code&gt;MethodColdCodeNode&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Storing the cold code.&lt;/li&gt;
&lt;li&gt;Make sure sorting will place cold code blocks after hot code blocks.&lt;/li&gt;
&lt;li&gt;Make sure cold code blocks are ordered the same as the hot code blocks.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="10"&gt;
&lt;li&gt;Change &lt;code&gt;MethodGCInfoNode&lt;/code&gt; to&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Emit the chained unwind info for the cold code block, after the hot code GCInfo, so the hot and cold code unwind info are currently mixed.&lt;/li&gt;
&lt;li&gt;Changed  &lt;code&gt;CalculateFuncletOffsets&lt;/code&gt; so that the offset for the cold code chained unwind info is included if it exists.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="11"&gt;
&lt;li&gt;Changed &lt;code&gt;MethodWithGCInfo&lt;/code&gt; to:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Have a reference to the &lt;code&gt;MethodColdCodeNode&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Changed &lt;code&gt;GetFixupBlob&lt;/code&gt; to include relocation for the cold code.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="12"&gt;
&lt;li&gt;Changed &lt;code&gt;RuntimeFunctionTableNode&lt;/code&gt; to:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Emit the RuntimeFunction entries for the cold code block after the hot code blocks.&lt;/li&gt;
&lt;li&gt;Prepare the cold to hot code mapping for &lt;code&gt;ScratchNode&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="13"&gt;
&lt;li&gt;Implement &lt;code&gt;ScratchNode&lt;/code&gt; - the session is simply an array of cold code runtime function index to hot code runtime function index, so all even entries (e.g. 0, 2, 4) are cold code runtime function index and the corresponding odd indexes (e.g. 1, 3, 5) are the corresponding runtime function index for the corresponding hot code. The array is sorted by the cold code indexes, by (9), the hot code indexes should be sorted as well.&lt;/li&gt;
&lt;li&gt;Implemented the &lt;code&gt;--hot-cold-splitting&lt;/code&gt; command-line option, and turn on the &lt;code&gt;CORJIT_FLAG_PROCSPLIT&lt;/code&gt; flag as needed.&lt;/li&gt;
&lt;li&gt;Implemented the various code manager contracts:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;JitCodeToMethodInfo&lt;/code&gt; already gave us a runtime function index, we do not know if it is hot or cold, so we use the scratch table to find it. If we got an even index, that would be cold code and therefore we map it back to the hot one.&lt;/li&gt;
&lt;li&gt;Change &lt;code&gt;GetFuncletStartOffsets&lt;/code&gt; to return the cold code block as well - technically the cold block is not a funclet, but it appears that the debugger might want it.&lt;/li&gt;
&lt;li&gt;Override &lt;code&gt;IsFunclet&lt;/code&gt; so that it avoids returning &lt;code&gt;true&lt;/code&gt; for the cold code block, by searching the scratch table.&lt;/li&gt;
&lt;li&gt;Change &lt;code&gt;JitTokenToMethodRegionInfo&lt;/code&gt; so that it will find and return the cold code block - again, by search the scratch table since we already have the hot part runtimeFunction.&lt;/li&gt;
&lt;li&gt;Change &lt;code&gt;DebugDebugger&lt;/code&gt; so that it uses &lt;code&gt;EECodeInfo&lt;/code&gt; to compute relative offset instead of a simple subtraction, that will allow us to account for the cold code.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This work is far from complete - here is a list of issues filed for the project - these are known issues for now:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://github.com/dotnet/runtimelab/issues/1901&lt;/li&gt;
&lt;li&gt;https://github.com/dotnet/runtimelab/issues/1902&lt;/li&gt;
&lt;li&gt;https://github.com/dotnet/runtimelab/issues/1903&lt;/li&gt;
&lt;li&gt;https://github.com/dotnet/runtimelab/issues/1904&lt;/li&gt;
&lt;li&gt;https://github.com/dotnet/runtimelab/issues/1905&lt;/li&gt;
&lt;li&gt;https://github.com/dotnet/runtimelab/issues/1906&lt;/li&gt;
&lt;li&gt;https://github.com/dotnet/runtimelab/issues/1907&lt;/li&gt;
&lt;li&gt;https://github.com/dotnet/runtimelab/issues/1908&lt;/li&gt;
&lt;li&gt;https://github.com/dotnet/runtimelab/issues/1909&lt;/li&gt;
&lt;li&gt;https://github.com/dotnet/runtimelab/issues/1910&lt;/li&gt;
&lt;li&gt;https://github.com/dotnet/runtimelab/issues/1911&lt;/li&gt;
&lt;li&gt;https://github.com/dotnet/runtimelab/issues/1912&lt;/li&gt;
&lt;li&gt;https://github.com/dotnet/runtimelab/issues/1913&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;@amanasifkhalid, @BruceForstall&lt;/p&gt;
&lt;p&gt;@dotnet/crossgen-contrib&lt;/p&gt;
</description>
      <pubDate>Sat, 18 Jun 2022 01:13:15 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1899</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1899</link>
      <title>PR: Empty Assembly Functionality - @MosheWolberg</title>
      <description>&lt;p&gt;This is the first prototype of writing and reading of a simple blank assembly with a single module with a new version of Assembly Builder and ModuleBuilder. The other Builders will be implemented as the project expands scope. There was theoretical support for multiple modules and that's why I created a dictionary for storing modules. But I discovered that MetadataBuilder wouldn't let me add multiple modules so that was rendered moot and anyways @AaronRobinsonMSFT told me not practical or relevant.
See the comments for design points and some questions.
I assume I'll move onto basic types (Interfaces) next.
There is also the second niche constructor for AssemblyBuilder but I'm not sure if that's as important to work on now.&lt;/p&gt;
</description>
      <pubDate>Wed, 15 Jun 2022 00:53:25 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1898</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1898</link>
      <title>PR: MyPRBranch - Surface Area of AsssemblyBuilder API - @MosheWolberg</title>
      <description>&lt;p&gt;Created basic outline to match existing API of Assembly Builder. Next step will be to create EMAC compliant image of a simple empty assembly.&lt;/p&gt;
</description>
      <pubDate>Mon, 13 Jun 2022 21:09:42 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1895</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1895</link>
      <title>PR: New Readme - @MosheWolberg</title>
      <description>&lt;p&gt;ReadMe and filenames changed @joperezr&lt;/p&gt;
</description>
      <pubDate>Fri, 10 Jun 2022 00:00:47 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1894</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1894</link>
      <title>PR: Following steps for stand-alone experiment - @joperezr</title>
      <description>&lt;p&gt;cc: @MosheWolberg @ericstj FYI&lt;/p&gt;
</description>
      <pubDate>Thu, 09 Jun 2022 22:11:38 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/pull/1893</guid>
      <link>https://github.com/dotnet/runtimelab/pull/1893</link>
      <title>PR: Update README.md - @joperezr</title>
      <description>&lt;p&gt;cc: @MosheWolberg @ericstj&lt;/p&gt;
&lt;p&gt;Preparing our branch for the experiment of AssemblyBuilder.Save()&lt;/p&gt;
</description>
      <pubDate>Thu, 09 Jun 2022 21:44:07 Z</pubDate>
    </item>
  </channel>
</rss>