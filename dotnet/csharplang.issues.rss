<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>dotnet/csharplang Issues</title>
    <description>Issues from https://github.com/dotnet/csharplang, generated by https://github.com/meziantou/IssuesToRss/</description>
    <managingEditor>meziantousite@outlook.com</managingEditor>
    <ttl>60</ttl>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6476</guid>
      <link>https://github.com/dotnet/csharplang/issues/6476</link>
      <title>Issue: [Proposal]: Change ref safety errors to warnings in unsafe contexts - @jaredpar</title>
      <description>&lt;h1&gt;Change ref safety errors to warnings inside unsafe&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;[x] Proposed&lt;/li&gt;
&lt;li&gt;[ ] Prototype: Not Started&lt;/li&gt;
&lt;li&gt;[ ] Implementation: Not Started&lt;/li&gt;
&lt;li&gt;[ ] Specification: Not Started&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;The language will downgrade &lt;code&gt;ref&lt;/code&gt; errors to a warning inside an &lt;code&gt;unsafe&lt;/code&gt; context.&lt;/p&gt;
&lt;h2&gt;Motivation&lt;/h2&gt;
&lt;p&gt;The set of &lt;code&gt;ref&lt;/code&gt; and features in C# are concerned with providing type safe access to memory references. This includes &lt;code&gt;ref&lt;/code&gt; returns, &lt;code&gt;ref&lt;/code&gt; fields, &lt;code&gt;in&lt;/code&gt;, etc ... The features are very successful in providing the expressiveness required by our API authors and developers. The analysis though is naturally very conservative. Essentially there are many scenarios in which &lt;code&gt;ref&lt;/code&gt; could be used safely but it is flagged as an error because the conservative nature of our analysis does not understand the use case.&lt;/p&gt;
&lt;p&gt;Today this results in a hard error being produced and the language contains no escape hatch. Instead when developers confront these cases they must rely on runtime APIs. For example &lt;a href="https://grep.app/search?q=Unsafe.AsRef"&gt;Unsafe.AsRef&lt;/a&gt; as a way to work around these limitations.&lt;/p&gt;
&lt;p&gt;Relying on runtime APIs has a number of significant drawbacks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;They cannot be relied on in multi-targeting scenarios. When a new API in &lt;code&gt;net7.0&lt;/code&gt; to support a C# 11 feature that cannot be used when multi-targeting between &lt;code&gt;net7.0&lt;/code&gt; and say &lt;code&gt;net6.0&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;They require non-trivial JIT work. The APIs cannot be implemented in C# code. It must be implemented as a codegen / JIT trick and done so such that it's a wash. The API intent is to really have no impact on the final code, it's an annotation.&lt;/li&gt;
&lt;li&gt;APIs cannot easily express some aspects of the language. Consider for example that &lt;a href="https://grep.app/search?q=Unsafe.AsRef"&gt;Unsafe.AsRef&lt;/a&gt; does not work for a &lt;code&gt;ref struct&lt;/code&gt; and designing an API that does is virtually impossible due to lack of generic support.&lt;/li&gt;
&lt;li&gt;It hides the actual problems. These APIs effectively turn off language analysis so there&lt;/li&gt;
&lt;li&gt;It's ugly to read long streams of &lt;code&gt;Unsafe.AsRef&lt;/code&gt; calls&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The language already has a mechanism to allow for type and memory safety violations: &lt;code&gt;unsafe&lt;/code&gt; context. It is already possible to violate memory safety using &lt;code&gt;unsafe&lt;/code&gt; that would allow for exactly the same type of problems that &lt;code&gt;ref&lt;/code&gt; safety means to prevent. When the language is viewed in its totality it's inconsistent that we allow effectively unlimited memory safety violations with pointers (where we have no tracking of what you can do) but don't allow for a much more constrained violation (when compiler can help identify the exact points and reasons for unsafety).&lt;/p&gt;
&lt;p&gt;Downgrading &lt;code&gt;ref&lt;/code&gt; safety errors to warnings allows for an escape hatch for developers. It still requires three levels of acknowledgement of the safety issues: &lt;code&gt;/unsafe&lt;/code&gt; compiler switch, &lt;code&gt;unsafe&lt;/code&gt; context and suppression of the emitted diagnostic. It also means curious developers can quickly see what violations exist by removing the warning suppressions.&lt;/p&gt;
&lt;h2&gt;Detailed design&lt;/h2&gt;
&lt;p&gt;The language will identify the errors which fall into the &lt;code&gt;ref&lt;/code&gt; memory safety category. For each which &amp;quot;break glass in case of emergency&amp;quot; is required the compilre will provide a warning to pair with the error. In the case the diagnostic occurs in &lt;code&gt;unsafe&lt;/code&gt; the warning will be used instead of the error.&lt;/p&gt;
&lt;p&gt;Initially the error codes will include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Address of&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ref&lt;/code&gt; lifetime violations&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example of the impact this will have:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;static void M1(ref A a)
{
    B b = CreateB(stackalloc byte[42]);
    M2(ref a, ref b);
}

static Span&amp;lt;byte&amp;gt; M2(ref A a, ref B b)
{
  // b never assigns through a so this is safe, we just can't represent it
}

ref struct A { }
ref struct B{ }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Drawbacks&lt;/h2&gt;
&lt;p&gt;It increase the power of &lt;code&gt;unsafe&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Alternatives&lt;/h2&gt;
&lt;p&gt;The alternative is we continue to lean on the runtime team to provide APIs which act as safety hatches for &lt;code&gt;unsafe&lt;/code&gt;. This means more APIs like &lt;code&gt;Unsafe.AsRef&lt;/code&gt;. This functions but has several downsides including cost to JIT team, cost to API design and that it doesn't work in multi-targeted scenarios.&lt;/p&gt;
&lt;h2&gt;Unresolved questions&lt;/h2&gt;
&lt;p&gt;The full set of errors that should fall into this category. There are several we know are in the initial set. The team would be open to more errors falling into this category given compelling scenarios existing.&lt;/p&gt;
&lt;p&gt;The other question is whether &lt;code&gt;readonly&lt;/code&gt; violations should fall under the same umbrella. Generally &lt;code&gt;readonly&lt;/code&gt; is there for memory safety reasons, ensuring a piece of memory is not written to. Downgrading that to a warning would seemingly fit into the same category.&lt;/p&gt;
&lt;h2&gt;Design meetings&lt;/h2&gt;
&lt;h2&gt;Related&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://github.com/dotnet/roslyn/issues/63104&lt;/li&gt;
&lt;li&gt;https://github.com/dotnet/roslyn/pull/64064&lt;/li&gt;
&lt;li&gt;https://github.com/dotnet/csharplang/pull/6453&lt;/li&gt;
&lt;/ul&gt;
</description>
      <pubDate>Tue, 20 Sep 2022 21:07:31 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6420</guid>
      <link>https://github.com/dotnet/csharplang/issues/6420</link>
      <title>Issue: [Proposal]: Partial properties - @RikkiGibson</title>
      <description>&lt;h1&gt;Partial properties&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;[x] Proposed&lt;/li&gt;
&lt;li&gt;[ ] Prototype: &lt;a href="https://github.com/PROTOTYPE_OWNER/roslyn/BRANCH_NAME"&gt;Not Started&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[ ] Implementation: &lt;a href="https://github.com/dotnet/roslyn/BRANCH_NAME"&gt;Not Started&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[ ] Specification: &lt;a href="pr/1"&gt;Not Started&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;Allow the &lt;code&gt;partial&lt;/code&gt; modifier on properties to separate declaration and implementation parts, similar to partial methods.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;// UserCode.cs
public partial class ViewModel : INotifyPropertyChanged
{
    public event PropertyChangedEventHandler PropertyChanged;

    [NotifyPropertyChanged]
    public partial string UserName { get; set; }
}

// Generated.cs
public partial class ViewModel
{
    private string __generated_userName;

    public partial string UserName
    {
        get =&amp;gt; __generated_userName;
        set
        {
            if (value != __generated_userName)
            {
                __generated_userName = value;
                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(UserName)));
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Motivation&lt;/h2&gt;
&lt;p&gt;When we did &lt;a href="https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/extending-partial-methods.md"&gt;extended partial methods&lt;/a&gt;, we indicated we would like to consider adding support for other kinds of partial members in the future. The community has &lt;a href="https://github.com/dotnet/csharplang/discussions/3412"&gt;shown enthusiasm&lt;/a&gt; for partial properties in particular.&lt;/p&gt;
&lt;p&gt;.NET has a number of scenarios where a property implementation is some kind of boilerplate. One of the most prominent cases is &lt;code&gt;INotifyPropertyChanged&lt;/code&gt;, as seen above. Another is &lt;a href="https://docs.microsoft.com/en-us/dotnet/desktop/wpf/properties/dependency-properties-overview?view=netdesktop-6.0"&gt;dependency properties&lt;/a&gt;. There are currently production source generators designed to handle these scenarios. These currently work by having the user write a field and having the generator add the corresponding property.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;// UserCode.cs
public partial class ViewModel : INotifyPropertyChanged
{
    public event PropertyChangedEventHandler PropertyChanged;

    [NotifyPropertyChanged]
    private string _userName;
}

// Generated.cs
public partial class ViewModel
{
    public string UserName
    {
        get =&amp;gt; /* ... */;
        set
        {
            // ...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Under this scheme, users have to become familiar with the conventions for how the generator creates properties based on their fields. Additional workarounds are needed for users to be able to change accessibility, virtual-ness, attributes, or other aspects of the generated property. Also, using features like find-all-references requires navigating to the generated property, instead of being able to just look at the declarations in user code. All of these issues are solved fairly naturally by adding partial properties to the language.&lt;/p&gt;
&lt;h2&gt;Detailed design&lt;/h2&gt;
&lt;h3&gt;Grammar&lt;/h3&gt;
&lt;p&gt;The &lt;em&gt;property_declaration&lt;/em&gt; grammar &lt;a href="https://github.com/dotnet/csharpstandard/blob/draft-v7/standard/classes.md#1471-general"&gt;(§14.7.1)&lt;/a&gt; is updated as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-diff"&gt;property_declaration
-    : attributes? property_modifier* type member_name property_body
+    : attributes? property_modifier* 'partial'? type member_name property_body
    ;  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Remarks&lt;/strong&gt;: This is similar to how &lt;em&gt;method_header&lt;/em&gt; &lt;a href="https://github.com/dotnet/csharpstandard/blob/draft-v7/standard/classes.md#1461-general"&gt;(§14.6.1)&lt;/a&gt; and &lt;em&gt;class_declaration&lt;/em&gt; &lt;a href="https://github.com/dotnet/csharpstandard/blob/draft-v7/standard/classes.md#1421-general"&gt;(§14.2.1)&lt;/a&gt; are specified. (Note that &lt;a href="https://github.com/dotnet/csharplang/issues/946"&gt;Issue #946&lt;/a&gt; proposes to relax the ordering requirement, and would probably apply to all declarations which allow the &lt;code&gt;partial&lt;/code&gt; modifier.)&lt;/p&gt;
&lt;h3&gt;Defining and implementing declarations&lt;/h3&gt;
&lt;p&gt;When a property declaration includes a &lt;em&gt;partial&lt;/em&gt; modifier, that property is said to be a &lt;em&gt;partial property&lt;/em&gt;. Partial properties may only be declared as members of partial types.&lt;/p&gt;
&lt;p&gt;A &lt;em&gt;partial property&lt;/em&gt; declaration is said to be a &lt;em&gt;defining declaration&lt;/em&gt; when its accessors all have semicolon bodies, and it lacks the &lt;code&gt;extern&lt;/code&gt; modifier. Otherwise, it is an &lt;em&gt;implementing declaration&lt;/em&gt;. A &lt;em&gt;partial property&lt;/em&gt; cannot be an auto-property.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;partial class C
{
    // Defining declaration
    public partial string Prop { get; set; }

    // Implementing declaration
    public partial string Prop { get =&amp;gt; field; set =&amp;gt; field = value; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Remarks&lt;/strong&gt;. It is useful for the compiler to be able to look at a single declaration in isolation and know whether it is a defining or an implementing declaration. Therefore we don't want to permit auto-properties by including two identical &lt;code&gt;partial&lt;/code&gt; property declarations, for example. We don't think that the use cases for this feature involve implementing the partial property with an auto-property, but in cases where a trivial implementation is desired, we think the &lt;code&gt;field&lt;/code&gt; keyword makes things simple enough.&lt;/p&gt;
&lt;p&gt;A partial property must have one &lt;em&gt;defining declaration&lt;/em&gt; and one &lt;em&gt;implementing declaration&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remarks&lt;/strong&gt;. We also don't think it is useful to allow splitting the declaration across more than two parts, to allow different accessors to be implemented in different places, for example. Therefore we simply imitate the scheme established by partial methods.&lt;/p&gt;
&lt;p&gt;Similar to partial methods, the attributes in the resulting property are the combined attributes of the parts are concatenated in an unspecified order, and duplicates are not removed.&lt;/p&gt;
&lt;p&gt;Only the defining declaration of a partial property participates in lookup, similar to how only the defining declaration of a partial method participates in overload resolution.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remarks&lt;/strong&gt;. In the compiler, we would expect that only the symbol for the defining declaration appears in the member list, and the symbol for the implementing part can be accessed through the defining symbol. However, some features like nullable analysis might &lt;em&gt;see through&lt;/em&gt; to the implementing declaration in order to provide more useful behavior.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;partial class C
{
    public partial string Prop { get; set; }
    public partial string Prop { get =&amp;gt; field; set =&amp;gt; field = value; }

    public C() // warning CS8618: Non-nullable property 'Prop' must contain a non-null value when exiting constructor. Consider declaring the property as nullable.
    {
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Matching signatures&lt;/h3&gt;
&lt;p&gt;The property declarations must have the same type and ref kind. The property declarations must have the same set of accessors.&lt;/p&gt;
&lt;p&gt;The property declarations and their accessor declarations must have the same modifiers, though the modifiers may appear in a different order. This does not apply to the &lt;code&gt;extern&lt;/code&gt; modifier, which may only appear on an &lt;em&gt;implementing declaration&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;A partial property is not permitted to have the &lt;code&gt;abstract&lt;/code&gt; modifier.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;partial class C
{
    public partial string Prop { get; private set; }

    // Error: accessor modifier mismatch in 'set' accessor of 'Prop'
    public partial string Prop { get =&amp;gt; field; set =&amp;gt; field = value; }
}

partial class C
{
    public partial string Prop { get; init; }

    // Error: implementation of 'Prop' must have an 'init' accessor to match definition
    public partial string Prop { get =&amp;gt; field; set =&amp;gt; field = value; }
}

partial class C
{
    public partial string Prop { get; }

    // Error: implementation of 'Prop' cannot have a 'set' accessor because the definition does not have a 'set' accessor.
    public partial string Prop { get =&amp;gt; field; set =&amp;gt; field = value; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Drawbacks&lt;/h2&gt;
&lt;p&gt;As always, this feature adds to the language concept count and must be weighed accordingly.&lt;/p&gt;
&lt;p&gt;The fact that adding the &lt;code&gt;partial&lt;/code&gt; modifier can change an auto-property declaration to a defining partial declaration may be confusing.&lt;/p&gt;
&lt;h2&gt;Alternatives&lt;/h2&gt;
&lt;p&gt;We could consider more flexible designs which permit different accessor definitions or implementations to be spread across different declarations.&lt;/p&gt;
&lt;p&gt;We could consider introducing some special way to denote that a partial property implementation is an auto-property, separate from the &lt;code&gt;field&lt;/code&gt; keyword.&lt;/p&gt;
&lt;p&gt;We could also consider doing nothing, which means that source generators and perhaps our tooling will need to establish conventions for working around the limitations of the field-based approach.&lt;/p&gt;
&lt;h2&gt;Unresolved questions&lt;/h2&gt;
&lt;p&gt;Should we permit partial indexers as part of this feature? It would increase orthogonality to allow this, but the word &amp;quot;indexer&amp;quot; is mentioned zero times since 2020 in the community discussion for this feature.&lt;/p&gt;
&lt;p&gt;Similarly, should we permit other kinds of partial members like fields, events, constructors, operators, etc? The same is mentioned in &lt;a href="https://github.com/dotnet/csharplang/blob/main/proposals/csharp-9.0/extending-partial-methods.md#partial-on-all-members"&gt;extending-partial-methods.md&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Design meetings&lt;/h2&gt;
&lt;p&gt;https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-08-31.md#partial-properties&lt;/p&gt;
</description>
      <pubDate>Tue, 30 Aug 2022 22:22:01 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6393</guid>
      <link>https://github.com/dotnet/csharplang/issues/6393</link>
      <title>Issue: [Proposal]: Partial-block only accessibility (private blockonly) - @noahthegame0</title>
      <description>&lt;p&gt;&lt;strong&gt;Summary&lt;/strong&gt;
A new accessibility keyword for members (or types) used within partial types similar to &lt;code&gt;private&lt;/code&gt; except it limits accessibility to the &amp;quot;partial-block&amp;quot; in which it was defined.&lt;/p&gt;
&lt;p&gt;Consider the example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;public partial class Test 
{
  private int x;
  void ValidTestMethod()
  {
    x++;
  }
}

//Somewhere else in our file or in a different file:
partial class Test
{
  void BrokenTestMethod()
  {
    x++;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So far this would still be allowed, but image we replaced &lt;code&gt;private&lt;/code&gt; with a new keyword (lets call it &lt;code&gt;private blockonly&lt;/code&gt; for now, I'll gladly take suggestions for what the best name for the keyword would be) such that our &lt;code&gt;x&lt;/code&gt; field looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;private blockonly int x;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The increment (the reference to &lt;code&gt;x&lt;/code&gt;) in our &lt;code&gt;BrokenTestMethod&lt;/code&gt; method would generate an accessibility compiler error because &lt;code&gt;x&lt;/code&gt; is defined outside of the current &amp;quot;partial-block&amp;quot;
But our &lt;code&gt;ValidTestMethod&lt;/code&gt; won't because &lt;code&gt;x&lt;/code&gt; is defined within the same &amp;quot;partial-block&amp;quot;.&lt;/p&gt;
&lt;p&gt;The same applies to any member defined in a partial type (including types)
A class for instance would just simply be defined as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;partial class Test 
{
  private blockonly class Test2 {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The existing behaviour of &lt;code&gt;private&lt;/code&gt; (both in partial types and non-partial types) will of course remain the same&lt;/p&gt;
&lt;p&gt;Our new keyword would of course be stackable with other keyword if the user so desires such as:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;private blockonly readonly ref struct TestStruct {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;just to name a long example.
Although it would &lt;strong&gt;NOT&lt;/strong&gt; be stackable with other accessibility keywords like &lt;code&gt;internal&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, etc.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Motivation&lt;/strong&gt;
I personally use partial classes a lot, having a part of my type in multiple files (or perhaps multiple places within 1 file) is my preferred way to organize my code. Some developers like making &amp;quot;base classes&amp;quot; or perhaps &amp;quot;static helpers classes&amp;quot; of which I do a fair bit too, but I could really get a lot of use of this new feature even while mixing some of those techniques in.&lt;/p&gt;
&lt;p&gt;Like for instances if I write a method that needs fields, but those fields only gets accessed within that method or within that area of my code, blockonly would help to prevent polluting the rest of my type when writing features or methods within that type.
Another Way is to append such fields with &lt;code&gt;_&lt;/code&gt; or even &lt;code&gt;__&lt;/code&gt; which is generally how I fix such a scenario, but that is a bit messy, and I believe this feature will help with this by a lot&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Editor Alternatives (Perhaps?)&lt;/strong&gt;
If anyone knows of an visual studio extension (perhaps?) that would do something similar I would be very interested in that.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;No potential .Net Issues (As far as my understanding goes)&lt;/strong&gt;
As far as my understanding goes, this should be possible even while following the .net specifications because when partial types get compiled they all get added into the same type as if they were never partial to begin with thus the behaviour of existing runtime accessibility checks will remain the same.
This is thus syntax sugar which won't be embedded anywhere once the code is compiled&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ending&lt;/strong&gt;
This is my first time submitting a proposal, if I'm missing any information of if I have misunderstood the guidelines please let me know so I can correct it as far as possible.
Please feel free to comment what you think about this proposal, I'm interested to see what you people out there think of it&lt;/p&gt;
</description>
      <pubDate>Sat, 20 Aug 2022 00:44:31 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6368</guid>
      <link>https://github.com/dotnet/csharplang/issues/6368</link>
      <title>Issue: Missing nullable check when creating fixed length array - @HavenDV</title>
      <description>&lt;!--
Please keep in mind that the GitHub issue tracker is not intended as a general support forum, but for reporting **non-security** bugs and feature requests.

If you believe you have an issue that affects the SECURITY of the platform, please do NOT create an issue and instead email your issue details to secure@microsoft.com. Your report may be eligible for our [bug bounty](https://www.microsoft.com/en-us/msrc/bounty-dot-net-core) but ONLY if it is reported through email.
For other types of questions, consider using [StackOverflow](https://stackoverflow.com).

--&gt;
&lt;h3&gt;Describe the bug&lt;/h3&gt;
&lt;p&gt;Strangely, this code doesn't issue any warnings, even though the array will contain 10 null values&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;#nullable enable

Type[] types = new Type[10];
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;To Reproduce&lt;/h3&gt;
&lt;!--
We ❤ code! Point us to a minimalistic repro project hosted in a GitHub repo, Gist snippet, or other means to see the isolated behavior.

We may close this issue if:
- the repro project you share with us is complex. We can't investigate custom projects, so don't point us to such, please.
- if we will not be able to repro the behavior you're reporting
--&gt;
&lt;h3&gt;Exceptions (if any)&lt;/h3&gt;
&lt;!-- 
Include the exception you get when facing this issue
--&gt;
&lt;h3&gt;Further technical details&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Include the output of &lt;code&gt;dotnet --info&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Microsoft Windows [Version 10.0.22621.105]
(c) Microsoft Corporation. All rights reserved.

C:\Users\haven&amp;gt;dotnet --info
.NET SDK:
 Version:   7.0.100-preview.6.22352.1
 Commit:    492644e08e

Runtime Environment:
 OS Name:     Windows
 OS Version:  10.0.22621
 OS Platform: Windows
 RID:         win10-x64
 Base Path:   C:\Program Files\dotnet\sdk\7.0.100-preview.6.22352.1\

Host:
  Version:      7.0.0-preview.6.22324.4
  Architecture: x64
  Commit:       d3fa592f6d

.NET SDKs installed:
  6.0.400 [C:\Program Files\dotnet\sdk]
  7.0.100-preview.6.22352.1 [C:\Program Files\dotnet\sdk]

.NET runtimes installed:
  Microsoft.AspNetCore.App 3.1.28 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 6.0.8 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.AspNetCore.App 7.0.0-preview.6.22330.3 [C:\Program Files\dotnet\shared\Microsoft.AspNetCore.App]
  Microsoft.NETCore.App 3.1.28 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 6.0.8 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.NETCore.App 7.0.0-preview.6.22324.4 [C:\Program Files\dotnet\shared\Microsoft.NETCore.App]
  Microsoft.WindowsDesktop.App 3.1.28 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]
  Microsoft.WindowsDesktop.App 6.0.8 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]
  Microsoft.WindowsDesktop.App 7.0.0-preview.6.22351.3 [C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App]

Other architectures found:
  x86   [C:\Program Files (x86)\dotnet]

Environment variables:
  Not set

global.json file:
  Not found
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The IDE (VS / VS Code/ VS4Mac) you're running on, and its version
VS 17.3&lt;/li&gt;
&lt;/ul&gt;
</description>
      <pubDate>Sat, 13 Aug 2022 11:21:34 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6359</guid>
      <link>https://github.com/dotnet/csharplang/issues/6359</link>
      <title>Issue: Should `required` on a property force it to be nullable in the constructor always - @333fred</title>
      <description>&lt;p&gt;Today, when decide the state of all properties at the start of a constructor, we assume that all properties from the base type have been initialized by the chained constructor. However, this might not be true of required properties. Consider the following scenario:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;#nullable enable
public class Base
{
    public required string Prop1 { get; set; }
}
public class Derived : Base
{
     public required string Prop2 { get; set; }

    [SetsRequiredMembers]
    public Derived(int unused) : base()
    {
        Prop1.ToString(); // Warning?
        Prop2.ToString(); // Warning: possibly null dereference
    } // Warning that Prop2 has a maybenull value. Does Prop1 get a warning?
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Prop1&lt;/code&gt; is an auto-implemented property, but we might not always know that this is the case. From source, this is relatively easy to detect, but if &lt;code&gt;Base&lt;/code&gt; is defined in metadata then this becomes much harder to detect.&lt;/p&gt;
&lt;p&gt;I propose that &lt;code&gt;required&lt;/code&gt; is enough of an indicator for the purposes of nullable analysis that we should make the initial state of properties marked &lt;code&gt;required&lt;/code&gt; &lt;code&gt;default(PropertyType)&lt;/code&gt;, regardless of whether the property is known to be an auto-property or not.&lt;/p&gt;
</description>
      <pubDate>Wed, 10 Aug 2022 00:07:40 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6401</guid>
      <link>https://github.com/dotnet/csharplang/issues/6401</link>
      <title>Issue: Expression bodied catch blocks - @ogjtech</title>
      <description>&lt;p&gt;Sometimes in code, we have multiple &lt;code&gt;catch&lt;/code&gt;-blocks if we want different exception handling behaviour for different types of exceptions. That behaviour could consist of many lines, but it could also simply be a method call, or an alternative &lt;code&gt;return&lt;/code&gt; statement.
In many other places in code, i.e. constructors, get-only properties or methods, you could turn it into an expression-bodied function to reduce lines of code and make code generally cleaner.&lt;/p&gt;
&lt;p&gt;I think it would be good if this could be done for &lt;code&gt;catch&lt;/code&gt;-blocks as well.&lt;/p&gt;
&lt;h1&gt;Why?&lt;/h1&gt;
&lt;p&gt;Currently, in my controller layer I am handling specific types of exceptions in actions.
The code looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c-sharp"&gt;try
{
    var result = await _manager.Foo(id, ct);

    return result ? NoContent() : BadRequest(ModelState);
}
catch (DataConflictException e)
{
    return Conflict(e);
}
catch (NotFoundException e)
{
    return NotFound(e);
}
catch (BadRequestException e)
{
    return BadRequest(e);
}
catch (UnauthorizedException e)
{
    return Unauthorized(e);
}
catch (Exception e)
{
    return StatusCode(StatusCodes.Status500InternalServerError, e);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, the &lt;code&gt;catch&lt;/code&gt;-blocks currently add 19 extra lines to the function body. I think it would be great if I could write the above codes as below:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c-sharp"&gt;try
{
    var result = await _workOrderTaskManager.SetStatusToFeasible(subsidiaryId, branchId, workOrderId, ct);

    return result ? NoContent() : BadRequest(ModelState);
}
catch (DataConflictException e) =&amp;gt; Conflict(e);
catch (NotFoundException e) =&amp;gt; NotFound(e);
catch (BadRequestException e) =&amp;gt; BadRequest(e);
catch (UnauthorizedException e) =&amp;gt; Unauthorized(e);
catch (Exception e) =&amp;gt; StatusCode(StatusCodes.Status500InternalServerError, e);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Above code reduces the &lt;code&gt;catch&lt;/code&gt;-blocks to just 5, one line for each block.
Of course, one could also simply create a single exception handling method in which all these different exceptions are handled, but defining &lt;code&gt;catch&lt;/code&gt;-blocks this way could in general drastically reduce lines of code.&lt;/p&gt;
</description>
      <pubDate>Thu, 04 Aug 2022 07:38:39 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6337</guid>
      <link>https://github.com/dotnet/csharplang/issues/6337</link>
      <title>Issue: [Proposal]: Recent changes to ref fields specification - @cston</title>
      <description>&lt;p&gt;Summarizing recent changes to the &lt;a href="https://github.com/dotnet/csharplang/blob/main/proposals/low-level-struct-improvements.md"&gt;ref fields specification&lt;/a&gt; and related questions.&lt;/p&gt;
&lt;h2&gt;1. &lt;code&gt;ref scoped&lt;/code&gt; removed&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ref scoped&lt;/code&gt; has been removed.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;scoped&lt;/code&gt; is now limited to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;by-ref parameters and locals&lt;/li&gt;
&lt;li&gt;by-value &lt;code&gt;ref struct&lt;/code&gt; parameters and locals&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;static void F1(scoped in int i) { }        // scoped ref: ok
static void F2(scoped Span&amp;lt;int&amp;gt; s) { }     // scoped ref struct: ok
static void F3(ref scoped Span&amp;lt;int&amp;gt; s) { } // ref scoped: not supported
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ref scoped&lt;/code&gt; does not prevent assigning through the &lt;code&gt;ref&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;static void F3(ref scoped Span&amp;lt;int&amp;gt; s)
{
    s = stackalloc int[] { 1 }; // escapes to caller
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;2. &lt;code&gt;ref&lt;/code&gt; field cannot refer to a &lt;code&gt;ref struct&lt;/code&gt; type&lt;/h2&gt;
&lt;p&gt;Until now, the feature has codified existing C#10 rules, while adding support for &lt;code&gt;ref&lt;/code&gt; fields.&lt;/p&gt;
&lt;p&gt;Allowing &lt;code&gt;ref&lt;/code&gt; fields to &lt;code&gt;ref struct&lt;/code&gt; types would require additional escape rules.&lt;/p&gt;
&lt;p&gt;First, a &lt;code&gt;readonly ref struct&lt;/code&gt; could store &lt;code&gt;ref&lt;/code&gt; state.
That means a &lt;code&gt;readonly ref struct&lt;/code&gt; argument to a method is now a potential place that references can be captured.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;readonly ref struct Container
{
    readonly ref Span&amp;lt;int&amp;gt; Span;

    void Store(Span&amp;lt;int&amp;gt; s) { Span = s; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Second, we'd need to track lifetime of nested refs.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;ref struct Container
{
    public ref Span&amp;lt;int&amp;gt; Nested;
}

Span&amp;lt;int&amp;gt; GetSpan(ref Container container) =&amp;gt; container.Nested; // lifetime no shorter than container
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;See &lt;a href="https://github.com/dotnet/csharplang/blob/main/proposals/low-level-struct-improvements.md#ref-fields-to-ref-struct"&gt;ref fields to ref struct&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;3. Certain parameters are implicitly &lt;code&gt;scoped&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;The recent change is to treat &lt;code&gt;ref&lt;/code&gt; parameters that refer to &lt;code&gt;ref struct&lt;/code&gt; types as implicitly &lt;code&gt;scoped&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;That addition means the set of parameters that are implicitly &lt;code&gt;scoped&lt;/code&gt; is now:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;this&lt;/code&gt; for &lt;code&gt;struct&lt;/code&gt; instance methods&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ref&lt;/code&gt; parameters that refer to &lt;code&gt;ref struct&lt;/code&gt; types&lt;/li&gt;
&lt;li&gt;&lt;code&gt;out&lt;/code&gt; parameters&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first case, &lt;code&gt;this&lt;/code&gt; for &lt;code&gt;struct&lt;/code&gt; instance methods, is for compatibility with C#10 rules which considered &lt;code&gt;this&lt;/code&gt; implicitly &lt;code&gt;scoped&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The downside to implicitly scoping &lt;code&gt;this&lt;/code&gt; is a &lt;code&gt;struct&lt;/code&gt; instance method cannot return a field by reference.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;struct S
{
    public int F;
    ref int GetRef() =&amp;gt; ref F; // error: cannot return 'this' or members by ref
}

static ref int GetRef(ref S s) =&amp;gt; ref s.F; // ok
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Making &lt;code&gt;this&lt;/code&gt; unscoped for &lt;code&gt;ref struct&lt;/code&gt; types would be a significant breaking change.
It would allow instance members of a mutable &lt;code&gt;ref struct&lt;/code&gt; to ref re-assign to fields in the &lt;code&gt;ref struct&lt;/code&gt;, requiring additional escape rules:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;ref struct Sneaky
{
    int Field;
    ref int RefField;

    void SelfAssign()
    {
        RefField = ref Field; // illegal with existing rules
    }

    static Sneaky UseExample()
    {
        Sneaky local = default;
        local.SelfAssign();
        return local; // local.RefField escapes to caller
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The second case, &lt;code&gt;ref&lt;/code&gt; parameters of &lt;code&gt;ref struct&lt;/code&gt; types, is similar to the previous case.
If not scoped, it would allow a mutable &lt;code&gt;ref struct&lt;/code&gt; to ref re-assign to fields in the &lt;code&gt;ref struct&lt;/code&gt;, adding escape rules, and potentially making APIs that include &lt;code&gt;ref struct&lt;/code&gt; receivers or parameters as difficult to use.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;static void DoSomething(ref Sneaky s) { ... }

static Sneaky UseExample()
{
    Sneaky s = default; // safe-to-escape to caller
    DoSomething(ref s); // compiler must assume self-assignment
    return s;           // error
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The third case, &lt;code&gt;out&lt;/code&gt; parameters, is to reduce the impact of considering ref parameters as returnable in ref fields.
In C#10, the scope of ref arguments including &lt;code&gt;out&lt;/code&gt; arguments were considered in ref returning methods, but were not considered returnable in &lt;code&gt;ref struct&lt;/code&gt; values.
In C#11, we need to consider that ref arguments may be returned in &lt;code&gt;ref struct&lt;/code&gt; values.
Implicitly scoping &lt;code&gt;out&lt;/code&gt; reduces the impact of that breaking change.
It also means &lt;code&gt;out&lt;/code&gt; is intuitively treated as &lt;code&gt;out&lt;/code&gt; only.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;static ref int CreateRef(ref int x, out int y) { ... }
static Span&amp;lt;int&amp;gt; CreateSpan(ref int x, out int y) { ... }

static ref int F1(ref int x)
{
    int y;
    return ref CreateRef(ref x, out y); // C#10: cannot return 'y'; C#11: ok
}

static Span&amp;lt;int&amp;gt; F2(ref int x)
{
    int y;
    return CreateSpan(ref x, out y);    // C#10: ok; C#11: ok
}

static Span&amp;lt;int&amp;gt; F3()
{
    int x = 42;
    int y;
    return CreateSpan(ref x, out y);    // C#10: ok; C#11: cannot return 'x'
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;See &lt;a href="https://github.com/dotnet/csharplang/blob/main/proposals/low-level-struct-improvements.md#implicitly-scoped"&gt;implicitly scoped&lt;/a&gt;, &lt;a href="https://github.com/dotnet/csharplang/blob/main/proposals/low-level-struct-improvements.md#unscoped-this-by-default"&gt;Unscoped this by default?&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;4. &lt;code&gt;scoped&lt;/code&gt; is emitted as &lt;code&gt;ScopedRefAttribute&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Should the attribute be emitted for implicitly &lt;code&gt;scoped&lt;/code&gt; parameters?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;For &lt;code&gt;out&lt;/code&gt; parameters that were considered unscoped in C#10?&lt;/li&gt;
&lt;li&gt;Only for methods where a reference could escape (method has a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;ref struct&lt;/code&gt; parameter and returns a &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;ref struct&lt;/code&gt;)?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Should the attribute definition be added to the BCL or synthesized by the compiler?&lt;/p&gt;
&lt;p&gt;&lt;em&gt;See &lt;a href="https://github.com/dotnet/csharplang/blob/main/proposals/low-level-struct-improvements.md#scopedrefattribute"&gt;ScopedRefAttribute&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;5. &lt;code&gt;UnscopedRefAttribute&lt;/code&gt; replaces proposed &lt;code&gt;unscoped&lt;/code&gt; keyword&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Can be applied to any &lt;code&gt;ref&lt;/code&gt; that is implicitly &lt;code&gt;scoped&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Can be applied to implicit &lt;code&gt;this&lt;/code&gt; in &lt;code&gt;struct&lt;/code&gt; instance methods and properties&lt;/li&gt;
&lt;li&gt;Cannot be applied to &lt;code&gt;init&lt;/code&gt; members or constructors, to avoid allowing &lt;code&gt;ref&lt;/code&gt; to &lt;code&gt;readonly&lt;/code&gt; members&lt;/li&gt;
&lt;li&gt;Member annotated with &lt;code&gt;[UnscopedRef]&lt;/code&gt; cannot implement interface&lt;/li&gt;
&lt;li&gt;Considered in overrides, interface implementations, delegate conversions&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;See &lt;a href="https://github.com/dotnet/csharplang/blob/main/proposals/low-level-struct-improvements.md#provide-unscoped"&gt;Provide unscoped&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Relates to test plan https://github.com/dotnet/roslyn/issues/59194&lt;/p&gt;
</description>
      <pubDate>Tue, 02 Aug 2022 17:11:49 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6309</guid>
      <link>https://github.com/dotnet/csharplang/issues/6309</link>
      <title>Issue: [API Proposal]: Record Default Constructor Accessibility - @Foxtrek64</title>
      <description>&lt;h3&gt;Background and motivation&lt;/h3&gt;
&lt;p&gt;Currently with record types, whether record classes or record structs, the default constructor is always public. There are times where non-public constructors are wanted, however to do so, users must implement the properties and constructor manually.&lt;/p&gt;
&lt;p&gt;There are certainly cases where this is better, but it removes the utility of the default constructor for record types.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;// old
public sealed record class Person(string Name, int Age);

// new
public sealed record class Person
{
    public string Name { get; }
    public int Age { get; }
    
    private Person(string name, int age)
    {
        Name = name;
        Age = age;
     }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;API Proposal&lt;/h3&gt;
&lt;p&gt;I would like to propose an additional syntax for record types, as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public sealed record class Person private(string Name, int Age);
public sealed record struct Person protected internal(string Name, int Age);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This would compile into a class or struct as normal, but the specified accessibility modifier would be applied to the generated constructor.&lt;/p&gt;
&lt;p&gt;Necessarily, the compiler will need instructions that if an accessibility modifier is not applied, then it should be assumed to be &lt;code&gt;public&lt;/code&gt; in order to maintain backwards compatibility with existing record types.&lt;/p&gt;
&lt;p&gt;Optionally, an analyzer could also be created to recommend removing the &lt;code&gt;public&lt;/code&gt; modifier for simplification reasons,&lt;/p&gt;
&lt;h3&gt;API Usage&lt;/h3&gt;
&lt;p&gt;The proposal and the usage are pretty much the same thing.&lt;/p&gt;
&lt;h3&gt;Alternative Designs&lt;/h3&gt;
&lt;p&gt;The placement of the private modifier is based off of Kotlin's class specification. Here is an example of theirs:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-kt"&gt;class Foo private constructor(Bar bar) { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That said, we are not beholden to any design because of another language's decisions, so if a different placement is desired for different reasons, I take no issue with this.&lt;/p&gt;
&lt;h3&gt;Risks&lt;/h3&gt;
&lt;p&gt;So long as we make the modifier optional and specify that no modifier is the same as public, there are no risks to this change.&lt;/p&gt;
</description>
      <pubDate>Fri, 22 Jul 2022 22:08:28 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6305</guid>
      <link>https://github.com/dotnet/csharplang/issues/6305</link>
      <title>Issue: [API Proposal]: Consistent interface members - @Shadowblitz16</title>
      <description>&lt;h3&gt;Background and motivation&lt;/h3&gt;
&lt;p&gt;I realized that static interface have different syntax then instance members&lt;/p&gt;
&lt;h3&gt;API Proposal&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;namespace System.Collections.Generic;

public interface IStaticDefault
{
    static void A1();
    static void A2()
    {
        
    }
}
public interface IStaticAbstract
{
    static abstract void A1();
    static abstract void A2()
    {
        
    }
}
public interface IStaticAccess
{
    public static void A1();
    public static void A2()
    {
        
    }
    protected static void B1();
    protected static void B2()
    {
        
    }
    private static void C1();
    private static void C2()
    {
        
    }
}
public interface IStaticBoth
{
    public abstract static void A1();
    public abstract static void A2()
    {
        
    }
    protected abstract static void B1();
    protected abstract static void B2()
    {
        
    }
    private abstract static void C1();
    private abstract static void C2()
    {
        
    }
}

public interface IInstanceDefault
{
    void A1();
    void A2()
    {
        
    }
}
public interface IInstanceAbstract
{
    abstract void A1();
    abstract void A2()
    {
        
    }
}
public interface IInstanceAccess
{
    public void A1();
    public void A2()
    {
        
    }
    protected void B1();
    protected void B2()
    {
        
    }
    private void C1();
    private void C2()
    {
        
    }
}
public interface IInstanceBoth
{
    public abstract void A1();
    public abstract void A2()
    {
        
    }
    protected abstract void B1();
    protected abstract void B2()
    {
        
    }
    private abstract void C1();
    private abstract void C2()
    {
        
    }
}


&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;API Usage&lt;/h3&gt;
&lt;p&gt;No API usage its makes interfaces more consistent and gives more power to the coder to decide what coding style to use&lt;/p&gt;
&lt;h3&gt;Alternative Designs&lt;/h3&gt;
&lt;p&gt;None&lt;/p&gt;
&lt;h3&gt;Risks&lt;/h3&gt;
&lt;p&gt;Shouldn't be any&lt;/p&gt;
</description>
      <pubDate>Thu, 21 Jul 2022 22:48:44 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6300</guid>
      <link>https://github.com/dotnet/csharplang/issues/6300</link>
      <title>Issue: [Proposal]: Implicit parameters - @radrow</title>
      <description>&lt;!--
Hello, and thanks for your interest in contributing to C#! If you haven't been invited by a team member to open an issue, please instead open a discussion marked [draft issue] at https://github.com/dotnet/csharplang/discussions/new and we'll try to give you feedback on how to get to an issue-ready proposal.

New language feature proposals should fully fill out this template. This should include a complete detailed design, which describes the syntax of the feature, what that syntax means, and how it affects current parts of the spec. Please make sure to point out specific spec sections that need to be updated for this feature.
--&gt;
&lt;h1&gt;Implicit Parameters&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;[x] Proposed&lt;/li&gt;
&lt;li&gt;[ ] Prototype: Not Started&lt;/li&gt;
&lt;li&gt;[ ] Implementation: Not Started&lt;/li&gt;
&lt;li&gt;[ ] Specification: Not Started&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;This proposal introduces &lt;strong&gt;implicit parameters&lt;/strong&gt; for C#. It is highly inspired by a feature of Scala known under this exact name, as well as similar solutions from other languages. In spite of that inspiration, the aim is to make the new functionality as simple as possible in order to avoid numerous flaws caused by overly complex Scala's design. The motivation is to increase clarity and comfort of writing and refactoring code that extensively passes environmental values through the stack.&lt;/p&gt;
&lt;p&gt;Implicit parameters are syntactic sugar for function applications. The idea is to pass selected arguments to methods without necessarily mentioning them across the code, especially where it would be repetitive and unavoidable. Thus, instead of writing&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Data FetchData(CancellationToken token) {
    var request  = MakeDataRequest(token);
    var service  = GetService(&amp;quot;main&amp;quot;, token);
    var response = service.Send(request, token);
    
    if(response.IsNotOk) {
        service = GetService(&amp;quot;fallback&amp;quot;, token);
        return service.Send(request, token).Data();
    }
    
    return response.Data();
}

MakeDataRequest(CancellationToken token);
GetService(string name, CancellationToken token);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One could simplify it to something like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Data FetchData(implicit CancellationToken token) {
    var request  = MakeDataRequest();
    var service  = GetService(&amp;quot;main&amp;quot;);
    var response = service.Send(request);
    
    if(response.IsNotOk) {
        service = GetService(&amp;quot;fallback&amp;quot;);
        return service.Send(request).Data();
    }
    
    return response.Data();
}

MakeDataRequest(implicit CancellationToken token);
GetService(string name, implicit CancellationToken token);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the cancellation token (&lt;code&gt;token&lt;/code&gt;) is provided &lt;em&gt;implicitly&lt;/em&gt; to every call that declares it as its &lt;code&gt;implicit&lt;/code&gt; argument. While it still needs to be declared in the function signature, the application is handled automatically as long as there is a matching implicit value in the context.&lt;/p&gt;
&lt;p&gt;A way to look at this feature is that it is a counterpart of the &lt;em&gt;default parameters&lt;/em&gt; that are already a part of C#. In both concepts some arguments are supplied by the compiler instead of the programmer. The difference is where those arguments come from; to find the source of an implicit parameter you need to look at the &lt;em&gt;calling&lt;/em&gt; function's signature, as opposed to the &lt;em&gt;called&lt;/em&gt; function in case of the default parameters.&lt;/p&gt;
&lt;h2&gt;Motivation&lt;/h2&gt;
&lt;p&gt;Since it is just a &amp;quot;smart&amp;quot; syntactic sugar, this feature does not provide any new control flows or semantics that were not achievable before. What it offers is that it lets one write code in a certain style more conveniently, and with less of boilerplate.&lt;/p&gt;
&lt;p&gt;The promoted paradigm is to handle environment and state by passing it through stack, instead of keeping them in global variables. There are numerous benefits of designing applications this way; most notably the ease of parallelization, test isolation, environment mocking, and broader control over method dependencies and side effects. This can play crucial role in big systems handling numerous tasks in parallel, where context separation is an important security and sanity factor.&lt;/p&gt;
&lt;p&gt;Simple &lt;code&gt;CancellationToken&lt;/code&gt; examples like the previous one are likely to be common. The following example is more elaborate, showing a realistic implementation of a gRPC server converting image files:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void CheckCancellation(implicit ServerCallContext ctx) =&amp;gt;
    ctx.CancellationToken.ThrowIfCancelled();

bool FileCached(string fileName, implicit ServerCallContext ctx) =&amp;gt;
    ctx.RequestHeaders.Get(&amp;quot;use_cache&amp;quot;) &amp;amp;&amp;amp; Cache.Exists(fileName);

async Task ConvertJpgToPng(
  int fileSize,
  string fileName,
  implicit IAsyncStreamReader&amp;lt;Req&amp;gt; inStream,
  implicit IServerStreamWriter&amp;lt;Res&amp;gt; outStream,
  implicit ServerCallContext ctx)
{
    bool cached = FileCached(fileName); // !
    
    Jpg jpg = null;
    if(cached)
    {
        await RequestNoFile(); // !
        jpg = Cache.Get(fileName); // !
    }
    else
    {
        jpg = await RequestFile(); // !
    }
    CheckCancellation(); // !
    
    Png png = jpg.ToPng();
    
    await outStream.WriteAsync(new Res(){Png = png}); // !
}

async Task RequestNoFile(implicit IServerStreamWriter&amp;lt;Res&amp;gt; outStream) =&amp;gt;
    await outStream.WriteAsync(new Res(){SendFile = false}); // !
    
async Task&amp;lt;Jpg&amp;gt; RequestFile(
  implicit IAsyncStreamReader&amp;lt;Req&amp;gt; inStream,
  implicit IServerStreamWriter&amp;lt;Res&amp;gt; outStream,
  implicit ServerCallContext ctx) {
    await outStream.WriteAsync(new Res(){SendFile = true }); // !
    CheckCancellation(); // !
    Req msg = await inStream.ReadAsync(); // !
    CheckCancellation(); // !
    return msg.Png;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code is a lot lighter and arguably cleaner than what it would look like if it passed around &lt;code&gt;ctx&lt;/code&gt;, &lt;code&gt;inStream&lt;/code&gt; and &lt;code&gt;outStream&lt;/code&gt; explicitly every time. The code focuses on the main logic without bringing up the contextual dependencies, which are mentioned only in method headers. To show the impact, I marked all the places where the implicit application happens with a &lt;code&gt;// !&lt;/code&gt; comment.&lt;/p&gt;
&lt;p&gt;Implicit parameters ease refactoring in some cases. Let us imagine that it turns out that &lt;code&gt;RequestNoFile&lt;/code&gt; needs to check for cancellation, and therefore requires &lt;code&gt;ServerCallContext&lt;/code&gt; to get access to the token:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;async Task RequestNoFile(implicit IServerStreamWriter&amp;lt;Res&amp;gt; outStream, implicit ServerCallContext _) {
    await outStream.WriteAsync(new Res(){SendFile = false});
    CheckCancellation();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Because in the presented snippet &lt;code&gt;RequestNoFile&lt;/code&gt; is called only from scopes with &lt;code&gt;ServerCallContext&lt;/code&gt; provided, no other changes in the code are required. In contrast, without implicit parameters, every single call to &lt;code&gt;RequestNoFile&lt;/code&gt; would have to be updated. Of course, if the calling context does not have that variable, it needs to get it anyway -- but if it does so implicitly as well, this benefit propagates further. This nicely reduces the complexity of adding new dependencies to routines.&lt;/p&gt;
&lt;h2&gt;Detailed design&lt;/h2&gt;
&lt;h3&gt;General syntax&lt;/h3&gt;
&lt;p&gt;Since the implicit parameters appear similar to optional parameters, it feels natural to declare them in a similar manner:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void f(int x, implicit int y, implicit int z) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Regarding placement, it makes sense to mingle both kinds of special parameters together. Parameters could be also simultaneously implicit and optional as well:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void f(int x, implicit int y, implicit int z = 3, int w = 4) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Supplying implicit arguments from non-implicit methods&lt;/h3&gt;
&lt;p&gt;In order to avoid the mess known from Scala 2, there should always be a clear way of finding the values provided as implicit parameters. Therefore, I propose letting them be taken only:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;From the implicit parameters of the current method&lt;/li&gt;
&lt;li&gt;Through explicit application&lt;/li&gt;
&lt;li&gt;(OPTIONAL) from &lt;code&gt;implicit&lt;/code&gt; &lt;strong&gt;local&lt;/strong&gt; variables (and only local)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Hence this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;int f(int x, implicit int y);

int g() {
    return f(3, y: 42);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If supplying them manually starts getting annoying, then a possible workaround would be to lift the context with another method. So this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void f1(implicit int x);
void f2(implicit int x);
void f3(implicit int x);

void g() {
    int arg = 123;
    f1(x: arg);
    f2(x: arg);
    f3(x: arg);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;turns into this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void f1(implicit int x);
void f2(implicit int x);
void f3(implicit int x);

void g() {
    int arg = 123;
    gf(x: arg)
}

void gf(implicit int arg) {
    f1();
    f2();
    f3();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Overloading&lt;/h3&gt;
&lt;p&gt;Resolution rules for overloading should be no different that those for optional parameters. When a method is picked based on the contex,t and there is no suitable implicit parameter in scope, it should result in an error.&lt;/p&gt;
&lt;h3&gt;Nested functions&lt;/h3&gt;
&lt;p&gt;In most common cases there should be no reason to prevent local functions from using implicit parameters of enclosing methods. Though, there are two exceptions where it would not work:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When the nested function is static&lt;/li&gt;
&lt;li&gt;When the nested function shadows an implicit parameter by declaring another one of the same type&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A workaround for the former is to declare the static function with the same implicit parameter. That also gives a reason to have a casual shadowing regarding the latter case.&lt;/p&gt;
&lt;h3&gt;Resolution of multiple implicit parameters&lt;/h3&gt;
&lt;p&gt;The design must consider ambiguities that emerge from use of multiple implicit parameters. Since they are not explicitly identified by the programmer, there must be a clear and deterministic way of telling what variables are supplied and in what order. A common way of tackling this is to enforce every implicit parameter have a distinct type and do the resolution based on that. It is a rare case that one would need multiple implicit parameters of the same type, and if so a wrapper class or a collection can be used (even a tuple).&lt;/p&gt;
&lt;p&gt;There is a special case when inheritance is taken into account, as it can lead to ambiguities:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void f(implicit Animal a) {}

void g(implicit Dog d, implicit Cat c) {
    f();  // Which animal should be supplied?
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This should result in an error, ideally poining to all variables that participate in the dilemma. However, as long as the resolution is deterministic, there should be no issue with that. A workaround in such situations is explicit application:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void f(implicit Animal a) {}

void g(implicit Dog d, implicit Cat c) {
    f(a: d);  // That's clear
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If that feels doubtful, it could be a configurable warning that an implicit parameter is affected by subtyping.&lt;/p&gt;
&lt;h3&gt;Backwards compatibility&lt;/h3&gt;
&lt;p&gt;Since I propose reusing an existing keyword, all valid identifiers shall remain valid. The only added syntax is an optional sort of parameters, which does interfere with any current constructs, so no conflicts would arise from that either. There is also no new semantics associated with not using this feature. Thus, full backward compatibility.&lt;/p&gt;
&lt;p&gt;Since there is a general convention to keep contextual parameters last anyway, transition of common libraries to use implicit parameters should be quite painless. That is because implicit parameters can still be used as positional ones, so the following codes shall run perfectly the same:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Version 1.0 before implicit parameters
async void Send(Message message, CancellationToken token);

// LegacyEnterpriseSoftwareIncorporated's business logic
async void SendFromString(string s, CancellationToken token)
{
    Send(new Message(s), token);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Version 1.1 after implicit parameters
async void Send(Message message, implicit CancellationToken token);

// LegacyEnterpriseSoftwareIncorporated's business logic
async void SendFromString(string s, CancellationToken token)
{
    Send(new Message(s), token);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;...and of course&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// Version 1.1 after implicit parameters
async void Send(Message message, implicit CancellationToken token);

// ModernStartupHardwareFreelance's business logic
async void SendFromString(string s, implicit CancellationToken token)
{
    Send(new Message(s));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Performance&lt;/h3&gt;
&lt;p&gt;These parameters turn into normal ones in an early phase of the compilation, thus no runtime overhead at all. Compilation time would be affected obviously, but it depends on the resolution algorithm. If kept simple (what I believe should an achievable goal), the impact should not be very noticeable. More than that, there is no overhead if the feature is not used.&lt;/p&gt;
&lt;h3&gt;Editor support&lt;/h3&gt;
&lt;p&gt;Since the feature would be desugared quite early, it should be easy to retrieve what arguments are applied implicitly. Thus, if some users find it confusing, I believe it would not be very hard to have a VS (Code) extension that would inform about the details of the implicit application. A similar thing to adding parameter names to method calls.&lt;/p&gt;
&lt;h2&gt;Drawbacks&lt;/h2&gt;
&lt;!-- Why should we *not* do this? --&gt;
&lt;p&gt;Well, &amp;quot;&lt;em&gt;implicit&lt;/em&gt;&amp;quot;. This word is sometimes enough to bring doubts and protests. As much as I personally like moving stuff behind the scenes, I definitely see reasons to be careful. All that implicit magic is a double-edged sword -- on one hand it helps keeping the code tidy, but on the other can lead to nasty surprices and overall degraded readability.&lt;/p&gt;
&lt;p&gt;One of the most common accusations against Scala is the so-called &lt;a href="http://spiridonov.pro/2015/10/14/scala-implicit-hell/"&gt;&amp;quot;implicit hell&amp;quot;&lt;/a&gt;, which is caused by sometimes overused combination of extension classes (known there as, of course, &amp;quot;implicit&amp;quot; classes), implicit parameters and implicit conversions. I am not a very experienced Scala programmer, but I do remember finding Akka (a Scala library that uses implicits extensively) quite hard to learn because of that.&lt;/p&gt;
&lt;p&gt;As mentioned before, &lt;a href="https://docs.scala-lang.org/scala3/reference/contextual.html"&gt;there is an article&lt;/a&gt; by Scala itself, that points out flaws in the Scala 2 design. I encourage the curious reader for a lecture on how not to do it.&lt;/p&gt;
&lt;p&gt;Also, there is a discussion under a non-successful proposal for adding this to &lt;a href="https://internals.rust-lang.org/t/implicit-parameters/14514"&gt;Rust&lt;/a&gt;. The languages and their priorities are fairly different, but the critics there clearly have a point.&lt;/p&gt;
&lt;h2&gt;Alternatives&lt;/h2&gt;
&lt;h3&gt;Resolution by name&lt;/h3&gt;
&lt;p&gt;Implicit parameters could be resolved by name instead of types. It allows implicit parameters to share type and solves all issues with inheritance, since types wouldn't play any role here. Although, it reduces flexibility since the parameters would be tied to the same name across all the flow of the code. This may slightly harden refactoring. A counterargument to that is that each implicit parameter should generally describe the same thing everywhere, so keeping the same name feels natural anyway and looks like a good pattern that might be worth enforcing.&lt;/p&gt;
&lt;h3&gt;Local implicit variables&lt;/h3&gt;
&lt;p&gt;To ease resolution and reduce the amount of code, some local variables could be declared as &lt;code&gt;implicit&lt;/code&gt; as well. To avoid Scala 2 mess, it is important to allow this solely for method-local parameters and nothing more.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void f(implicit int x);

void g() {
    implicit int x = 123;
    f();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Unresolved questions&lt;/h2&gt;
&lt;!-- What parts of the design are still undecided? --&gt;
&lt;ul&gt;
&lt;li&gt;Should we allow implicit parameters on properties?&lt;/li&gt;
&lt;li&gt;Should we allow implicit parameters on constructors?&lt;/li&gt;
&lt;li&gt;Do we want to allow declaring implicit local variables?&lt;/li&gt;
&lt;li&gt;Resolution by type vs by name.&lt;/li&gt;
&lt;li&gt;Should we allow passing an implicit parameter when it is of a subtype of the declared one? (assuming no ambiguities)?&lt;/li&gt;
&lt;li&gt;Should nested functions inherit implicit context from their declarators?&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Design meetings&lt;/h2&gt;
&lt;!-- Link to design notes that affect this proposal, and describe in one sentence for each what changes they led to. --&gt;
</description>
      <pubDate>Thu, 21 Jul 2022 11:16:26 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6289</guid>
      <link>https://github.com/dotnet/csharplang/issues/6289</link>
      <title>Issue: specification of the `foreach` statement (12.9.5) doesn't apply for `System.Span` - @ltcmelo</title>
      <description>&lt;h3&gt;Discussed in https://github.com/dotnet/csharplang/discussions/6288&lt;/h3&gt;
&lt;div type='discussions-op-text'&gt;
&lt;p&gt;&lt;sup&gt;Originally posted by &lt;strong&gt;ltcmelo&lt;/strong&gt; July 18, 2022&lt;/sup&gt;
The &lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/statements#1295-the-foreach-statement"&gt;&lt;code&gt;foreach&lt;/code&gt; statement&lt;/a&gt; is specified by means of an expansion into a &lt;code&gt;while&lt;/code&gt; *.&lt;br /&gt;
But the specification doesn't apply for a type such as &lt;code&gt;System.Span&lt;/code&gt; or &lt;code&gt;System.ReadOnlySpan&lt;/code&gt; as the expansion will produce invalid code.&lt;br /&gt;
Specifically: the &lt;code&gt;V&lt;/code&gt; in &lt;code&gt;foreach (V v in x) «embedded_statement»&lt;/code&gt; will expand into the &lt;code&gt;V&lt;/code&gt; in &lt;code&gt;V v = (V)(T)e.Current;&lt;/code&gt;; however, if the &lt;code&gt;foreach&lt;/code&gt; is inside an &lt;code&gt;async&lt;/code&gt; method, then the declaration &lt;code&gt;V v&lt;/code&gt; will lead to a diagnose such as:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;error CS4012: Parameters or locals of type 'ReadOnlySpan&amp;lt;char&amp;gt;' cannot be declared in async methods or async lambda expressions.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Here's an example in which specified expansion breaks.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class C
{
    public async Task M()
    {
        IReadOnlyList&amp;lt;string&amp;gt; o = null;
        foreach (ReadOnlySpan&amp;lt;char&amp;gt; c in o) {}        
        return;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;* I have (most of) this expansion as a &lt;a href="https://github.com/ShiftLeftSecurity/SharpSyntaxRewriter/blob/master/src/SharpSyntaxRewriter/Rewriters/ExpandForeach.cs"&gt;syntax rewriter&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;
</description>
      <pubDate>Mon, 18 Jul 2022 19:21:40 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6358</guid>
      <link>https://github.com/dotnet/csharplang/issues/6358</link>
      <title>Issue: Decorator pattern for functions in .NET - @mmojgani77</title>
      <description>&lt;p&gt;Python programming language has decorator concept that you can run some codes before and after calling the method.
It is a useful feature for concepts like logging, caching, etc.
I suggest to implement this feature that makes that ability for developer to run another functions before and after a function or method call&lt;/p&gt;
</description>
      <pubDate>Wed, 29 Jun 2022 11:24:22 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6247</guid>
      <link>https://github.com/dotnet/csharplang/issues/6247</link>
      <title>Issue: [Proposal]: Embedded Language Indicators for raw string literals - @333fred</title>
      <description>&lt;!--
Hello, and thanks for your interest in contributing to C#! If you haven't been invited by a team member to open an issue, please instead open a discussion marked [draft issue] at https://github.com/dotnet/csharplang/discussions/new and we'll try to give you feedback on how to get to an issue-ready proposal.

New language feature proposals should fully fill out this template. This should include a complete detailed design, which describes the syntax of the feature, what that syntax means, and how it affects current parts of the spec. Please make sure to point out specific spec sections that need to be updated for this feature.
--&gt;
&lt;h1&gt;Embedded Language Indicators for raw string literals&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;[x] Proposed&lt;/li&gt;
&lt;li&gt;[ ] Prototype: Not Started&lt;/li&gt;
&lt;li&gt;[ ] Implementation: Not Started&lt;/li&gt;
&lt;li&gt;[ ] Specification: Not Started&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;When we were designing &lt;a href="https://github.com/dotnet/csharplang/issues/4304"&gt;raw string literals&lt;/a&gt;, we intentionally left the door open for putting a language indicator at the end of the opening &lt;code&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/code&gt; for the multi-line form. This proposal adds the support to do that.&lt;/p&gt;
&lt;h2&gt;Motivation&lt;/h2&gt;
&lt;p&gt;In the BCL, we added &lt;code&gt;StringSyntaxAttribute&lt;/code&gt; for applying to parameters, which allows parameters to indicate the strings passed to them contain some form of embedded language, which is then used for syntax highlighting. However, this only works for strings passed directly to the parameter. For strings first stored in a variable, the only solution is a &lt;code&gt;// lang = x&lt;/code&gt; comment. This means that, if the IDE wants to extract a multi-line raw string literal, it cannot neatly preserve the highlighting that was used. This syntax form is intended to help bridge that gap.&lt;/p&gt;
&lt;h2&gt;Detailed design&lt;/h2&gt;
&lt;p&gt;The existing raw string literal &lt;a href="https://github.com/dotnet/csharplang/blob/main/proposals/raw-string-literal.md"&gt;proposal&lt;/a&gt; has the following multi-line grammar:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-antlr"&gt;multi_line_raw_string_literal
    : raw_string_literal_delimiter whitespace* new_line (raw_content | new_line)* new_line whitespace* raw_string_literal_delimiter
    ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is updated to the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-antlr"&gt;multi_line_raw_string_literal
    : raw_string_literal_delimiter identifier? whitespace* new_line (raw_content | new_line)* new_line whitespace* raw_string_literal_delimiter
    ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Where the &lt;code&gt;identifier?&lt;/code&gt; token is added right after the delimiter.&lt;/p&gt;
&lt;h2&gt;Drawbacks&lt;/h2&gt;
&lt;p&gt;This form is not equally applicable to all string types, so it would only apply to multi-line raw string literals. Ideas on other forms that could be more broadly applied would be useful: maybe putting the identifier after the closing quote could work?&lt;/p&gt;
&lt;h2&gt;Alternatives&lt;/h2&gt;
&lt;h2&gt;Unresolved questions&lt;/h2&gt;
&lt;h2&gt;Design meetings&lt;/h2&gt;
</description>
      <pubDate>Mon, 27 Jun 2022 22:47:09 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6242</guid>
      <link>https://github.com/dotnet/csharplang/issues/6242</link>
      <title>Issue: [Proposal]: Allow trailing comma in `ComplexElementInitializerExpression` - @Youssef1313</title>
      <description>&lt;!--
Hello, and thanks for your interest in contributing to C#! If you haven't been invited by a team member to open an issue, please instead open a discussion marked [draft issue] at https://github.com/dotnet/csharplang/discussions/new and we'll try to give you feedback on how to get to an issue-ready proposal.

New language feature proposals should fully fill out this template. This should include a complete detailed design, which describes the syntax of the feature, what that syntax means, and how it affects current parts of the spec. Please make sure to point out specific spec sections that need to be updated for this feature.
--&gt;
&lt;h1&gt;FEATURE_NAME&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;[x] Proposed&lt;/li&gt;
&lt;li&gt;[ ] Prototype: Not Started&lt;/li&gt;
&lt;li&gt;[ ] Implementation: Not Started&lt;/li&gt;
&lt;li&gt;[ ] Specification: Not Started&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;Allows a trailing comma in &lt;code&gt;ComplexElementInitializerExpression&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Motivation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;All initializer expressions currently allows a trailing comma, except &lt;code&gt;ComplexElementInitializerExpression&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Allowing a trailing comma helps for a better diff if a new expression will be added.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Detailed design&lt;/h2&gt;
&lt;p&gt;Currently, the grammar per the &lt;a href="https://github.com/dotnet/csharpstandard/blob/draft-v7/standard/grammar.md"&gt;draft-v7 branch&lt;/a&gt; is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-antlr"&gt;// Source: §11.7.15.4 Collection initializers
collection_initializer
    : '{' element_initializer_list '}'
    | '{' element_initializer_list ',' '}'
    ;

element_initializer_list
    : element_initializer (',' element_initializer)*
    ;

element_initializer
    : non_assignment_expression
    | '{' expression_list '}'
    ;

expression_list
    : expression
    | expression_list ',' expression
    ;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It will be modified to be:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-antlr"&gt;// Source: §11.7.15.4 Collection initializers
collection_initializer
    : '{' element_initializer_list '}'
    | '{' element_initializer_list ',' '}'
    ;

element_initializer_list
    : element_initializer (',' element_initializer)*
    ;

element_initializer
    : non_assignment_expression
    | '{' expression_list '}'
    | '{' expression_list ',' '}'
    ;

expression_list
    : expression
    | expression_list ',' expression
    ;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Drawbacks&lt;/h2&gt;
&lt;!-- Why should we *not* do this? --&gt;
&lt;h2&gt;Alternatives&lt;/h2&gt;
&lt;!-- What other designs have been considered? What is the impact of not doing this? --&gt;
&lt;h2&gt;Unresolved questions&lt;/h2&gt;
&lt;!-- What parts of the design are still undecided? --&gt;
&lt;h2&gt;Design meetings&lt;/h2&gt;
&lt;!-- Link to design notes that affect this proposal, and describe in one sentence for each what changes they led to. --&gt;
</description>
      <pubDate>Sat, 25 Jun 2022 15:59:14 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6235</guid>
      <link>https://github.com/dotnet/csharplang/issues/6235</link>
      <title>Issue: [Proposal]: UTF8 literal support for nameof() expressions - @Sergio0694</title>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: extracted minimal proposal from https://github.com/dotnet/csharplang/issues/184#issuecomment-1076849885.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--
Hello, and thanks for your interest in contributing to C#! If you haven't been invited by a team member to open an issue, please instead open a discussion marked [draft issue] at https://github.com/dotnet/csharplang/discussions/new and we'll try to give you feedback on how to get to an issue-ready proposal.

New language feature proposals should fully fill out this template. This should include a complete detailed design, which describes the syntax of the feature, what that syntax means, and how it affects current parts of the spec. Please make sure to point out specific spec sections that need to be updated for this feature.
--&gt;
&lt;h1&gt;UTF8 literal support for nameof() expressions&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;[x] Proposed&lt;/li&gt;
&lt;li&gt;[ ] Prototype: Not Started&lt;/li&gt;
&lt;li&gt;[ ] Implementation: Not Started&lt;/li&gt;
&lt;li&gt;[ ] Specification: Not Started&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Summary and motivation&lt;/h2&gt;
&lt;p&gt;This proposal is a small follow up to the UTF8 literal feature. There are many scenarios where developers would want to move to passing UTF8 literals to get better performance and not having to transcode the text at runtime, but the way the feature is currently specced, it would mean that replacing all callsites where today developers are using &lt;code&gt;nameof&lt;/code&gt;, &lt;code&gt;[CallerMemberName]&lt;/code&gt;, &lt;code&gt;[CallerArgumentExpression]&lt;/code&gt; etc. would not be possible. This would mean that developers would be forced to choose between less error prone code with worse performance (what they have today), or more error prone code (due to hardcoded literals) with faster performance. Having to make a compromise here is not ideal, and this proposal is meant to offer minimal support to solve this issue.&lt;/p&gt;
&lt;p&gt;Specifically, the proposal is only to enable &lt;code&gt;nameof&lt;/code&gt; expressions to be used as UTF8 arguments. This would allow developers to get robust code by using the &lt;code&gt;nameof&lt;/code&gt; operator, and callsites currently using &lt;code&gt;[CallerMemberName]&lt;/code&gt; and &lt;code&gt;[CallerArgumentExpression]&lt;/code&gt; could just move to &lt;code&gt;nameof&lt;/code&gt; instead to still have build time checks for the literals, instead of having hardcoded strings.&lt;/p&gt;
&lt;p&gt;Essentially, the proposal is to allow &lt;code&gt;u8&lt;/code&gt; to be appended to a &lt;code&gt;nameof&lt;/code&gt; expression, like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void Test(int parameter)
{
    var testUtf8 = nameof(Test)u8;
    var parameterUtf8 = nameof(parameter)u8;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This would have the same flexibility as &lt;code&gt;nameof&lt;/code&gt; today, but with UTF8 support. Roslyn would just lower this exactly the same as it would have had if a literal had been used in place of that &lt;code&gt;nameof&lt;/code&gt; expression, with the &lt;code&gt;u8&lt;/code&gt; suffix at the end.&lt;/p&gt;
&lt;h2&gt;Use case example&lt;/h2&gt;
&lt;!-- Why are we doing this? What use cases does it support? What is the expected outcome? --&gt;
&lt;p&gt;As mentioned in https://github.com/dotnet/csharplang/issues/184#issuecomment-1076849885, we have a custom, high-performance, reflection-free ETW logger in the Microsoft Store, which exposes a builder pattern to allow callers to construct their structured events to submit, like so (simplified):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void SomeEvent(string someText, string someOtherText, ...)
{
    using TracingDataBuilder builder = TracingDataBuilder.Create();
 
    // ...
   
    builder.AppendEventTagAndName(SOME_TAG.BAR); // [CallerMemberName]
    builder.AppendWStringKeyValuePair(pSomeText, someTextLength, nameof(someText));
    builder.AppendWStringKeyValuePair(pSomeOtherText, someOtherTextName, nameof(someOtherText));
    builder.AppendWStringKeyValuePair(pSomeId, someIdLength, nameof(someId));
    builder.AppendWStringKeyValuePair(pSomeType, someTypeLength, nameof(someType));
    builder.AppendBoolKeyValuePair(&amp;amp;someBoolParameter, nameof(someBoolParameter));
    builder.AppendBoolKeyValuePair(&amp;amp;someOtherBoolParameter, nameof(someOtherBoolParameter));
    builder.AppendInt32KeyValuePair(&amp;amp;someIntParameter, nameof(someIntParameter));
    
    _ = builder.EventWriteTransfer(_traceLogger, descriptor, null, null);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This currently uses &lt;code&gt;Encoding.UTF8&lt;/code&gt; to get the UTF8 data for those event and field names and build the event metadata. This is not ideal for performance, and we'd like to migrate to just using UTF8 literals. The issue with that is that due to the current design, there would be no way to use them without having to fall back to having hardcoded strings everywhere, which is not great.&lt;/p&gt;
&lt;p&gt;With the proposed feature instead, we could just drop the attributes and simply do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public void SomeEvent(string someText, string someOtherText, ...)
{
    using TracingDataBuilder builder = TracingDataBuilder.Create();
 
    // ...
   
    builder.AppendEventTagAndName(SOME_TAG.BAR, nameof(SomeEvent)u8);
    builder.AppendWStringKeyValuePair(pSomeText, someTextLength, nameof(someText)u8);
    builder.AppendWStringKeyValuePair(pSomeOtherText, someOtherTextName, nameof(someOtherText)u8);
    builder.AppendWStringKeyValuePair(pSomeId, someIdLength, nameof(someId)u8);
    builder.AppendWStringKeyValuePair(pSomeType, someTypeLength, nameof(someType)u8);
    builder.AppendBoolKeyValuePair(&amp;amp;someBoolParameter, nameof(someBoolParameter)u8);
    builder.AppendBoolKeyValuePair(&amp;amp;someOtherBoolParameter, nameof(someOtherBoolParameter)u8);
    builder.AppendInt32KeyValuePair(&amp;amp;someIntParameter, nameof(someIntParameter)u8);
    
    _ = builder.EventWriteTransfer(_traceLogger, descriptor, null, null);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The .NET runtime also has some examples of where this could be useful. For instance, consider this: https://github.com/dotnet/runtime/blob/2a01ceb2d004a125757a4bb95a9341cc283c5afd/src/libraries/System.Reflection.MetadataLoadContext/src/System/Reflection/TypeLoading/General/Utf8Constants.cs#L41-L62. This is exactly the kind of scenario where developers used to hardcode literals before we had the &lt;code&gt;nameof&lt;/code&gt; operator, and then switched to &lt;code&gt;Foo =&amp;gt; nameof(Foo)&lt;/code&gt; when that became available. Having to go back to literals once again just to be able to get UTF8 encoding is not great. This could just be written as &lt;code&gt;Foo =&amp;gt; nameof(Foo)u8&lt;/code&gt; instead to avoid the use of hardcoded string literals whenever possible.&lt;/p&gt;
&lt;h2&gt;Detailed design&lt;/h2&gt;
&lt;!-- This is the bulk of the proposal. Explain the design in enough detail for somebody familiar with the language to understand, and for somebody familiar with the compiler to implement, and include examples of how the feature is used. Please include syntax and desired semantics for the change, including linking to the relevant parts of the existing C# spec to describe the changes necessary to implement this feature. An initial proposal does not need to cover all cases, but it should have enough detail to enable a language team member to bring this proposal to design if they so choose. --&gt;
&lt;p&gt;The design allows using the &lt;code&gt;u8&lt;/code&gt; suffix on a &lt;code&gt;nameof&lt;/code&gt; expression to have it lowered to an UTF8 &lt;code&gt;ReadOnlySpan&amp;lt;byte&amp;gt;&lt;/code&gt;. All the same other rules as normal UTF8 literals (&lt;a href="https://github.com/dotnet/csharplang/blob/main/proposals/utf8-string-literals.md"&gt;see here&lt;/a&gt;) apply here. A &lt;code&gt;nameof&lt;/code&gt; expression with the &lt;code&gt;u8&lt;/code&gt; suffix would be lowered exactly the same as a literal with the same content of the &lt;code&gt;nameof&lt;/code&gt; expression, with the &lt;code&gt;u8&lt;/code&gt; suffix.&lt;/p&gt;
&lt;p&gt;The same conversion rules and other general rules around UTF8 literals would apply here as well, with no changes.&lt;/p&gt;
&lt;h2&gt;Drawbacks&lt;/h2&gt;
&lt;!-- Why should we *not* do this? --&gt;
&lt;p&gt;It's a new, although small, bit of syntax, and it would likely need some mapping in the public code analysis APIs as well.&lt;/p&gt;
&lt;h2&gt;Alternatives&lt;/h2&gt;
&lt;p&gt;Force developers to go back to hardcoded strings in all of these scenarios. This works, but it's far from ideal.&lt;/p&gt;
</description>
      <pubDate>Fri, 24 Jun 2022 14:06:03 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6197</guid>
      <link>https://github.com/dotnet/csharplang/issues/6197</link>
      <title>Issue: [Proposal]: [Dot object deconstruction] - @fedeAlterio</title>
      <description>&lt;h1&gt;Dot object deconstruction&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;[x] Proposed&lt;/li&gt;
&lt;li&gt;[ ] Prototype: Not Started&lt;/li&gt;
&lt;li&gt;[ ] Implementation: Not Started&lt;/li&gt;
&lt;li&gt;[ ] Specification: Not Started&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;Allow creating a tuple from an object simply using the dot (.) operator.&lt;/p&gt;
&lt;h2&gt;Motivation&lt;/h2&gt;
&lt;p&gt;The main motivation is lighter syntax and better readability.
Consider:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var (from, to) = (request.LikeMessage.FromUsername, request.LikeMessage.ToUsername);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The idea is to pull the common part behind the dot (.).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var (from, to) = request.LikeMessage.(FromUsername, ToUsername);&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Detailed design&lt;/h2&gt;
&lt;p&gt;Basically is a syntactic sugar:
&lt;code&gt;var (from, to) = request.LikeMessage.(FromUsername, ToUsername);&lt;/code&gt;
should be lowered to:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var tmp = request.LikeMessage; 
var (from, to) = (tmp.FromUsername, tmp.ToUsername);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Drawbacks&lt;/h2&gt;
&lt;p&gt;The main drawback is the similarity of the expression to the function call operator.&lt;/p&gt;
&lt;h2&gt;Alternatives&lt;/h2&gt;
&lt;p&gt;An alternative is to change the syntax to:
&lt;code&gt;var (from, to) = request.LikeMessage.{FromUsername, ToUsername};&lt;/code&gt;&lt;/p&gt;
</description>
      <pubDate>Sat, 04 Jun 2022 15:31:44 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6185</guid>
      <link>https://github.com/dotnet/csharplang/issues/6185</link>
      <title>Issue: Proposal: Class/Struct Initializer Method - @myrabyte</title>
      <description>&lt;p&gt;Would be fantastic to have some kind of constructor or initializer method on a class or struct that runs AFTER all property initializers. So we can add logic with all the parameters already in place passed via init properties. This could be achieved by adding [init] attribute to the parameterless private constructor. Or add &amp;quot;init&amp;quot; keyword in front of it. Also, this method can be invoked by deserializers. Just a thought.&lt;/p&gt;
</description>
      <pubDate>Mon, 30 May 2022 12:56:51 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6181</guid>
      <link>https://github.com/dotnet/csharplang/issues/6181</link>
      <title>Issue: Why get address of variable is unsafe ? - @MBurtsev</title>
      <description>&lt;p&gt;When I use operator for get address(&amp;amp;) compiler shows necessary using unsafe context. But if we just get address and never use it as pointer we are always in safe context. I suggest making changes. So that this requirement applies only if pointers are used for read\write operations. Below I give the code that should work in a safe context.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;        static void Test()
        {
            var adr = 0;
            var threadId = (long)&amp;amp;adr &amp;gt;&amp;gt; 16;
        }
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Sun, 29 May 2022 13:31:51 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6163</guid>
      <link>https://github.com/dotnet/csharplang/issues/6163</link>
      <title>Issue: [Proposal] Strict switch requiring to handle all possible options (if applicable) - @wojciechsura</title>
      <description>&lt;p&gt;I'd like to propose a strict switch version, which requires all enumeration values to be handled. The problem, which this construct might solve looks like following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public enum SomeEnum
{
    One,
    Two,
    Three
}

// (...)

public void Test()
{
    SomeEnum val = SomeEnum.One;

    switch (val)
    {
         case SomeEnum.One:
             break;
         case SomeEnum.Two:
             break;
         case SomeEnum.Three:
             break;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If one added an additional value to SomeEnum, the Test method might behave erratically, because it doesn't handle the newly added item.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public enum SomeEnum
{
    One,
    Two,
    Three,
    Four
}

// (...)

public void Test()
{
    SomeEnum val = SomeEnum.Four;

    // Most likely undesired behavior
    switch (val)
    {
         case SomeEnum.One:
             break;
         case SomeEnum.Two:
             break;
         case SomeEnum.Three:
             break;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This can be solved by adding a default case with exception:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public enum SomeEnum
{
    One,
    Two,
    Three,
    Four
}

// (...)

public void Test()
{
    SomeEnum val = SomeEnum.Four;

    // Most likely undesired behavior
    switch (val)
    {
         case SomeEnum.One:
             break;
         case SomeEnum.Two:
             break;
         case SomeEnum.Three:
             break;
         default:
             throw new InvalidEnumArgumentException(&amp;quot;Unsupported SomeEnum value!&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This however has a drawback, because the problem &lt;em&gt;might&lt;/em&gt; be found in the runtime if the method in question is actually executed.&lt;/p&gt;
&lt;p&gt;I propose a now notion (to be discussed), which requires developer to handle all possible values, or add a default case.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public enum SomeEnum
{
    One,
    Two,
    Three,
    Four
}

// (...)

public void Test()
{
    SomeEnum val = SomeEnum.Four;

    // Compilation error: not all cases were handled
    switch strict (val)
    {
         case SomeEnum.One:
             break;
         case SomeEnum.Two:
             break;
         case SomeEnum.Three:
             break;
    }

    // OK - all cases were handled
    switch strict (val)
    {
         case SomeEnum.One:
             break;
         case SomeEnum.Two:
             break;
         case SomeEnum.Three:
             break;
         case SomeEnum.Four:
             break;
    }

    // OK - default was provided
    switch strict (val)
    {
         case SomeEnum.One:
             break;
         case SomeEnum.Two:
             break;
         case SomeEnum.Three:
             break;
         default:
             break;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In case of other enumerable types (like int, byte etc.), the behavior would be the same - requirement to handle all values. Ranges might be helpful in such cases:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    switch strict (byteVal)
    {
        case [0..31]:
            return &amp;quot;Control ASCII&amp;quot;;
        case [32..127]:
            return &amp;quot;Readable ASCII&amp;quot;;
        case [128..255]:
            return &amp;quot;Variable ASCII&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is non-breaking change, because a completely new notion would be introduced. The &amp;quot;regular&amp;quot; &lt;code&gt;switch&lt;/code&gt; would work exactly the same way as it did.&lt;/p&gt;
&lt;p&gt;I'm interested, if you see this functionality (which probably shouldn't be too hard to implement) is of an interest to you.&lt;/p&gt;
</description>
      <pubDate>Wed, 25 May 2022 08:18:26 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6161</guid>
      <link>https://github.com/dotnet/csharplang/issues/6161</link>
      <title>Issue: [Proposal]: UTF-8 Literal Pattern Matching Support - @333fred</title>
      <description>&lt;h1&gt;UTF-8 Literal Pattern Matching Support&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;[x] Proposed&lt;/li&gt;
&lt;li&gt;[ ] Prototype: Not Started&lt;/li&gt;
&lt;li&gt;[ ] Implementation: Not Started&lt;/li&gt;
&lt;li&gt;[ ] Specification: Not Started&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The LDM looked at the concept and approved it in theory, but it needs an approved specification. This is in the Any Time milestone, so we'd accept a specification from a community member.&lt;/p&gt;
&lt;p&gt;Original discussion: https://github.com/dotnet/csharplang/discussions/6036&lt;/p&gt;
&lt;h2&gt;Design Meetings&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-05-11.md#pattern-matching-with-utf-8-string-literals&lt;/li&gt;
&lt;/ul&gt;
</description>
      <pubDate>Wed, 25 May 2022 00:47:00 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6149</guid>
      <link>https://github.com/dotnet/csharplang/issues/6149</link>
      <title>Issue: Open issues for `ref` fields - @cston</title>
      <description>&lt;h3&gt;1. Parse &lt;code&gt;scoped&lt;/code&gt; as a modifier with &lt;code&gt;-langversion:11&lt;/code&gt;?&lt;/h3&gt;
&lt;p&gt;What is the effect of parsing &lt;code&gt;scoped&lt;/code&gt; as a modifier on existing code that uses &lt;code&gt;scoped&lt;/code&gt; as a type name or identifier?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// C#10: 'scoped' type
class scoped { }
scoped s;
static void F(scoped x, ref scoped y) { }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;// C#10: 'scoped' identifier
bool scoped;
scoped = true;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;2. Allow &lt;code&gt;ref&lt;/code&gt; auto properties?&lt;/h3&gt;
&lt;p&gt;Support &lt;code&gt;ref&lt;/code&gt; auto property declarations? If so, allow &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;init&lt;/code&gt;?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;ref T P0 { get; }
ref T P1 { get; set; }
ref T P2 { get; init; }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;3. Allow &lt;code&gt;ref&lt;/code&gt; assignment in object initializers?&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;ref struct R&amp;lt;T&amp;gt;
{
    public ref T F;
}

int i = 0;
var r = new R&amp;lt;int&amp;gt; { F = ref i };
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;4. Report diagnostic for constructor that does not set &lt;code&gt;ref&lt;/code&gt; field?&lt;/h3&gt;
&lt;p&gt;Report a diagnostic for an explicit constructor that does not assign to a &lt;code&gt;ref&lt;/code&gt; field, or that assigns a value?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;ref struct R&amp;lt;T&amp;gt;
{
    private ref T _t;

    public R() { } // warning: ref is not assigned

    public R(ref T t)
    {
        _t = t; // warning: assigning value not ref
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;5. &lt;code&gt;scoped&lt;/code&gt; differences in overrides and interface implementations&lt;/h3&gt;
&lt;p&gt;Report a diagnostic for mismatches of &lt;code&gt;scoped&lt;/code&gt; across overrides or implicit or explicit interface implementations? Allow &amp;quot;safe&amp;quot; variance differences?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;ref struct R&amp;lt;T&amp;gt; { }

abstract class A&amp;lt;T&amp;gt;
{
    public abstract R&amp;lt;T&amp;gt; F1(scoped R&amp;lt;T&amp;gt; r);
    public abstract R&amp;lt;T&amp;gt; F2(R&amp;lt;T&amp;gt; r);
}

class B : A&amp;lt;int&amp;gt;
{
    public override R&amp;lt;int&amp;gt; F1(R&amp;lt;int&amp;gt; r) =&amp;gt; r;              // error?
    public override R&amp;lt;int&amp;gt; F2(scoped R&amp;lt;int&amp;gt; r) =&amp;gt; default; // ok?
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Proposed: Report errors for any differences in &lt;code&gt;scoped&lt;/code&gt;, even &amp;quot;safe&amp;quot; differences.&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;6. &lt;code&gt;scoped&lt;/code&gt; differences in delegate conversions&lt;/h3&gt;
&lt;p&gt;Report a diagnostic for mismatches of &lt;code&gt;scoped&lt;/code&gt; in conversions from lambda expressions or method groups to delegate types? Allow &amp;quot;safe&amp;quot; variance differences?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;ref struct R { }

delegate R D1(scoped R r);
delegate R D2(R r);

D1 i1 = (R r) =&amp;gt; r;              // error?
D2 i2 = (scoped R r) =&amp;gt; default; // ok?

D1 e1 = (D1)((R r) =&amp;gt; r);              // error?
D2 e2 = (D2)((scoped R r) =&amp;gt; default); // ok?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Proposed: Report errors for any differences in &lt;code&gt;scoped&lt;/code&gt;, even &amp;quot;safe&amp;quot; differences.&lt;/em&gt;&lt;/p&gt;
</description>
      <pubDate>Fri, 20 May 2022 19:42:11 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6117</guid>
      <link>https://github.com/dotnet/csharplang/issues/6117</link>
      <title>Issue: Define a syntax to conditionally set (init) properties in object initializers - @AArnott</title>
      <description>&lt;h3&gt;Discussed in https://github.com/dotnet/csharplang/discussions/5588&lt;/h3&gt;
&lt;div type='discussions-op-text'&gt;
&lt;p&gt;&lt;sup&gt;Originally posted by &lt;strong&gt;AArnott&lt;/strong&gt; December 29, 2021&lt;/sup&gt;
In https://github.com/neuecc/MessagePack-CSharp/pull/1369#issuecomment-1002726721 we discuss how it seems to be impossible to initialize an object's &lt;code&gt;init&lt;/code&gt; properties conditionally. For a deserializer that needs to set these properties &lt;em&gt;iff&lt;/em&gt; values for those properties appear in the serialized data stream, this presents a real problem for AOT generated deserializer code. I expect the System.Text.Json deserializer's new AOT code gen feature in 6.0.0 may suffer from the same problem.&lt;/p&gt;
&lt;p&gt;For example consider initializing this object:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;public class A {
  public int B { get; init; } = 3;
  public int C { get; init; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Properties B and C can only be set with syntax like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;A a = new A {
  B = 5,
  C = 2,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is fine for hand-written code. But for an AOT code generated deserializer when values for B or C are optional, we would need something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;A a = new A {
  B = reader.ReadInt32(&amp;quot;B&amp;quot;),
  C = reader.ReadInt32(&amp;quot;C&amp;quot;),
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But how would we make the assignments to B (and C) optional such that a missing value for B would allow the &lt;code&gt;3&lt;/code&gt; default value to remain? There is no syntax supported in C# today to do this. An alternative might be to invoke it with its existing value, but as there is no way to reference the object within its own object initializer, we can't do something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;A a = new A {
  B = reader.TryReadInt32(&amp;quot;B&amp;quot;, out int v) ? v : _.B,
  C = reader.ReadInt32(&amp;quot;C&amp;quot;),
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Above I hypothesize that &lt;code&gt;_&lt;/code&gt; is a reference to the initializing object, but this isn't valid C# 10 code.&lt;/p&gt;
&lt;p&gt;Do we need a new feature for this?&lt;/div&gt;&lt;/p&gt;
&lt;p&gt;@CyrusNajmabadi suggested this syntax, which is quite nice:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;var readB = reader.TryReadInt32(&amp;quot;B&amp;quot;, out int b);
var c = reader.ReadInt32(&amp;quot;C&amp;quot;);;
A a = new A
{
    B = b when readB,
    C = c
};
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Thu, 12 May 2022 12:30:08 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6099</guid>
      <link>https://github.com/dotnet/csharplang/issues/6099</link>
      <title>Issue: Proposal: Alternate syntax to !! for null parameter checks - @coolbluewater</title>
      <description>&lt;p&gt;This is an alternate proposal to the proposed &lt;code&gt;!!&lt;/code&gt; null parameter checks in C# 11 - see https://github.com/dotnet/runtime/pull/64720.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1: Regular method&lt;/strong&gt;
Instead of:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;void M(object arg1!!, int arg3, object arg3!!)
{
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Write:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;void M(object arg1, int arg2, object arg3)
   : notnull(arg1, arg3)
{
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Example 2: Constructors&lt;/strong&gt;
Instead of:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;Class(object arg1!!, int arg2, object arg3!!) 
   : base(arg1, arg2)
{
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Write:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;Class(object arg1, int arg2, object arg3)
   : notnull(arg1, arg3)
   : base(arg1, arg2)
{
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Discussion&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The keyword is up for debate. Some other possibilities are &lt;code&gt;defines&lt;/code&gt;, &lt;code&gt;defined&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The syntax follows that of the &lt;code&gt;base&lt;/code&gt; keyword, and so fits naturally into C#.&lt;/li&gt;
&lt;li&gt;The placement of &lt;code&gt;notnull&lt;/code&gt; indicates that it is executed before any of the code in the method.&lt;/li&gt;
&lt;li&gt;For constructors, &lt;code&gt;notnull&lt;/code&gt; must come before the &lt;code&gt;base&lt;/code&gt; statement, if any. This indicates that &lt;code&gt;notnull&lt;/code&gt; is executed before the base class constructor.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;notnull&lt;/code&gt; statement takes only one line, regardless of the number of arguments to be null checked.&lt;/li&gt;
&lt;li&gt;The use of a separate &lt;code&gt;notnull&lt;/code&gt; statement allows a breakpoint to be set.&lt;/li&gt;
&lt;li&gt;This syntax provides enough room for other such statements in the future.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;@KathleenDollard @stephentoub&lt;/p&gt;
</description>
      <pubDate>Fri, 06 May 2022 14:24:39 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6095</guid>
      <link>https://github.com/dotnet/csharplang/issues/6095</link>
      <title>Issue: [API Proposal]: new&lt;TArgument&gt;() generic constraints for constructor with parameters - @MithrilMan</title>
      <description>&lt;h3&gt;Background and motivation&lt;/h3&gt;
&lt;p&gt;Actually we can instantiate generic types, without using Activator.CreateInstance, if we put a &lt;code&gt;new()&lt;/code&gt; generic constraint but this is limited to parameterless constructor.&lt;/p&gt;
&lt;p&gt;If we want to instantiate a generic type using a constructor overload, we have to find alternative solutions.&lt;/p&gt;
&lt;p&gt;Suppose a scenario where I want to create a Guard static class like this&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static class Guard
{
   public static void Against&amp;lt;TException&amp;gt;(bool assertion, string message) where TException : Exception
   {
      if (assertion)
         throw (TException)Activator.CreateInstance(typeof(TException), message);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where I can pass an exception as a generic type, I have to use Activator.CreateInstance if I want to instantiate it with a message.&lt;/p&gt;
&lt;h3&gt;API Proposal&lt;/h3&gt;
&lt;p&gt;having a way to set a generic constructor with parameter constraint would solve the issue.&lt;/p&gt;
&lt;p&gt;a constraint in the form of&lt;/p&gt;
&lt;p&gt;&lt;code&gt;new&amp;lt;TArgument1&amp;gt;()&lt;/code&gt;
&lt;code&gt;new&amp;lt;TArgument1, TArgument2&amp;gt;()&lt;/code&gt;
&lt;code&gt;new&amp;lt;TArgument1, TArgument2, TArgument3&amp;gt;()&lt;/code&gt;
...&lt;/p&gt;
&lt;h3&gt;API Usage&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static class Guard
{
   public static void Against&amp;lt;TException&amp;gt;(bool assertion, string message) where TException : Exception, new&amp;lt;string&amp;gt;()
   {
      if (assertion)
         throw new TException(message);
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Alternative Designs&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;No response&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;Risks&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;No response&lt;/em&gt;&lt;/p&gt;
</description>
      <pubDate>Wed, 04 May 2022 15:25:40 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6089</guid>
      <link>https://github.com/dotnet/csharplang/issues/6089</link>
      <title>Issue: [semi-auto-props]: Revise spec regarding `set;` - @Youssef1313</title>
      <description>&lt;p&gt;The spec for semi-auto properties allows &lt;code&gt;public int P { set; }&lt;/code&gt; where it used to produce &lt;code&gt;error CS8051: Auto-implemented properties must have get accessors.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;I don't see a real benefit from allowing &lt;code&gt;set;&lt;/code&gt; only property. Should it be disallowed?&lt;/p&gt;
&lt;p&gt;@333fred @AlekseyTs @CyrusNajmabadi&lt;/p&gt;
</description>
      <pubDate>Tue, 03 May 2022 19:56:53 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6081</guid>
      <link>https://github.com/dotnet/csharplang/issues/6081</link>
      <title>Issue: [Required Members]: Effect of `SetsRequiredMembers` on nullable analysis - @333fred</title>
      <description>&lt;p&gt;Previously, LDM decided that we would not enforce that all members are assigned in the body of a constructor marked with &lt;code&gt;SetsRequiredMembers&lt;/code&gt;, and we'd instead trust the user for that scenario. We still need to decide, however, what effect &lt;code&gt;SetsRequiredMembers&lt;/code&gt; has on nullable analysis.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;class C
{
    public required string Field;
    [SetsRequiredMembers]
    public C()
    {
    } // Warning about Field being null or not?
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our options are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Do nothing. The user specified &lt;code&gt;SetsRequiredMembers&lt;/code&gt;, which is effectively an option to tell the compiler &amp;quot;don't worry about it&amp;quot;.&lt;/li&gt;
&lt;li&gt;Warn about potentially nullable fields/properties at the end of the constructor. Even if the enforcement would be uneven (we wouldn't warn if a value type field or a nullable field was unset), it would give &lt;em&gt;some&lt;/em&gt; amount of guardrail, and for the things that are likely most vulnerable to a null reference exception if something goes wrong.&lt;/li&gt;
&lt;/ol&gt;
</description>
      <pubDate>Sat, 30 Apr 2022 01:07:56 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6080</guid>
      <link>https://github.com/dotnet/csharplang/issues/6080</link>
      <title>Issue: [semi-auto-props] Question: DefiniteAssignment warning for properties with a setter - @Youssef1313</title>
      <description>&lt;pre&gt;&lt;code class="language-csharp"&gt;public struct C
{
    public C()
    {
        // Is this warning expected?
        // CS9020: The 'this' object is read before all of its fields have been assigned, causing preceding implicit assignments of 'default' to non-explicitly assigned fields.
        P = 5;
    }

    public int P { get =&amp;gt; field; set =&amp;gt; field = value; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is no way to ensure the field is definitely assigned without using an initializer.&lt;/p&gt;
</description>
      <pubDate>Fri, 29 Apr 2022 19:17:47 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6077</guid>
      <link>https://github.com/dotnet/csharplang/issues/6077</link>
      <title>Issue: [semi-auto-props] Question: Override `set` only of an auto property - @Youssef1313</title>
      <description>&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Base
{
    public virtual int P { get; set; }
}

public class Derived : Base
{  
    // This produces &amp;quot;Auto-implemented properties must have get accessors.&amp;quot;
    // However, per the spec updates, a set-only with semicolon is allowed.
    // Should this now produce an error similar to ERR_AutoPropertyMustOverrideSet?
    // ERR_AutoPropertyMustOverrideSet is &amp;quot;&amp;quot;Auto-implemented properties must override all accessors of the overridden property.&amp;quot;
    public override int P { set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The spec update that means a set-only is allowed is:&lt;/p&gt;
&lt;p&gt;https://github.com/dotnet/csharplang/blob/main/proposals/semi-auto-properties.md&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-diff"&gt;+ An automatically implemented property (or ***auto-property*** for short), is a non-abstract non-extern
+ property with either or both of:
+ 1. an accessor with a semicolon-only body
+ 2. usage of the `field` contextual keyword ([Keywords](lexical-structure.md#keywords)) within the accessors or
+    expression body of the property. The `field` identifier is only considered the `field` keyword when there is
+    no existing symbol named `field` in scope at that location.

&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Fri, 29 Apr 2022 04:49:57 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6076</guid>
      <link>https://github.com/dotnet/csharplang/issues/6076</link>
      <title>Issue: [semi-auto-props] Question: Override `get` only of an auto property where the override uses `field` keyword - @Youssef1313</title>
      <description>&lt;pre&gt;&lt;code class="language-csharp"&gt;public class Base
{
    public virtual int P { get; set; }
}

public class Derived : Base
{
    // Will this be allowed? It's not allowed for old-style auto properties (see P4).
    public override int P { get =&amp;gt; field; }

    // public override int P { get; }
    // The above produces the following error:
    // Auto-implemented properties must override all accessors of the overridden property.
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Fri, 29 Apr 2022 04:49:56 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6065</guid>
      <link>https://github.com/dotnet/csharplang/issues/6065</link>
      <title>Issue: Champion: numeric IntPtr - @jcouv</title>
      <description>&lt;h1&gt;numeric IntPtr&lt;/h1&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;System.IntPtr&lt;/code&gt; and &lt;code&gt;System.UIntPtr&lt;/code&gt; become numeric types, aliased by &lt;code&gt;nint&lt;/code&gt; and &lt;code&gt;nuint&lt;/code&gt;, and gain the built-in status of &lt;code&gt;nint&lt;/code&gt; and &lt;code&gt;nuint&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Motivation&lt;/h2&gt;
&lt;p&gt;As part of numerics work for .NET 7, &lt;code&gt;System.IntPtr&lt;/code&gt; and &lt;code&gt;System.UIntPtr&lt;/code&gt; are becoming proper numeric types.
So the distinction between native integer types and their underlying types becomes unnecessary.&lt;/p&gt;
&lt;h2&gt;Detailed design&lt;/h2&gt;
&lt;p&gt;https://github.com/dotnet/csharplang/blob/main/proposals/numeric-intptr.md (currently in &lt;a href="https://github.com/dotnet/csharplang/pull/6031"&gt;draft PR&lt;/a&gt;)&lt;/p&gt;
&lt;h2&gt;Drawbacks&lt;/h2&gt;
&lt;h2&gt;Alternatives&lt;/h2&gt;
&lt;h2&gt;Unresolved questions&lt;/h2&gt;
&lt;h2&gt;Design meetings&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-05-09.md#numeric-intptr&lt;/li&gt;
&lt;/ul&gt;
</description>
      <pubDate>Tue, 26 Apr 2022 18:16:45 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6051</guid>
      <link>https://github.com/dotnet/csharplang/issues/6051</link>
      <title>Issue: [Proposal]: Support default parameter values in lambdas - @captainsafia</title>
      <description>&lt;h1&gt;Support default parameter values in lambdas&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;[x] Proposed&lt;/li&gt;
&lt;li&gt;[ ] Prototype: Not Started&lt;/li&gt;
&lt;li&gt;[ ] Implementation: Not Started&lt;/li&gt;
&lt;li&gt;[ ] Specification: Not Started&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;To build on top of the lambda improvements introduced in C#10, we propose adding support for default parameter values in lambdas. This would enable users to implement the following lambdas.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var addWithDefault = (int addTo = 2) =&amp;gt; addTo + 1;
addWithDefault(); // 3
addWithDefault(5); // 6
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Motivation&lt;/h2&gt;
&lt;p&gt;App frameworks in the .NET ecosystem leverage lambdas heavily to allow users to quickly write business logic associated with an endpoint.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var app = WebApplication.Create(args);

app.MapPost(&amp;quot;/todos/{id}&amp;quot;, (int id, string task, TodoService todoService) =&amp;gt; {
  var todo = todoService.Create(id, task);
  return Results.Created(todo);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lambdas don't currently support setting default values on parameters, so if a developer wanted to build an application that was resilient to scenarios where users didn't provide data, they're left to either use local functions or set the default values within the lambda body, as opposed to the more succinct proposed syntax.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var app = WebApplication.Create(args);

app.MapPost(&amp;quot;/todos/{id}&amp;quot;, (int id, string task = &amp;quot;foo&amp;quot;, TodoService todoService) =&amp;gt; {
  var todo = todoService.Create(id, task);
  return Results.Created(todo);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The proposed syntax also has the benefit of reducing confusing differences between lambdas and local functions, making it easier to reason about constructs and &amp;quot;grow up&amp;quot; lambdas to functions without compromising features, particularly in other scenarios where lambdas are used in APIs where method groups can also be provided as references.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var rootCommand = new RootCommand();
rootCommand.SetHandler((int pathOption, bool forceOption) =&amp;gt; { ... })
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Detailed design&lt;/h2&gt;
&lt;p&gt;Currently, when a user implements a lambda with a default value, the compiler raises a &lt;code&gt;CS1065&lt;/code&gt; error.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var addWithDefault = (int addTo = 2) =&amp;gt; addTo + 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Default values can be applied to lambda parameters with the following behavior.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var addWithDefault = (int addTo = 2) =&amp;gt; addTo + 1;
addWithDefault(); // 3
addWithDefault(5); // 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The default value will be emitted to metadata. Users can introspect the &lt;code&gt;DefaultValue&lt;/code&gt; in the &lt;code&gt;ParameterInfo&lt;/code&gt; associated with the lambda's &lt;code&gt;MethodInfo&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var addWithDefault = (int addTo = 2) =&amp;gt; addTo + 1;
addWithDefault.Method.GetParameters()[0].DefaultValue; // 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Similar to the behavior for delegates with &lt;code&gt;out&lt;/code&gt; parameters or , a new natural type is generated for each lambda defined with any default parameter values.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var addWithDefault = (int addTo = 2) =&amp;gt; addTo + 1;
// internal delegate int &amp;lt;&amp;gt;F{00000002}(int arg0 = 2);
var printString = (string toPrint = &amp;quot;defaultString&amp;quot;) =&amp;gt; Console.WriteLine(toPrint);
// internal delegate void &amp;lt;&amp;gt;F{00000003}(string arg0 = &amp;quot;defaultString&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This enhancement requires the following changes to the grammar for lambda expressions.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-diff"&gt;explicit_anonymous_function_parameter
-    : anonymous_function_parameter_modifier? type identifier
+    : anonymous_function_parameter_modifier? type identifier default_argument?
    ;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Open Questions&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Open question:&lt;/strong&gt; how does this change affect delegate unification behavior?&lt;/p&gt;
&lt;p&gt;Proposed answer: Delegates will be unified when the same parameter (based on order) has the same default value, regardless of parameter name.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var a = (int i = 13) =&amp;gt; 1;
// internal delegate int &amp;lt;&amp;gt;F{00000002}(int arg0 = 13);
var b = (int i = 0) =&amp;gt; 2;
// internal delegate int &amp;lt;&amp;gt;F{00000003}(int arg0 = 0);
var c = (int i = 13) =&amp;gt; 3;
// internal delegate int &amp;lt;&amp;gt;F{00000002}(int arg0 = 13);
var d = (int c = 13) =&amp;gt; 1;
// internal delegate int &amp;lt;&amp;gt;F{00000002}(int arg0 = 13);
a = b; // Not allowed
a = c; // Allowed
a = d; // Allowed
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var d = (int x = 10) =&amp;gt; x;
// Not allowed because default parameter value in lambda does not match the default
// value reflected under the hood in the natural type for `d` generated above
d = (int y = 20) =&amp;gt; y; 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;delegate int Del(int a = 1);
// Not allowed because default parameter value in Delegate type does not match
Del del = (int x = 100) =&amp;gt; x;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Open question:&lt;/strong&gt; how does this interact with the existing &lt;code&gt;DefaultParameterValue&lt;/code&gt; attribute?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposed answer:&lt;/strong&gt; For parity, permit the &lt;code&gt;DefaultParameterValue&lt;/code&gt; attribute on lambdas and ensure that the delegate generation behavior matches for default parameter values supported via the syntax.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var a = (int i = 13) =&amp;gt; 1;
// same as
var b = ([DefaultParameterValue(13)] int i) =&amp;gt; 1;
b = a; // Allowed
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Design Discussions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-04-27.md#default-parameter-values-in-lambdas&lt;/li&gt;
&lt;li&gt;https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-07-13.md#lambda-default-parameters&lt;/li&gt;
&lt;/ul&gt;
</description>
      <pubDate>Fri, 22 Apr 2022 19:01:30 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6046</guid>
      <link>https://github.com/dotnet/csharplang/issues/6046</link>
      <title>Issue: Mutex&lt;T&gt; data wrapper - @ctigrisht</title>
      <description>&lt;p&gt;It would be really nice if an object could be wrapped inside of a &lt;code&gt;Mutex&amp;lt;T&amp;gt;&lt;/code&gt; in a way that when the value is accessed a lock occurs&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;// define the data
static ConcurrentDictionary&amp;lt;string, Mutex&amp;lt;MyClass&amp;gt;&amp;gt; MyData = new(); 

// access the data on a separate thread 
var mutexObj = MyData[&amp;quot;key&amp;quot;];
mutexObj.Value.Property = &amp;quot;Some new data&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Thu, 21 Apr 2022 06:13:46 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6045</guid>
      <link>https://github.com/dotnet/csharplang/issues/6045</link>
      <title>Issue: Null-conditional assignment - @RikkiGibson</title>
      <description>&lt;ul&gt;
&lt;li&gt;[x] Proposed&lt;/li&gt;
&lt;li&gt;[ ] Prototype: &lt;a href="https://github.com/PROTOTYPE_OWNER/roslyn/BRANCH_NAME"&gt;Not Started&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[ ] Implementation: &lt;a href="https://github.com/dotnet/roslyn/BRANCH_NAME"&gt;Not Started&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[x] Specification: Included&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;Permits assignment to occur conditionally within a &lt;code&gt;a?.b&lt;/code&gt; or &lt;code&gt;a?[b]&lt;/code&gt; expression.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;using System;

class C
{
    public object obj;
}

void M(C? c)
{
    c?.obj = new object();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;using System;

class C
{
    public event Action E;
}

void M(C? c)
{
    c?.E += () =&amp;gt; { Console.WriteLine(&amp;quot;handled event E&amp;quot;); };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;void M(object[]? arr)
{
    arr?[42] = new object();
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Motivation&lt;/h2&gt;
&lt;p&gt;A variety of motivating use cases can be found in the championed issue. Major motivations include:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Parity between properties and &lt;code&gt;Set()&lt;/code&gt; methods.&lt;/li&gt;
&lt;li&gt;Attaching event handlers in UI code.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Detailed design&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The right side of the assignment is only evaluated when the receiver of the conditional access is non-null.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;// M() is only executed if 'a' is non-null.
// note: the value of 'a.b' doesn't affect whether things are evaluated here.
a?.b = M();
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;All forms of compound assignment are allowed.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;a?.b -= M(); // ok
a?.b += M(); // ok
// etc.
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;If the result of the expression is used, the expression's type must be known to be of a value type or a reference type. This is consistent with existing behaviors on conditional accesses.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;class C&amp;lt;T&amp;gt;
{
    public T? field;
}

void M1&amp;lt;T&amp;gt;(C&amp;lt;T&amp;gt;? c, T t)
{
    (c?.field = t).ToString(); // error: 'T' cannot be made nullable.
    c?.field = t; // ok
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Conditional access expressions are still not lvalues, and it's still not allowed to e.g. take a &lt;code&gt;ref&lt;/code&gt; to them.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;M(ref a?.b); // error
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;It is not allowed to ref-assign to a conditional access. The main reason for this is that the only way you would conditionally access a ref variable is a ref field, and ref structs are forbidden from being used in nullable value types. If a valid scenario for a conditional ref-assignment came up in the future, we could add support at that time.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;ref struct RS
{
    public ref int b;
}

void M(RS a, ref int x)
{
  a?.b = ref x; // error: Operator '?' can't be applied to operand of type 'C'.
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;It's not possible to e.g. assign to conditional accesses through deconstruction assignment. We anticipate it will be rare for people to want to do this, and not a significant drawback to need to do it over multiple separate assignment expressions instead.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;(a?.b, c?.d) = (x, y); // error
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Specification&lt;/h3&gt;
&lt;p&gt;The &lt;em&gt;null conditional assignment&lt;/em&gt; grammar is defined as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-antlr"&gt;null_conditional_assignment
    : null_conditional_member_access assignment_operator expression
    : null_conditional_element_access assignment_operator expression
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;See &lt;a href="https://github.com/dotnet/csharpstandard/blob/draft-v6/standard/expressions.md#1177-null-conditional-member-access"&gt;§11.7.7&lt;/a&gt; and &lt;a href="https://github.com/dotnet/csharpstandard/blob/draft-v6/standard/expressions.md#11711-null-conditional-element-access"&gt;§11.7.11&lt;/a&gt; for reference.&lt;/p&gt;
&lt;p&gt;When the &lt;em&gt;null conditional assignment&lt;/em&gt; appears in an expression-statement, its semantics are as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;P?.A = B&lt;/code&gt; is equivalent to &lt;code&gt;if (P is not null) P.A = B;&lt;/code&gt;, except that &lt;code&gt;P&lt;/code&gt; is only evaluated once.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;P?[A] = B&lt;/code&gt; is equivalent to &lt;code&gt;if (P is not null) P[A] = B&lt;/code&gt;, except that &lt;code&gt;P&lt;/code&gt; is only evaluated once.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Otherwise, its semantics are as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;P?.A = B&lt;/code&gt; with result type &lt;code&gt;T&lt;/code&gt; is equivalent to &lt;code&gt;(P is null) ? (T?)null : (P.A = B)&lt;/code&gt;, except that &lt;code&gt;P&lt;/code&gt; is only evaluated once.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;P?[A] = B&lt;/code&gt; with result type &lt;code&gt;T&lt;/code&gt; is equivalent to &lt;code&gt;(P is null) ? (T?)null : (P[A] = B)&lt;/code&gt;, except that &lt;code&gt;P&lt;/code&gt; is only evaluated once.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Implementation&lt;/h3&gt;
&lt;p&gt;The grammar in the standard currently doesn't correspond strongly to the syntax design used in the implementation. We expect that to remain the case after this feature is implemented. The syntax design in the &lt;a href="https://github.com/dotnet/roslyn/blob/09408ab8a29e03caddfb11f29328c05169ac7cde/src/Compilers/CSharp/Portable/Syntax/Syntax.xml#L583-L607"&gt;implementation&lt;/a&gt; isn't expected to actually change--only the way it is used will change. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-mermaid"&gt;graph TD;
subgraph ConditionalAccessExpression
  whole[a?.b = c]
end
subgraph  
  direction LR;
  subgraph Expression
    whole--&amp;gt;a;
  end
  subgraph OperatorToken
    whole--&amp;gt;?;
  end
  subgraph WhenNotNull
    whole--&amp;gt;whenNotNull[.b = c];
    whenNotNull--&amp;gt;.b;
    whenNotNull--&amp;gt;=;
    whenNotNull--&amp;gt;c;
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Complex examples&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;class C
{
    ref int M() =&amp;gt; /*...*/;
}

void M(C? c)
{
    c?.M() = 42; // equivalent to:
    if (c is not null)
        c.M() = 42;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;M(a?.b?.c = d); // equivalent to:
M(a is null
    ? null
    : (a.b is null
        ? null
        : (a.b.c = d));
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;a?.b = c?.d = e?.f; // equivalent to:
a?.b = (c?.d = e?.f);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;a?.b ??= c; // equivalent to:
if (a is not null)
{
    if (a.b is null)
    {
        a.b = c;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Drawbacks&lt;/h2&gt;
&lt;p&gt;The choice to keep the assignment within the conditional access introduces some additional work for the IDE, which has many code paths which need to work backwards from an assignment to identifying the thing being assigned.&lt;/p&gt;
&lt;h2&gt;Alternatives&lt;/h2&gt;
&lt;p&gt;We could instead make the &lt;code&gt;?.&lt;/code&gt; syntactically a child of the &lt;code&gt;=&lt;/code&gt;. This makes it so any handling of &lt;code&gt;=&lt;/code&gt; expressions needs to become aware of the conditionality of the right side in the presence of &lt;code&gt;?.&lt;/code&gt; on the left. It also makes it so the structure of the syntax doesn't correspond as strongly to the semantics.&lt;/p&gt;
&lt;h2&gt;Unresolved questions&lt;/h2&gt;
&lt;h2&gt;Design meetings&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-04-27.md#null-conditional-assignment&lt;/li&gt;
&lt;li&gt;https://github.com/dotnet/csharplang/blob/main/meetings/2022/LDM-2022-08-31.md#null-conditional-assignment&lt;/li&gt;
&lt;/ul&gt;
</description>
      <pubDate>Thu, 21 Apr 2022 00:26:30 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/csharplang/issues/6038</guid>
      <link>https://github.com/dotnet/csharplang/issues/6038</link>
      <title>Issue: Bug: broken links in spec - @Bouke</title>
      <description>&lt;p&gt;The links on this page are broken: https://github.com/dotnet/csharplang/blob/main/spec/documentation-comments.md. #5815&lt;/p&gt;
</description>
      <pubDate>Tue, 19 Apr 2022 18:52:29 Z</pubDate>
    </item>
  </channel>
</rss>