<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>dotnet/orleans Issues</title>
    <description>Issues from https://github.com/dotnet/orleans, generated by https://github.com/meziantou/IssuesToRss/</description>
    <managingEditor>meziantousite@outlook.com</managingEditor>
    <ttl>60</ttl>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7991</guid>
      <link>https://github.com/dotnet/orleans/issues/7991</link>
      <title>Issue: Setting RequestContext by IIncomingGrainCallFilter from a gRPC service - @danielleiszen</title>
      <description>&lt;p&gt;As far as I understood correctly, when RequestContext.Set is called the given metadata is passed to every grain method call from that point automatically. What is not clear for me in the docs whether the same metadata is being passed to another grain if that is created using GrainFactory.GetGrain&amp;lt;&amp;gt;() during a call that has the metadata passed to already by the mentioned mechanism.&lt;/p&gt;
&lt;p&gt;The metadata I need to pass is a context identifier that can be used to identify the user and other contextual info. I would use the grain filter mechanism (IIncomingGrainCallFilter) for the purpose. However, I do not know how to pass the required information to the filter.&lt;/p&gt;
&lt;p&gt;I use a gRPC service endpoint that gets the IClusterClient from service provider, then creates a grain and calls some of its methods. The context information that I would like to set to the RequestContext comes from the ServerCallContext parameter of the gRPC method. These 3 (service endpoint, grain filter, grain) could run in different threads, I presume. The filter is instantiated by Orleans so I have no control over its life cycle.  As I experienced it is created as a singleton, no matter how I register it in the DI container.&lt;/p&gt;
&lt;p&gt;What is the suggested way of passing data to the grain filter?
In which thread is the Invoke method called? Can I use some thread synchronization mechanism to communicate between the gRPC method and the grain filter?&lt;/p&gt;
&lt;p&gt;Any suggestions are appreciated. Thank you.&lt;/p&gt;
</description>
      <pubDate>Thu, 22 Sep 2022 17:10:05 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7990</guid>
      <link>https://github.com/dotnet/orleans/issues/7990</link>
      <title>Issue: Exception throws when using MemoryStream with PrometheusTelemetryConsumer. - @vrecluse</title>
      <description>&lt;pre&gt;&lt;code&gt;System.ArgumentOutOfRangeException: Length cannot be less than zero. (Parameter 'length')
   at System.String.Substring(Int32 startIndex, Int32 length)
   at Orleans.TelemetryConsumers.Prometheus.PrometheusTelemetryConsumer.GetCategoryFromMetricName(String name)
   at Orleans.TelemetryConsumers.Prometheus.PrometheusTelemetryConsumer.TrackMetric(String name, Double value, IDictionary`2 properties)
   at Orleans.Runtime.TelemetryManager.TrackMetric(String name, Double value, IDictionary`2 properties) in /_/src/Orleans.Core/Telemetry/TelemetryManager.cs:line 52
   at Orleans.Providers.Streams.Common.DefaultQueueAdapterReceiverMonitor.TrackInitialization(Boolean success, TimeSpan callTime, Exception exception) in /_/src/OrleansProviders/Streams/Common/Monitors/DefaultQueueAdapterReceiverMonitor.cs:line 39
   at Orleans.Providers.MemoryAdapterReceiver`1.Initialize(TimeSpan timeout) in /_/src/OrleansProviders/Streams/Memory/MemoryAdapterReceiver.cs:line 32
   at Orleans.Streams.PersistentStreamPullingAgent.&amp;lt;InitializeInternal&amp;gt;b__28_0() in /_/src/Orleans.Runtime/Streams/PersistentStream/PersistentStreamPullingAgent.cs:line 133
   at Orleans.Internal.OrleansTaskExtentions.SafeExecute(Func`1 action) in /_/src/Orleans.Core/Async/TaskExtensions.cs:line 178
   at Orleans.Internal.OrleansTaskExtentions.LogException(Task task, ILogger logger, ErrorCode errorCode, String message) in /_/src/Orleans.Core/Async/TaskExtensions.cs:line 166
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It seems the names passed to TrackMetric do not include '.'&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;        public void TrackInitialization(bool success, TimeSpan callTime, Exception exception)
        {
            this.TelemetryProducer.TrackMetric(&amp;quot;InitializationFailure&amp;quot;, success ? 0 : 1, this.LogProperties);
            this.TelemetryProducer.TrackMetric(&amp;quot;InitializationCallTime&amp;quot;, callTime, this.LogProperties);
            this.TelemetryProducer.TrackMetric(&amp;quot;InitializationException&amp;quot;, exception == null ? 0 : 1, this.LogProperties);
        }

&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Wed, 21 Sep 2022 11:00:59 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7989</guid>
      <link>https://github.com/dotnet/orleans/issues/7989</link>
      <title>Issue: client  cannot   sometimes  receive message from  stream - @baekhyunee7</title>
      <description>&lt;ul&gt;
&lt;li&gt;orleans: 3.6.4
client can sometimes  receive stream message , but sometimes not;
&amp;quot;PubSubStore: is in Memory;
silo seems  succeed to send message to stream; but client cannot receive;
Is there any way  for  client to keep alive  for stream?
silo producer:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var stream = GetStreamProvider( &amp;quot;SimpleMessageStreamProvider&amp;quot; ).GetStream&amp;lt;SomeMessage&amp;gt;( serverId, &amp;quot;SomeMessage&amp;quot; );
await stream.OnNextAsync( new SomeMessage());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;client consumer:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var stream = client.GetStreamProvider( &amp;quot;SimpleMessageStreamProvider&amp;quot;).GetStream&amp;lt;SomeMessage&amp;gt;( serverId, &amp;quot;SomeMessage&amp;quot; );
await _stream.SubscribeAsync(
                                                           ( data, token ) =&amp;gt;
                                                           {
                                                                // do something
                                                           });
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Wed, 21 Sep 2022 06:34:42 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7985</guid>
      <link>https://github.com/dotnet/orleans/issues/7985</link>
      <title>Issue: Make it possible to tune the deactivation of grains in relation to memory usage - @COCPORN</title>
      <description>&lt;p&gt;Make it possible to tune the deactivation of grains in relation to memory usage, both for the GC-reported usage and host environment. Orleans implements &lt;code&gt;IHostEnvironmentStatistics&lt;/code&gt; and &lt;code&gt;IAppEnvironmentStatistics&lt;/code&gt; and these can be queried against configuration to see if deactivation of grains should be suppressed.&lt;/p&gt;
&lt;p&gt;The implementation should have functional parity with the current implementation to make any configurable new behavior not come off as surprising.&lt;/p&gt;
</description>
      <pubDate>Sat, 17 Sep 2022 12:41:49 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7982</guid>
      <link>https://github.com/dotnet/orleans/issues/7982</link>
      <title>Issue: TimeToLive is not working as expected - @hpaikrao</title>
      <description>&lt;p&gt;Hi Team,
I have configured TimeToLive property as per below and expecting a new column to be added in my dyanamodb table.&lt;/p&gt;
&lt;p&gt;.AddDynamoDBGrainStorage(name: &amp;quot;AgentStateStorage&amp;quot;,
configureOptions: options =&amp;gt;
{&lt;br /&gt;
options.TableName = orleansConfiguration.Environment + &amp;quot;-&amp;quot; + orleansConfiguration.DynamoTableName;
options.TimeToLive = TimeSpan.FromMinutes(10);&lt;br /&gt;
})&lt;/p&gt;
&lt;p&gt;After running the code, column name as &amp;quot;GrainTtl&amp;quot; not added into the respective table. Please refer below screenshot. Please suggest any other configuration needed for this to work.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/100188279/190387121-48185c6a-6c7b-4c67-9dbd-b23f83429b52.png" alt="image" /&gt;&lt;/p&gt;
</description>
      <pubDate>Thu, 15 Sep 2022 11:02:26 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7981</guid>
      <link>https://github.com/dotnet/orleans/issues/7981</link>
      <title>Issue: Question about copying on serialization - @bill-poole</title>
      <description>&lt;p&gt;The docs state that the reason why a defensive copy is made of method arguments (unless explicitly marked immutable) is:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;so that they are not mutated while being serialized; and&lt;/li&gt;
&lt;li&gt;so that if the target grain is in the same silo, the message doesn't have to be serialized/deserialized - the target grain can just be given a direct reference to the copy.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The docs also say that if a message/parameter is marked immutable, then it cannot be changed by either the sender or receiver at any time after the message/parameter has been passed to the grain method on the sending grain. However, presumably Orleans doesn't retain a reference to any sent message/parameter once the send operation has completed and the &lt;code&gt;Task&lt;/code&gt; returned by the grain method on the sending grain has completed? Likewise, I wouldn't have thought Orleans would retain a reference to a message/parameter on the receiving grain after the message/parameter has been passed to the grain method implementation on the receiving grain.&lt;/p&gt;
&lt;p&gt;Is this correct? If so, I believe better default behavior would be:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;take a defensive copy of messages being sent to grains in the same silo (i.e., those that are not serialized/deserialized to/from a channel) that are not marked as immutable; and&lt;/li&gt;
&lt;li&gt;do not take a defensive copy of messages being sent to grains in different silos.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The issue/risk of message objects being mutated while serialized (i.e., before the &lt;code&gt;Task&lt;/code&gt; returned from the grain proxy method is completed) is the same with all async serializers. For example, the &lt;code&gt;JsonSerializer.SerializeAsync&lt;/code&gt; method does not (to my knowledge) take a defensive copy of the object to be serialized. It just requires that the given object is not mutated while it is being serialized. I therefore believe this should be sufficient precedent for Orleans to only take defensive copies of messages being sent to target grains in the same silo.&lt;/p&gt;
</description>
      <pubDate>Thu, 15 Sep 2022 05:32:56 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7980</guid>
      <link>https://github.com/dotnet/orleans/issues/7980</link>
      <title>Issue: [Proposal] Allow ImmutableAttribute to be applied to method arguments - @bill-poole</title>
      <description>&lt;p&gt;In the spirit of making grains more &amp;quot;POCO&amp;quot;, I think there would be less friction (e.g., in unit tests) to allow grain method parameters to be declared immutable by decorating them with the &lt;code&gt;ImmutableAttribute&lt;/code&gt;, rather than having to wrap them in an &lt;code&gt;Immutable&amp;lt;T&amp;gt;&lt;/code&gt; instance (for types that are not owned/controlled by the project).&lt;/p&gt;
</description>
      <pubDate>Thu, 15 Sep 2022 05:19:54 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7979</guid>
      <link>https://github.com/dotnet/orleans/issues/7979</link>
      <title>Issue: AWS SQS Message On-Demand Deserialization Support  - @connorgilheany</title>
      <description>&lt;p&gt;Current Version: 3.2&lt;/p&gt;
&lt;p&gt;To support production operational responsibilities, I need a way to deserialize SQS stream messages. These are serialized and deserialized in Orleans via the SQSBatchContainer and SerializationManager.&lt;/p&gt;
&lt;p&gt;The use case is to view messages that failed to be processed. If this happens in our system, there is likely some remediation that needs to happen outside of just shovelling the messages back into the main queue. We could try to rely on our logs, but it's very possible that we won't get every piece of data that we need there. Additionally, if theres a poison pill message that continually fails to be processed, we need to view that message to determine why.&lt;/p&gt;
&lt;p&gt;It seems impossible to replicate the deserialization code that Orleans would invoke on these messages. This appears to be where it all happens in Orleans 3.x: https://github.com/dotnet/orleans/blob/7dd8d299fedf2c21bda17b1c037c7bb3d817cafb/src/AWS/Orleans.Streaming.SQS/Streams/SQSBatchContainer.cs#L99&lt;/p&gt;
&lt;p&gt;The issues that I've encountered are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SerializationManager is not accessible via DI in my application (which uses Microsoft.Extensions.DependencyInjection), and&lt;/li&gt;
&lt;li&gt;SQSBatchContainer is internal, so I have no reference type to deserialize the object into.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;My suggestion is to:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Make SerializationManager accessible via DI, and&lt;/li&gt;
&lt;li&gt;Make SQSBatchContainer public&lt;/li&gt;
&lt;/ol&gt;
</description>
      <pubDate>Wed, 14 Sep 2022 22:17:58 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7978</guid>
      <link>https://github.com/dotnet/orleans/issues/7978</link>
      <title>Issue: GrainServices aren't working because DI doesn't inject IGrainIdentity - @t4s-ryan</title>
      <description>&lt;p&gt;Hello!&lt;/p&gt;
&lt;p&gt;We are trying to use a GrainService to hold a shared messaging service within our application, but are having difficulties getting the service to activate.  We've been following the documentation here:&lt;/p&gt;
&lt;p&gt;https://dotnet.github.io/orleans/docs/grains/grainservices.html&lt;/p&gt;
&lt;p&gt;What we're seeing is that when the grain is activated and its constructor called:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;public MessagingServiceGrain(IMessagingManager messagingManager, IGrainIdentity grainId, Silo silo, ILoggerFactory loggerFactory)
: base(grainId, silo, loggerFactory)
{
_messagingManager = messagingManager;
_logger = loggerFactory.CreateLogger&lt;MessagingServiceGrain&gt;();
}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The runtime produces the following error:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;InvalidOperationException: Unable to resolve service for type 'Orleans.Core.IGrainIdentity' while attempting to activate 'Fintercept.Grains.Services.MessagingServiceGrain'.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The IGrainIdentity is definitely required by the GrainService base class constructor:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;//     Constructor to use for grain services
protected GrainService(IGrainIdentity grainId, Silo silo, ILoggerFactory loggerFactory);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So, you'd think that the DI will drop this in for you as required.  As discussed in issue #3148 (https://github.com/dotnet/orleans/issues/3148), the DI doesn't do this and it is suggested that it isn't possible to set it up yourself.&lt;/p&gt;
&lt;p&gt;How does one overcome this issue?&lt;/p&gt;
</description>
      <pubDate>Wed, 14 Sep 2022 20:44:43 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7977</guid>
      <link>https://github.com/dotnet/orleans/issues/7977</link>
      <title>Issue: Proposed additions to GrainCancellationTokenSource - @bill-poole</title>
      <description>&lt;p&gt;It's good practice to make grain methods cancelable by passing a &lt;code&gt;GrainCancellationToken&lt;/code&gt; to each grain method. However, if we are calling a grain method via an Orleans client, then we have a &lt;code&gt;CancellationToken&lt;/code&gt;, not a &lt;code&gt;GrainCancellationToken&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Ideally, grain methods would just accept a &lt;code&gt;CancellationToken&lt;/code&gt; rather than a &lt;code&gt;GrainCancellationToken&lt;/code&gt;, which would make grains more &amp;quot;POCO&amp;quot;. However, in the absence of that, either or both of the following two additions would be helpful:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Add a &lt;code&gt;GrainCancellationTokenSource.CreateLinkedTokenSource(CancellationToken)&lt;/code&gt; method like what exists on the &lt;code&gt;CancellationTokenSource&lt;/code&gt; class. This would allow us to more easily create a &lt;code&gt;GrainCancellationTokenSource&lt;/code&gt; linked to an existing &lt;code&gt;CancellationToken&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Add an implicit converter from a &lt;code&gt;CancellationToken&lt;/code&gt; to a &lt;code&gt;GrainCancellationToken&lt;/code&gt; so we can pass an existing &lt;code&gt;CancellationToken&lt;/code&gt; directly to a grain method accepting a &lt;code&gt;GrainCancellationToken&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In the absence of either of the above, we are forced to write code like below.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;using var cts = new GrainCancellationTokenSource();
using (context.CancellationToken.Register(
    cts =&amp;gt; ((GrainCancellationTokenSource)cts!).Cancel(), cts))
    {
        await grain.Method(..., cts.Token);
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Wed, 14 Sep 2022 10:45:03 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7974</guid>
      <link>https://github.com/dotnet/orleans/issues/7974</link>
      <title>Issue: 4.0-preview2 missing IStartupTask and maybe other types as well - @rjygraham</title>
      <description>&lt;p&gt;I'm trying to use IStartupTask in 4.0-preview2 but the type appears to be missed in the consolidation work that occurred between preview1 and preview2.&lt;/p&gt;
&lt;p&gt;The type is available in Microsoft.Orleans.Runtime.Abstractions 4.0-preview1 but adding that package ends up adding duplicate types across Microsoft.Orleans.Runtime.Abstractions 4.0-preview1 and Microsoft.Orleans.Runtime 4.0-preview2 which makes compiler all kinds of mad. &lt;/p&gt;
&lt;p&gt;Not sure how close 4.0-preview3 is to release, but 4.0-preview2 is unusable for some scenarios due to this issue.&lt;/p&gt;
</description>
      <pubDate>Mon, 12 Sep 2022 21:06:39 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7973</guid>
      <link>https://github.com/dotnet/orleans/issues/7973</link>
      <title>Issue: Silos no longer stable after upgrading to v3.6.2 - @DocIT-Official</title>
      <description>&lt;p&gt;Background:&lt;/p&gt;
&lt;p&gt;Been running Orleans in our production SAAS platform for a few years now, we have 8 silo's however 4 out of 8 are the same docker container just some different labels in AKS deployment to load different grain assemblies. the reason for this is that we have real-time OCR processing and that we want that work to run in their own PODS. this has been working with great success for over 2 years. however we upgrade all our nuget packages to v3.6.2 and now we are getting hundreds of pod restarts because pods stop responding to heartbeat while processing work which is causing work to be aborted, I'm looking for some guidance as this behavior is only observed once deployed to AKS, all our integration tests pass and nothing is showing up in insights to make us believe there any unhandled exceptions&lt;/p&gt;
</description>
      <pubDate>Mon, 12 Sep 2022 18:01:32 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7972</guid>
      <link>https://github.com/dotnet/orleans/issues/7972</link>
      <title>Issue: Re-entrant grain flow control question - @bill-poole</title>
      <description>&lt;p&gt;Does Orleans provide flow control to re-entrant grains, or is it left up to each re-entrant grain to use a &amp;quot;max concurrency&amp;quot; rate limiter and then throw an exception if the number of concurrent requests exceeds the allowable number? Ideally, Orleans would limit/block callers until the target grain is under the configured &amp;quot;max concurrency&amp;quot;.&lt;/p&gt;
&lt;p&gt;If Orleans provides no such controls/limits, then all re-entrant grains are arguably exposed to denial-of-service (DoS) attacks, unless those grains have implemented custom rate limiting controls (like throwing an exception if the rate limiter is at capacity).&lt;/p&gt;
&lt;p&gt;All grains should apply backpressure to calling grains and it's not clear from the Orleans documentation whether it does this for re-entrant grains. I'm aware that the &lt;code&gt;SiloMessagingOptions.MaxEnqueuedRequestsHardLimit&lt;/code&gt; option can be used to provide flow control for non-re-entrant grains; but, it doesn't seem like this will work for re-entrant grains. Apologies if I have that wrong.&lt;/p&gt;
</description>
      <pubDate>Sat, 10 Sep 2022 11:15:58 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7970</guid>
      <link>https://github.com/dotnet/orleans/issues/7970</link>
      <title>Issue: Orleans stream PersistentStreamPullingAgent: JsonSerializationException for  Orleans.Providers.Streams.Common.EventSequenceTokenV2 - @iamsamcoder</title>
      <description>&lt;p&gt;My app is running Orleans 3.5.1. I'm developing with docker locally and deploying to AKS.&lt;/p&gt;
&lt;p&gt;Up to this point, my client and silo have ran in the same process and streaming has worked without issue. I recently created an external client to push stream messages from another service. Since this change, my messages are failing in AKS only, they work fine running locally in Docker.&lt;/p&gt;
&lt;p&gt;Here is the exception message:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-log"&gt;[{&amp;quot;severityLevel&amp;quot;:&amp;quot;Error&amp;quot;,&amp;quot;outerId&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;Unable to find a constructor to use for type Orleans.Providers.Streams.Common.EventSequenceTokenV2. A class should either have a default constructor, one constructor with arguments or a constructor marked with the JsonConstructor attribute. Path 'SequenceToken.SequenceNumber', line 1, position 239.&amp;quot;,&amp;quot;type&amp;quot;:&amp;quot;Newtonsoft.Json.JsonSerializationException&amp;quot;,&amp;quot;id&amp;quot;:&amp;quot;35356266&amp;quot;,
&amp;quot;parsedStack&amp;quot;:[{&amp;quot;assembly&amp;quot;:&amp;quot;System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e&amp;quot;,&amp;quot;method&amp;quot;:&amp;quot;System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw&amp;quot;,&amp;quot;level&amp;quot;:0,&amp;quot;line&amp;quot;:0},
{&amp;quot;assembly&amp;quot;:&amp;quot;System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e&amp;quot;,&amp;quot;method&amp;quot;:&amp;quot;System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess&amp;quot;,&amp;quot;level&amp;quot;:1,&amp;quot;line&amp;quot;:0},
{&amp;quot;assembly&amp;quot;:&amp;quot;System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e&amp;quot;,&amp;quot;method&amp;quot;:&amp;quot;System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification&amp;quot;,&amp;quot;level&amp;quot;:2,&amp;quot;line&amp;quot;:0},
{&amp;quot;assembly&amp;quot;:&amp;quot;Orleans.Core, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null&amp;quot;,&amp;quot;method&amp;quot;:&amp;quot;Orleans.Internal.OrleansTaskExtentions+&amp;lt;&amp;lt;ToTypedTask&amp;gt;g__ConvertAsync|4_0&amp;gt;d`1.MoveNext&amp;quot;,&amp;quot;level&amp;quot;:3,&amp;quot;line&amp;quot;:0},
{&amp;quot;assembly&amp;quot;:&amp;quot;System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e&amp;quot;,&amp;quot;method&amp;quot;:&amp;quot;System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw&amp;quot;,&amp;quot;level&amp;quot;:4,&amp;quot;line&amp;quot;:0},
{&amp;quot;assembly&amp;quot;:&amp;quot;System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e&amp;quot;,&amp;quot;method&amp;quot;:&amp;quot;System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess&amp;quot;,&amp;quot;level&amp;quot;:5,&amp;quot;line&amp;quot;:0},
{&amp;quot;assembly&amp;quot;:&amp;quot;System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e&amp;quot;,&amp;quot;method&amp;quot;:&amp;quot;System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification&amp;quot;,&amp;quot;level&amp;quot;:6,&amp;quot;line&amp;quot;:0},
{&amp;quot;assembly&amp;quot;:&amp;quot;Orleans.Runtime, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null&amp;quot;,&amp;quot;method&amp;quot;:&amp;quot;Orleans.Streams.PersistentStreamPullingAgent+&amp;lt;DeliverBatchToConsumer&amp;gt;d__43.MoveNext&amp;quot;,&amp;quot;level&amp;quot;:7,&amp;quot;line&amp;quot;:0},
{&amp;quot;assembly&amp;quot;:&amp;quot;System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e&amp;quot;,&amp;quot;method&amp;quot;:&amp;quot;System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw&amp;quot;,&amp;quot;level&amp;quot;:8,&amp;quot;line&amp;quot;:0},
{&amp;quot;assembly&amp;quot;:&amp;quot;System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e&amp;quot;,&amp;quot;method&amp;quot;:&amp;quot;System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess&amp;quot;,&amp;quot;level&amp;quot;:9,&amp;quot;line&amp;quot;:0},
{&amp;quot;assembly&amp;quot;:&amp;quot;System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e&amp;quot;,&amp;quot;method&amp;quot;:&amp;quot;System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification&amp;quot;,&amp;quot;level&amp;quot;:10,&amp;quot;line&amp;quot;:0},
{&amp;quot;assembly&amp;quot;:&amp;quot;Orleans.Core, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null&amp;quot;,&amp;quot;method&amp;quot;:&amp;quot;Orleans.Internal.AsyncExecutorWithRetries+&amp;lt;ExecuteWithRetriesHelper&amp;gt;d__4`1.MoveNext&amp;quot;,&amp;quot;level&amp;quot;:11,&amp;quot;line&amp;quot;:0},
{&amp;quot;assembly&amp;quot;:&amp;quot;System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e&amp;quot;,&amp;quot;method&amp;quot;:&amp;quot;System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw&amp;quot;,&amp;quot;level&amp;quot;:12,&amp;quot;line&amp;quot;:0},
{&amp;quot;assembly&amp;quot;:&amp;quot;Orleans.Core, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null&amp;quot;,&amp;quot;method&amp;quot;:&amp;quot;Orleans.Internal.AsyncExecutorWithRetries+&amp;lt;ExecuteWithRetriesHelper&amp;gt;d__4`1.MoveNext&amp;quot;,&amp;quot;level&amp;quot;:13,&amp;quot;line&amp;quot;:0},
{&amp;quot;assembly&amp;quot;:&amp;quot;System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e&amp;quot;,&amp;quot;method&amp;quot;:&amp;quot;System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw&amp;quot;,&amp;quot;level&amp;quot;:14,&amp;quot;line&amp;quot;:0},
{&amp;quot;assembly&amp;quot;:&amp;quot;System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e&amp;quot;,&amp;quot;method&amp;quot;:&amp;quot;System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess&amp;quot;,&amp;quot;level&amp;quot;:15,&amp;quot;line&amp;quot;:0},
{&amp;quot;assembly&amp;quot;:&amp;quot;System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e&amp;quot;,&amp;quot;method&amp;quot;:&amp;quot;System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification&amp;quot;,&amp;quot;level&amp;quot;:16,&amp;quot;line&amp;quot;:0},
{&amp;quot;assembly&amp;quot;:&amp;quot;Orleans.Runtime, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null&amp;quot;,&amp;quot;method&amp;quot;:&amp;quot;Orleans.Streams.PersistentStreamPullingAgent+&amp;lt;RunConsumerCursor&amp;gt;d__41.MoveNext&amp;quot;,&amp;quot;level&amp;quot;:17,&amp;quot;line&amp;quot;:0
}]
}
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The external client pushes a message without a sequence token:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;var streamProvider = _client.GetStreamProvider(_followUpStreamOptions.StreamProviderName);

IAsyncObserver&amp;lt;FollowUpMonitorMessage&amp;gt; observer =
                streamProvider.GetStream&amp;lt;FollowUpMonitorMessage&amp;gt;(grainIdToMessage,
                    _followUpStreamOptions.StreamNamespace);

await observer.OnNextAsync(message);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Event though it shouldn't be necessary, I've tried adding all the same packages (except Orleans server, kubernetes, and event sourcing which are only in the silo app) to both the client and silo just in case, to ensure the same packages are used by both.&lt;/p&gt;
&lt;p&gt;Client:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt; &amp;lt;PackageReference Include=&amp;quot;Microsoft.Orleans.Client&amp;quot; Version=&amp;quot;3.5.1&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.Orleans.Clustering.AzureStorage&amp;quot; Version=&amp;quot;3.5.1&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.Orleans.CodeGenerator.MSBuild&amp;quot; Version=&amp;quot;3.5.1&amp;quot;&amp;gt;
      &amp;lt;PrivateAssets&amp;gt;all&amp;lt;/PrivateAssets&amp;gt;
      &amp;lt;IncludeAssets&amp;gt;runtime; build; native; contentfiles; analyzers; buildtransitive&amp;lt;/IncludeAssets&amp;gt;
    &amp;lt;/PackageReference&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.Orleans.Core&amp;quot; Version=&amp;quot;3.5.1&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.Orleans.Core.Abstractions&amp;quot; Version=&amp;quot;3.5.1&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.Orleans.OrleansRuntime&amp;quot; Version=&amp;quot;3.5.1&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.Orleans.Persistence.AzureStorage&amp;quot; Version=&amp;quot;3.5.1&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.Orleans.Runtime.Abstractions&amp;quot; Version=&amp;quot;3.5.1&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.Orleans.Streaming.AzureStorage&amp;quot; Version=&amp;quot;3.5.1&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Silo:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;PackageReference Include=&amp;quot;Microsoft.Orleans.Client&amp;quot; Version=&amp;quot;3.5.1&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.Orleans.Clustering.AzureStorage&amp;quot; Version=&amp;quot;3.5.1&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.Orleans.CodeGenerator.MSBuild&amp;quot; Version=&amp;quot;3.5.1&amp;quot;&amp;gt;
      &amp;lt;PrivateAssets&amp;gt;all&amp;lt;/PrivateAssets&amp;gt;
      &amp;lt;IncludeAssets&amp;gt;runtime; build; native; contentfiles; analyzers; buildtransitive&amp;lt;/IncludeAssets&amp;gt;
    &amp;lt;/PackageReference&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.Orleans.Core&amp;quot; Version=&amp;quot;3.5.1&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.Orleans.Core.Abstractions&amp;quot; Version=&amp;quot;3.5.1&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.Orleans.EventSourcing&amp;quot; Version=&amp;quot;3.5.1&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.Orleans.Hosting.Kubernetes&amp;quot; Version=&amp;quot;3.5.1&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.Orleans.OrleansRuntime&amp;quot; Version=&amp;quot;3.5.1&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.Orleans.OrleansTelemetryConsumers.AI&amp;quot; Version=&amp;quot;3.5.1&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.Orleans.Persistence.AzureStorage&amp;quot; Version=&amp;quot;3.5.1&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.Orleans.Runtime.Abstractions&amp;quot; Version=&amp;quot;3.5.1&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.Orleans.Server&amp;quot; Version=&amp;quot;3.5.1&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.Orleans.Streaming.AzureStorage&amp;quot; Version=&amp;quot;3.5.1&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Wed, 07 Sep 2022 23:15:54 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7968</guid>
      <link>https://github.com/dotnet/orleans/issues/7968</link>
      <title>Issue: runtime error: Orleans.ClientBuilder.Build() is failing on 3.6.0+ - @johnds1974</title>
      <description>&lt;p&gt;Getting this exception now all of a sudden on a previously working test console app:&lt;/p&gt;
&lt;p&gt;{&amp;quot;Generic implementation type 'Orleans.DefaultOptionsFormatter&lt;code&gt;1' has a DefaultConstructorConstraint ('new()' constraint), but the generic service type 'Orleans.IOptionFormatter&lt;/code&gt;1' doesn't.&amp;quot;}&lt;/p&gt;
&lt;p&gt;at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteFactory.ValidateTrimmingAnnotations(Type serviceType, Type[] serviceTypeGenericArguments, Type implementationType, Type[] implementationTypeGenericArguments)
at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteFactory.Populate()
at Microsoft.Extensions.DependencyInjection.ServiceProvider..ctor(ICollection&lt;code&gt;1 serviceDescriptors, ServiceProviderOptions options) at Microsoft.Extensions.DependencyInjection.ServiceCollectionContainerBuilderExtensions.BuildServiceProvider(IServiceCollection services, ServiceProviderOptions options) at Orleans.Hosting.ServiceProviderFactoryAdapter&lt;/code&gt;1.BuildServiceProvider(HostBuilderContext context, IServiceCollection services)
at Orleans.Hosting.ServiceProviderBuilder.BuildServiceProvider(HostBuilderContext context)
at Orleans.ClientBuilder.Build()
at AgentApp.Program.CreateClusterClient() in C:\DEV\MSOrleansTest\AgentApp\Program.cs:line 102
at AgentApp.Program.&lt;RunMainAsync&gt;d__3.MoveNext() in C:\DEV\MSOrleansTest\AgentApp\Program.cs:line 48&lt;/p&gt;
&lt;p&gt;.Net Core 6.0 console app:&lt;/p&gt;
&lt;p&gt;My &lt;strong&gt;CreateClusterClient&lt;/strong&gt; method (called from main):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    private static Task&amp;lt;IClusterClient&amp;gt; CreateClusterClient()
    {
        //logger.LogInformation($&amp;quot;ConnectClient()...&amp;quot;);

        var client = new ClientBuilder()
            .UseLocalhostClustering()
           .Configure&amp;lt;ClusterOptions&amp;gt;(options =&amp;gt;
            {
                options.ClusterId = &amp;quot;dev&amp;quot;;
                options.ServiceId = &amp;quot;OrleansBasics&amp;quot;;
            })
            //.AddSimpleMessageStreamProvider(&amp;quot;teststream&amp;quot;)
            .ConfigureLogging(logging =&amp;gt; logging.AddNLog())
            .Build();

        return Task.FromResult(client);
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Sun, 04 Sep 2022 16:35:32 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7967</guid>
      <link>https://github.com/dotnet/orleans/issues/7967</link>
      <title>Issue: codegen\ref\xxx.dll could not be found - @zxyao145</title>
      <description>&lt;p&gt;Hi, I'm learning orleans according to https://docs.microsoft.com/zh-cn/dotnet/orleans/tutorials-and-samples/tutorial-1, but the Grains project cannot be rebuild, and an error ouput:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Severity	Code	Description	Project	File	Line	Suppression State
Error	CS0006	Metadata file 'OrlensDemo.GrainInterfacesLib\obj\Debug\net6.0\codegen\ref\OrlensDemo.GrainInterfacesLib.dll' could not be found	OrlensDemo.GrainsLib	D:\codeDemo2\OrlensDemo.SiloServer\OrlensDemo.GrainsLib\CSC	1	Active
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I don't understand why it looks for DLL under &lt;code&gt;codegen\ref&lt;/code&gt;, and my demo is here: https://github.com/zxyao145/OrleansDemo. Can anyone tell me where I was wrong?&lt;/p&gt;
</description>
      <pubDate>Sun, 04 Sep 2022 15:17:23 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7966</guid>
      <link>https://github.com/dotnet/orleans/issues/7966</link>
      <title>Issue: Proposal: Change the way StatelessWorkers are activated - @COCPORN</title>
      <description>&lt;p&gt;Currently, a grain marked as a &lt;code&gt;StatelessWorker&lt;/code&gt; will do a round-robin instantiation of grains to handle the incoming requests. It will keep creating instances of grains until the max level is reached. In most cases this is not ideal in terms of performance and memory usage (especially if you cache data in a local stateless-worker).&lt;/p&gt;
&lt;p&gt;I have a WIP PR coming on this (I am not a previous contributor to Orleans in the core, so please be gentle and somewhat thorough looking at my suggestions). :)&lt;/p&gt;
&lt;p&gt;The PR implements creating activations when the activations that are already busy have an incoming request queue. This makes it so that there are fewer activations in the silo while still keeping things local.&lt;/p&gt;
&lt;p&gt;There are added tests implementing this with locking access to the grain activation with a semaphore to force multiple activations and one that awaits all calls showing that they are all routed to the same activation.&lt;/p&gt;
</description>
      <pubDate>Sat, 03 Sep 2022 16:20:14 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7964</guid>
      <link>https://github.com/dotnet/orleans/issues/7964</link>
      <title>Issue: Proposal: Allow users to opt-in to serializer behavior with parameterized object construction - @mnmr</title>
      <description>&lt;p&gt;It is common for developers to have initialization logic in class constructors, e.g. to pre-calculate some internal state that wasn't part of the serialized data.&lt;/p&gt;
&lt;p&gt;Currently (v4), Orleans always pre-instantiates objects and lets users perform initialization logic through serialization callbacks. The primary motivation for this behavior is that it allows cyclic object graphs to be serialized.&lt;/p&gt;
&lt;p&gt;To ease the migration path to Orleans, and to support a wider set of serialization scenarios, I propose that Orleans should be able to create objects by invoking a parameterized constructor. This allows classes to regain their original state after having been round-tripped through the serializer, without developers having to introduce specialized callback methods.&lt;/p&gt;
&lt;p&gt;As part of the changes for #7937, Orleans now has an &lt;code&gt;OrleansConstructorAttribute&lt;/code&gt;. This could be used to mark a specific constructor for Orleans to use during deserialization, allowing users to explicitly opt-in to the feature. Cyclic references would then not be supported, and it would be the users responsibility to ensure that objects don't reference themselves (directly or indirectly). Given the rarity of cyclic references and the opt-in nature of the feature I do not think that this is a concern.&lt;/p&gt;
&lt;p&gt;To implement the feature, rules must exist on how parameters can map to fields and properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;calculate the canonical name by stripping leading underscores and lowercasing the first remaining character&lt;/li&gt;
&lt;li&gt;canonical names and types must match (except for parameters, which are allowed to be same-type-but-nullable)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Additionally, these would be the rules governing how objects are created:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;types with a single &lt;code&gt;OrleansConstructorAttribute&lt;/code&gt; annotation opt-in to parameterized construction, all other types use the existing logic (the analyzer should be updated to warn if there are multiple annotated constructors for a single type)&lt;/li&gt;
&lt;li&gt;any fields or properties not mapped to a ctor parameter would be initialized as usual (after object creation)&lt;/li&gt;
&lt;li&gt;missing values for a required ctor parameter would result in a deserialization failure (exception), unless the parameter has been given a default value&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If accepted, I volunteer to implement the required changes.&lt;/p&gt;
</description>
      <pubDate>Fri, 02 Sep 2022 19:57:43 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7962</guid>
      <link>https://github.com/dotnet/orleans/issues/7962</link>
      <title>Issue: [3.x] Serializer classes are not generated for types only referenced in inherited interfaces - @niblak</title>
      <description>&lt;p&gt;Given the following class hierarchy:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        public class TypeInParentInterface
        {

        }

        public class TypeInGrain
        {

        }

        public interface IParentInterface
        {
            public Task&amp;lt;TypeInParentInterface&amp;gt; One();
        }

        public interface IMyGrainWithInterfaceInheritance : IGrainWithGuidKey, IParentInterface
        {
            public Task&amp;lt;TypeInGrain&amp;gt; Two();
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A serializer class will currently only be generated for &lt;code&gt;TypeInGrain&lt;/code&gt;. &lt;code&gt;SymbolExtensions.GetInstanceMembers&lt;/code&gt; needs to be changed to consider types in inherited interfaces as well.&lt;/p&gt;
&lt;p&gt;I will submit a PR for this.&lt;/p&gt;
</description>
      <pubDate>Fri, 02 Sep 2022 02:13:03 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7961</guid>
      <link>https://github.com/dotnet/orleans/issues/7961</link>
      <title>Issue: Timeout error from silo when number of connections goes beyond 10k - @kishor-raskar</title>
      <description>&lt;p&gt;Hi Team, we are having following services:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Microsoft SingalR Hub service.&lt;/li&gt;
&lt;li&gt;Orleans as a backplane for SignalR (created the Silo host and registered signalR hub as silo client)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We have deployed these apps on EKS and have assigned 6 Core CPU and 6G memory to Silo Pod, hub has been provisioned moderately with 2core CPU and 2GB memory, we are trying performance tests and trying to figure out the optimum load single silo can handle.&lt;/p&gt;
&lt;p&gt;With this setup in place, we are facing time-out errors from the Silo side while making the ClientGrain connections, when our singalR connection count goes beyond 10k, We observed the latency on Silo dashboard it gets increased very massively after a certain number of connections.&lt;/p&gt;
&lt;p&gt;Can you guys help me to come up with the optimum number of connections a single silo should support and optimum resources like memory and CPU we should assign to Silo pod.&lt;/p&gt;
&lt;p&gt;Note: I have used two silo hosts to share the load with LOAD_SHEDDING_LIMIT set to 30.&lt;/p&gt;
&lt;p&gt;Your help will be highly appreciated as we are kind of stuck till 10k connections currently.&lt;/p&gt;
</description>
      <pubDate>Thu, 01 Sep 2022 10:16:14 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7957</guid>
      <link>https://github.com/dotnet/orleans/issues/7957</link>
      <title>Issue: Cannot transform data from IEnumerable between two assemblies - @NikitaPozharskyi</title>
      <description>&lt;p&gt;Hi! I have two services and one of them take a Grain which was specified in another service. So after i take it we execute method which shold return class object with fields smth like that&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Person{
public string Name{get;set;}
public IEnumerable&amp;lt;Children&amp;gt; ChildrenList {get;set;}
. . .
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After method execution we handle the break point in another service where we calculating that data in IEnumerable (we have local function that makes some calculations). Like this&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class PeopleHandler{
public async Task ExecuteAsync(personName){
var name = _context.People.First(_ =&amp;gt; _.Name == personName);
var children = GetChildren(name);

return new Person(name, childrens)

IEnumerable GetChildren (string personName){
var children =  _context.GetChildren.Select(. . .) . . .

 return children;
 }
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Attention. We don't use ToList() at the end. We handle it like that to another service. So we execute method&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public async Task GetPersonInformation (personName){
  var peopleHandler = _client.GetGrain&amp;lt;PeopleHandler&amp;gt;(grainId);
  var person = await peopleHandler.ExecuteAsync(personName);

 var childrens = person.ChildrenList.ToList() // or any other method that makes programm to calculate data 'First() etc.'
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After that we got an exception about NullReferenceException in Children. We can't calculate data between services. I decided to make it ToList() before we return data from the ExecuteAsync method and i got a result but what was the reason of that? If it wasn't a local function i understand that private functions can be not visible in first assembly but this is local function and we need to know everything about public method including it's private methods inside of it. So i changed return Type of GetChildren and got my result. What do you think?&lt;/p&gt;
</description>
      <pubDate>Wed, 31 Aug 2022 10:55:00 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7956</guid>
      <link>https://github.com/dotnet/orleans/issues/7956</link>
      <title>Issue: Add TryRegisterReminder - @j0nimost</title>
      <description>&lt;p&gt;From the documentation of &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/orleans.grain.registerorupdatereminder?view=orleans-3.0"&gt;RegisterOrUpdateReminder&lt;/a&gt; is says :
&lt;em&gt;If an existing reminder with the same name already exists, that reminder will be overwritten with this new reminder. Reminders will always be received by one activation of this grain, even if multiple activations exist for this grain.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This is a limiting since for my instances I could be updating existing reminders. It would be nice if we had a &lt;strong&gt;TryRegisterReminder&lt;/strong&gt; which returns a boolean based on whether;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a reminder was created -&amp;gt; true&lt;/li&gt;
&lt;li&gt;if there's an existing reminder -&amp;gt; false.&lt;/li&gt;
&lt;/ul&gt;
</description>
      <pubDate>Wed, 31 Aug 2022 09:14:34 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7953</guid>
      <link>https://github.com/dotnet/orleans/issues/7953</link>
      <title>Issue: [Docs] Out of date: `IGrainObserver` methods can return `Task`, etc, not only `void` - @ReubenBond</title>
      <description>&lt;p&gt;We need to update docs to reflect the fact that the restriction that &lt;code&gt;IGrainObserver&lt;/code&gt; methods can only return &lt;code&gt;void&lt;/code&gt; has been lifted&lt;/p&gt;
</description>
      <pubDate>Mon, 29 Aug 2022 19:52:44 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7952</guid>
      <link>https://github.com/dotnet/orleans/issues/7952</link>
      <title>Issue: Add .net 6 support for Microsoft.Orleans.OrleansCodeGenerator.Build - @abuzaforfagun</title>
      <description>&lt;p&gt;&lt;code&gt;.net 6&lt;/code&gt; is the current LTS version of .NET.
As a product of .NET, I think all of the orlens components should support &lt;code&gt;.net 6&lt;/code&gt;. But &lt;code&gt;Microsoft.Orleans.OrleansCodeGenerator.Build&lt;/code&gt; does not support &lt;code&gt;.net 6&lt;/code&gt;.&lt;/p&gt;
</description>
      <pubDate>Mon, 29 Aug 2022 03:35:50 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7941</guid>
      <link>https://github.com/dotnet/orleans/issues/7941</link>
      <title>Issue: No codec found for OrleansAWSUtils.Streams.SQSBatchContainer - @tanordheim</title>
      <description>&lt;p&gt;When trying to add SQS streaming to an Orleans 4.0 preview 2 project I get the following error on startup:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Orleans.Providers.Streams.Common.PersistentStreamProvider-test-stream failed to start due to errors at stage ApplicationServices (10000)
      Orleans.Serialization.CodecNotFoundException: Could not find a codec for type OrleansAWSUtils.Streams.SQSBatchContainer.
         at Orleans.Serialization.Serializers.CodecProvider.ThrowCodecNotFound[TField](Type fieldType) in /_/src/Orleans.Serialization/Serializers/CodecProvider.cs:line 913
         at Orleans.Serialization.Serializers.CodecProvider.GetCodec[TField]() in /_/src/Orleans.Serialization/Serializers/CodecProvider.cs:line 167
         at Orleans.Serialization.Serializer`1..ctor(ICodecProvider codecProvider, SerializerSessionPool sessionPool) in /_/src/Orleans.Serialization/Serializer.cs:line 497
         at Orleans.Serialization.Serializer.GetSerializer[T]() in /_/src/Orleans.Serialization/Serializer.cs:line 38
         at OrleansAWSUtils.Streams.SQSAdapterFactory..ctor(String name, SqsOptions sqsOptions, HashRingStreamQueueMapperOptions queueMapperOptions, SimpleQueueCacheOptions cacheOptions, IOptions`1 clusterOptions, Serializer serializer, ILoggerFactory loggerFactory) in /_/src/AWS/Orleans.Streaming.SQS/Streams/SQSAdapterFactory.cs:line 43
         at System.RuntimeMethodHandle.InvokeMethod(Object target, Span`1&amp;amp; arguments, Signature sig, Boolean constructor, Boolean wrapExceptions)
         at System.Reflection.RuntimeConstructorInfo.Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
         at Microsoft.Extensions.DependencyInjection.ActivatorUtilities.ConstructorMatcher.CreateInstance(IServiceProvider provider)
         at Microsoft.Extensions.DependencyInjection.ActivatorUtilities.CreateInstance(IServiceProvider provider, Type instanceType, Object[] parameters)
         at Microsoft.Extensions.DependencyInjection.ActivatorUtilities.CreateInstance[T](IServiceProvider provider, Object[] parameters)
         at OrleansAWSUtils.Streams.SQSAdapterFactory.Create(IServiceProvider services, String name) in /_/src/AWS/Orleans.Streaming.SQS/Streams/SQSAdapterFactory.cs:line 95
         at Orleans.Runtime.KeyedSingletonService`2.&amp;lt;&amp;gt;c__DisplayClass4_0.&amp;lt;.ctor&amp;gt;b__0() in /_/src/Orleans.Core/Utils/KeyedService.cs:line 83
         at System.Lazy`1.ViaFactory(LazyThreadSafetyMode mode)
         at System.Lazy`1.ExecutionAndPublication(LazyHelper executionAndPublication, Boolean useDefaultConstructor)
         at System.Lazy`1.CreateValue()
         at System.Lazy`1.get_Value()
         at Orleans.Runtime.KeyedSingletonService`2.GetService(IServiceProvider services) in /_/src/Orleans.Core/Utils/KeyedService.cs:line 87
         at Orleans.Runtime.KeyedServiceCollection`2.GetService(IServiceProvider services, TKey key)
         at Orleans.Runtime.KeyedServiceCollectionExtensions.GetServiceByKey[TKey,TService](IServiceProvider services, TKey key) in /_/src/Orleans.Core.Abstractions/Utils/IKeyedServiceCollection.cs:line 78
         at Orleans.Runtime.KeyedServiceCollectionExtensions.GetRequiredServiceByKey[TKey,TService](IServiceProvider services, TKey key) in /_/src/Orleans.Core.Abstractions/Utils/IKeyedServiceCollection.cs:line 100
         at Orleans.Runtime.KeyedServiceCollectionExtensions.GetRequiredServiceByName[TService](IServiceProvider services, String name) in /_/src/Orleans.Core.Abstractions/Utils/IKeyedServiceCollection.cs:line 138
         at Orleans.Providers.Streams.Common.PersistentStreamProvider.Init(CancellationToken token) in /_/src/Orleans.Streaming/PersistentStreams/PersistentStreamProvider.cs:line 106
         at Orleans.Runtime.SiloLifecycleSubject.MonitoredObserver.OnStart(CancellationToken ct) in /_/src/Orleans.Runtime/Lifecycle/SiloLifecycleSubject.cs:line 134
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This can easily be reproduced by this code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var app = Host.CreateDefaultBuilder(args)
    .UseOrleans((_, siloBuilder) =&amp;gt;
    {
        siloBuilder
            .UseLocalhostClustering()
            .AddMemoryGrainStorage(&amp;quot;PubSubStore&amp;quot;)
            .AddSqsStreams(&amp;quot;test-stream&amp;quot;, options =&amp;gt;
            {
                options.ConnectionString = &amp;quot;Service=http://localhost:9324/orleansstream&amp;quot;;
            })
            .Configure&amp;lt;ClusterOptions&amp;gt;(options =&amp;gt;
            {
                options.ClusterId = &amp;quot;test-cluster&amp;quot;;
                options.ServiceId = &amp;quot;test-service&amp;quot;;
            })
            .Configure&amp;lt;EndpointOptions&amp;gt;(options =&amp;gt;
            {
                var ipAddress = Dns.GetHostEntry(Dns.GetHostName())
                    .AddressList
                    .FirstOrDefault(a =&amp;gt; a.AddressFamily == AddressFamily.InterNetwork);
                if (ipAddress is null)
                    throw new Exception(&amp;quot;unable to find public ipv4 address&amp;quot;);
                options.AdvertisedIPAddress = ipAddress;
                options.SiloPort = 11111;
                options.GatewayPort = 30000;
            });
    })
    .Build();

await app.RunAsync();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Is something missing from the Microsoft.Orleans.Streaming.SQS NuGet package for this release?&lt;/p&gt;
</description>
      <pubDate>Mon, 22 Aug 2022 13:50:02 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7940</guid>
      <link>https://github.com/dotnet/orleans/issues/7940</link>
      <title>Issue: In the implementation class, connect to other servers and wait - @bouyeijiang</title>
      <description>&lt;p&gt;example code:&lt;/p&gt;
&lt;p&gt;public class GrainGdbQuery : Grain, IGrainGdbQuery
{
public GrainGdbQuery()
{ }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    public Task GdbQueryFromCluster(string version,string dataName,
        string dataType,string commandText)
    {
       var client = new ClientBuilder()
        .UseStaticClustering(ipandports.Select(x=&amp;gt;IPEndPoint.Parse(x)).ToArray())
        .Configure&amp;lt;ClusterOptions&amp;gt;(options =&amp;gt;
        {
            options.ClusterId = &amp;quot;dev&amp;quot;;
            options.ServiceId = &amp;quot;dev_s&amp;quot;;
        })
        .ConfigureApplicationParts(parts =&amp;gt; parts.AddApplicationPart(typeof(IGrainGdbQuery).Assembly))
        .Build();

        client.Connect(ReplayFilter).Result;// **always waiting**
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
</description>
      <pubDate>Mon, 22 Aug 2022 10:57:46 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7939</guid>
      <link>https://github.com/dotnet/orleans/issues/7939</link>
      <title>Issue: None of the assemblies added to ApplicationPartManager contain generated code - @bouyeijiang</title>
      <description>&lt;p&gt;client = new ClientBuilder()
.UseStaticClustering(ipandports.Select(x=&amp;gt;IPEndPoint.Parse(x)).ToArray())
.Configure&lt;ClusterOptions&gt;(options =&amp;gt;
{
options.ClusterId = &amp;quot;dev&amp;quot;;
options.ServiceId = &amp;quot;dev_s&amp;quot;;
})
.ConfigureApplicationParts(parts =&amp;gt; parts.AddApplicationPart(typeof(IGrainGdbQuery).Assembly))
.Build();&lt;/p&gt;
&lt;p&gt;catch exception:
Orleans.Runtime.OrleansConfigurationException:“None of the assemblies added to ApplicationPartManager contain generated code. Ensure that code generation has been executed for grain interface and class assemblies.”&lt;/p&gt;
</description>
      <pubDate>Mon, 22 Aug 2022 09:42:45 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7938</guid>
      <link>https://github.com/dotnet/orleans/issues/7938</link>
      <title>Issue: [3.x] Serializing large enumerables causes a stack overflow - @niblak</title>
      <description>&lt;p&gt;&lt;code&gt;SerializationManager.DeepCopierHelper&lt;/code&gt; uses recursion to serialize  elements in non-&lt;code&gt;Array&lt;/code&gt; enumerable types, which has the potential to create a stack overflow for large collections (&lt;code&gt;Newtonsoft.Json.Linq.JArray&lt;/code&gt; is what bit us in production).&lt;/p&gt;
&lt;p&gt;This looks unintentional since &lt;code&gt;Array&lt;/code&gt; is already special-cased in this method to deep copy iteratively.&lt;/p&gt;
&lt;p&gt;I've created a repro of the problem in my fork &lt;a href="https://github.com/niblak/orleans/commit/163419bdcbd687af6a39dd0ee6b8d100d7bb7847"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Note that I commented out a few &lt;code&gt;[Serializer]&lt;/code&gt; attributes for Newtonsoft types in the test assemblies, since these were picked up by the runtime from the codegen files and skipped the deep copy entirely, preventing it from reproing.&lt;/p&gt;
</description>
      <pubDate>Sun, 21 Aug 2022 23:28:07 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7937</guid>
      <link>https://github.com/dotnet/orleans/issues/7937</link>
      <title>Issue: Serialization: GenerateFieldIds does not work with immutable types - @mnmr</title>
      <description>&lt;p&gt;I have been unable to get Orleans to serialize objects, when GenerateFieldIds is enabled, without adding an accessible setter to all properties. Neither a private setter or init-only properties are enough.&lt;/p&gt;
&lt;p&gt;Somehow object construction must be different when GenerateFieldIds is enabled, because if I add explicit &lt;code&gt;[Id]&lt;/code&gt; annotations (and turn off GenerateFieldIds) then I do not need to have the setters.&lt;/p&gt;
&lt;p&gt;The ideal solution would be to treat properties that are initialized on the constructor as if they had a setter.&lt;/p&gt;
</description>
      <pubDate>Sun, 21 Aug 2022 11:52:24 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7936</guid>
      <link>https://github.com/dotnet/orleans/issues/7936</link>
      <title>Issue: Serialization: enabling GenerateFieldIds breaks empty record serialization - @mnmr</title>
      <description>&lt;p&gt;When enabling the GenerateFieldIds setting, Orleans fails to generate code for records that do not have any explicit &lt;code&gt;[Id]&lt;/code&gt; markings (like the &lt;code&gt;EmptyAbstractRecord&lt;/code&gt; in the unit tests project).&lt;/p&gt;
&lt;p&gt;Orleans should exclude the compiler-generated properties for record types to work around this issue.&lt;/p&gt;
</description>
      <pubDate>Sun, 21 Aug 2022 11:46:40 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7935</guid>
      <link>https://github.com/dotnet/orleans/issues/7935</link>
      <title>Issue: Poor discoverability and inconsistent naming of serialization attributes - @mnmr</title>
      <description>&lt;p&gt;I've been trying to use the Orleans serializer as a stand-alone library, and think that it'd be good for discoverability (and ease of use) if it were to only use project-owned attributes with consistent naming, such as &lt;code&gt;[OrleansSerializer]&lt;/code&gt;, &lt;code&gt;[OrleansIgnore]&lt;/code&gt;, &lt;code&gt;[OrleansConstructor]&lt;/code&gt;, &lt;code&gt;[OrleansId]&lt;/code&gt;, &lt;code&gt;[OrleansImmutable]&lt;/code&gt;, etc.&lt;/p&gt;
&lt;p&gt;Some attributes (e.g. &lt;code&gt;[NonSerialized]&lt;/code&gt;) are likely re-used for compatibility with &lt;code&gt;BinaryFormatter&lt;/code&gt;, but is this really desirable to have as the default? I would prefer to opt-in to this behavior by adding &lt;code&gt;BinaryFormatter&lt;/code&gt;-specific attributes, even if this means some annotations are duplicated. This would also provide a way to opt-out of using &lt;code&gt;BinaryFormatter&lt;/code&gt; altogether.&lt;/p&gt;
&lt;p&gt;I was also only able to discover &lt;code&gt;[ActivatorUtilitiesConstructor]&lt;/code&gt; by looking at the code, as it's not mentioned in any Orleans docs I could find.&lt;/p&gt;
&lt;p&gt;In summary, I think Orleans would benefit from internalizing attributes.&lt;/p&gt;
&lt;p&gt;This is related to #7872&lt;/p&gt;
</description>
      <pubDate>Sun, 21 Aug 2022 11:36:49 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7933</guid>
      <link>https://github.com/dotnet/orleans/issues/7933</link>
      <title>Issue: Consistent 'No target activation` errors when silo is dead - @benthepoet</title>
      <description>&lt;p&gt;We've recently encountered an issue where after deploying a new set of silos (5 total), we are consistently getting errors like these for a number of grain instances that keep failing to activate.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;No target activation S10.1.0.19:11111:398459896*grn/Salad.Services.Users.ProfileGrain/4077d9c3-0184-4c61-a594-5ec47606d7b6@67c74992 for response message: Transient Rejection (info: Target silo is known to be dead) Response S10.1.0.243:11111:398460762*grn/Salad.Services.Referrals.RefereeGrain/4077d9c3-0184-4c61-a594-5ec47606d7b6@cb7b748a-&amp;gt;S10.1.0.19:11111:398459896*grn/Salad.Services.Users.ProfileGrain/4077d9c3-0184-4c61-a594-5ec47606d7b6@67c74992 #22935009
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We're using the AWS clustering provider currently.
I've checked the membership table and the target silo that appears to be in question &lt;code&gt;10.1.0.243&lt;/code&gt; is marked dead (&lt;code&gt;SiloStatus = 6&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Any idea why this would be happening even though the target silo is dead?&lt;/p&gt;
</description>
      <pubDate>Thu, 18 Aug 2022 13:43:43 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7932</guid>
      <link>https://github.com/dotnet/orleans/issues/7932</link>
      <title>Issue: Stream is not getting re-activated after Silo restarts - @kishor-raskar</title>
      <description>&lt;p&gt;Hi Team,
We have two services:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Orleans Silo host.&lt;/li&gt;
&lt;li&gt;Microsoft SignalR web Application (which will be client server for Silohost).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Orleans Silo is acting as backplane for our SignalR application, when we connects some of the clients to SingalR Hub, this connections is getting registered with Silo as steam (I may not aware of underlying behavior of it).&lt;/p&gt;
&lt;p&gt;So messages are getting delivered from one SingalR client to another and everything works fine unless silo gets restarted, after that we see server clients are getting reconnected, but actual signalr clients no longer receives any messages. We are getting following warning:
*&lt;em&gt;[WRN] Consumer ObserverId:&lt;em&gt;cli/5df83a99/ad57ac09-fd68-4867-8a81-ca151af2e6fd on stream SERVERS_STREAM-cbd1b061-1708-4fde-ac99-8bbc14b3e713-ORLEANS_SIGNALR_STREAM_PROVIDER is no longer active - permanently removing Consumer.&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Can you please help me with this?
Note: I am trying this on my local machine, hence I could have only single Silo instance running in local clustering, if you could help me to set multi-silo cluster either locally or on environment it would be great help (if multi-silo avoids this kind of issues)&lt;/p&gt;
</description>
      <pubDate>Thu, 18 Aug 2022 11:28:49 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7931</guid>
      <link>https://github.com/dotnet/orleans/issues/7931</link>
      <title>Issue: How implement IRepository for getting list of grains for show in Grid? - @P9avel</title>
      <description>&lt;p&gt;I am want to list of grains in GUI, I am need to implement IRepository and GetList method with skip and take parameters. How to get grains state without loading grain in silo?&lt;/p&gt;
</description>
      <pubDate>Wed, 17 Aug 2022 06:07:40 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7924</guid>
      <link>https://github.com/dotnet/orleans/issues/7924</link>
      <title>Issue: Applying [Id(x)] to a property init method results in NRE when resolving Serializer&lt;T&gt;. Could source generators possibly flag this as an error? - @MarkNickeson</title>
      <description>&lt;p&gt;Repro with workaround:  &lt;a href="https://gist.github.com/MarkNickeson/c21d86a77b891b28b2ba44c77a6eb324"&gt;https://gist.github.com/MarkNickeson/c21d86a77b891b28b2ba44c77a6eb324&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Given the record definition below, the [Id(0)] attribute on Bar is basically invalid because init can only be invoked during construction. However, a developer does not receive feedback until they attempt to resolve the serializer at which point a NRE is thrown.&lt;/p&gt;
&lt;p&gt;One workaround is to move the [Id(0)] to the backing field and use SerializationCallbacks to perform necessary logic after fields/properties have been deserialized.&lt;/p&gt;
&lt;p&gt;Ideally it would be nice if the source generators could flag the error while they are processing the source tree.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt; [GenerateSerializer]
    public record RecordWithSetterMethod
    {
        string _bar;

        [Id(0)]
        public string Bar
        {
            get =&amp;gt; _bar;
            init
            {
                _bar = value; DoMore(_bar);
            }
        }

        public RecordWithSetterMethod(string bar)
        {
            _bar = bar;
            DoMore(_bar);
        }

        void DoMore(string bar)
        {
            // do more!
        }
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Tue, 16 Aug 2022 16:31:51 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7923</guid>
      <link>https://github.com/dotnet/orleans/issues/7923</link>
      <title>Issue: Empty base record results in incorrect deserialization behavior - @MarkNickeson</title>
      <description>&lt;p&gt;A sample xunit repro can be found here: &lt;a href="https://gist.github.com/MarkNickeson/a0af303b8cecb579c272f74187653eb8"&gt;https://gist.github.com/MarkNickeson/a0af303b8cecb579c272f74187653eb8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Essentially, a base record that is empty such as:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[GenerateSerializer]
public abstract record ImAbstractBaseFail
{       
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;results in derived records failing to deserialize correctly, e.g.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[GenerateSerializer]
public record ImDerivedFail : ImAbstractBaseFail
{
    [Id(0)]
    public string Foo { get; init; }

    public ImDerivedFail(string foo)
    {
        Foo = foo;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Serializing ImDerivedFail(&amp;quot;XXXXXXX&amp;quot;) makes is clear that the data for ImDerivedFail.Foo is serialized because the UTF8 encoded string appears as a sequence of 0x58 bytes.&lt;/p&gt;
&lt;p&gt;However, after deserializing to a new instance Foo is null.&lt;/p&gt;
&lt;p&gt;As well, a record hierarchy such as FooBase(with data) -&amp;gt; Intermediate(without data) -&amp;gt; Concrete(with data) demonstrates that the empty intermediate type affects derived types, BUT not its base type. Example: &lt;a href="https://gist.github.com/MarkNickeson/157b7c17d9e0d0157afbd74763082bf3"&gt;https://gist.github.com/MarkNickeson/157b7c17d9e0d0157afbd74763082bf3&lt;/a&gt;&lt;/p&gt;
</description>
      <pubDate>Tue, 16 Aug 2022 15:30:51 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7922</guid>
      <link>https://github.com/dotnet/orleans/issues/7922</link>
      <title>Issue: System.InvalidOperationException: OutgoingCallInvoker.Invoke() received an invalid call. - @canitez</title>
      <description>&lt;p&gt;Hi, although not constantly, we sometimes get this error. Is the problem caused by startup settings, what could be the reason?&lt;/p&gt;
&lt;p&gt;` public void ConfigureCustomServices(IServiceCollection services)
{
var retryAsyncPolicy = Policy
.Handle&lt;Exception&gt;(e =&amp;gt; !(e is BusinessException))
.RetryAsync();&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        services.AddSingleton(typeof(IHttpContextAccessor), new HttpContextAccessor());
        services.AddTransient(typeof(IUserPrincipalContextFactory), typeof(ClientUserPrincipalContextFactory));

        services.AddTransient(typeof(IClientBuilder), aspnetProvider =&amp;gt;
        {
            IClientBuilder clientBuilder = new ClientBuilder()
                .Configure&amp;lt;ClusterOptions&amp;gt;(options =&amp;gt;
                {
                    options.ClusterId = orleansSettings.ClusterId;
                    options.ServiceId = orleansSettings.ServiceId;
                })
                .ConfigureServices(sc =&amp;gt;
                {
                    sc.AddSingleton(typeof(ILoggerFactory), orleansProvider =&amp;gt; aspnetProvider.GetRequiredService&amp;lt;ILoggerFactory&amp;gt;());
                    sc.AddSingleton(typeof(IMetrics), orleansProvider =&amp;gt; aspnetProvider.GetRequiredService&amp;lt;IMetrics&amp;gt;());
                })
                .ConfigureApplicationParts(parts =&amp;gt; parts.AddApplicationPart(typeof(CommonTypesPointer).Assembly).WithReferences())
                .AddClusterConnectionLostHandler((object sender, EventArgs e) =&amp;gt;
                {
                    var metrics = aspnetProvider.GetRequiredService&amp;lt;IMetrics&amp;gt;();
                    metrics.Measure.Counter.Increment(MetricsRegistry.ClusterConnectionLostCounter);

                    Log.Fatal(&amp;quot;Cluster connection lost&amp;quot;);
                })
                .AddOutgoingGrainCallFilter&amp;lt;MetricCallFilter&amp;gt;()
                .AddOutgoingGrainCallFilter(async context =&amp;gt;
                {
                    HttpContextAccessor accessor = new HttpContextAccessor();

                    if (accessor.HttpContext != null)
                    {
                        RequestContext.Set(&amp;quot;Language&amp;quot;, new ClientLanguageProvider(accessor).Language);
                        RequestContext.Set(&amp;quot;UserPrincipal&amp;quot;, new UserPrincipal(accessor.HttpContext.User));
                        RequestContext.Set(&amp;quot;CorrelationId&amp;quot;, new LogCorrelationIdGeneratorForHttp(accessor).GetCorrelationId());
                        RequestContext.Set(&amp;quot;RequestPath&amp;quot;, accessor.HttpContext.Request.Path.ToString());
                        RequestContext.Set(&amp;quot;ClientMachineName&amp;quot;, Environment.MachineName);
                    }

                    await retryAsyncPolicy.ExecuteAsync(() =&amp;gt; context.Invoke());
                });

            if (environment.IsEnvironment(&amp;quot;LocalDevelopment&amp;quot;))
            {
                clientBuilder.UseLocalhostClustering();
            }
            else if (orleansSettings.UseStaticGatewayList)
            {
                // Uri format should be like: gwy.tcp://127.0.0.1:1/0
                string[] uris = orleansSettings.ClusterIPList;

                clientBuilder.UseStaticClustering((StaticGatewayListProviderOptions o) =&amp;gt;
                {
                    foreach (var uriStr in uris)
                    {
                        Uri uri = new Uri(uriStr);
                        if (uri.HostNameType == UriHostNameType.Dns)
                        {
                            System.Net.IPHostEntry host = System.Net.Dns.GetHostEntry(uri.Host);
                            var uriBuilder = new UriBuilder(uri);
                            uriBuilder.Host = host.AddressList.First().ToString();
                            uri = uriBuilder.Uri;
                        }

                        o.Gateways.Add(uri);
                    }
                });
            }
            else
            {
                clientBuilder
                    .UseAdoNetClustering(options =&amp;gt;
                    {
                        var connectionStringBuilder = new NpgsqlConnectionStringBuilder(configuration.GetConnectionString(&amp;quot;SiloConnection&amp;quot;));
                        connectionStringBuilder.Password = orleansSettings.SiloDatabasePassword;
                        options.ConnectionString = connectionStringBuilder.ConnectionString;
                        options.Invariant = orleansSettings.AdoProvider;
                    });
            }

            return clientBuilder;
        });
    }`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;System.InvalidOperationException: OutgoingCallInvoker.Invoke() received an invalid call.&lt;/p&gt;
&lt;p&gt;at Orleans.Runtime.OutgoingCallInvoker.ThrowInvalidCall()&lt;/p&gt;
&lt;p&gt;at Orleans.Runtime.OutgoingCallInvoker.Invoke()&lt;/p&gt;
&lt;p&gt;at Polly.RetrySyntaxAsync.&amp;lt;&amp;gt;c__DisplayClass9_1.&amp;lt;&lt;RetryAsync&gt;b__1&amp;gt;d.MoveNext()&lt;/p&gt;
&lt;p&gt;--- End of stack trace from previous location where exception was thrown ---&lt;/p&gt;
&lt;p&gt;at Polly.Retry.RetryEngine.ImplementationAsync[TResult](Func&lt;code&gt;3 action, Context context, CancellationToken cancellationToken, IEnumerable&lt;/code&gt;1 shouldRetryExceptionPredicates, IEnumerable&lt;code&gt;1 shouldRetryResultPredicates, Func&lt;/code&gt;1 policyStateFactory, Boolean continueOnCapturedContext)&lt;/p&gt;
&lt;p&gt;at Polly.Retry.RetryEngine.ImplementationAsync[TResult](Func&lt;code&gt;3 action, Context context, CancellationToken cancellationToken, IEnumerable&lt;/code&gt;1 shouldRetryExceptionPredicates, IEnumerable&lt;code&gt;1 shouldRetryResultPredicates, Func&lt;/code&gt;1 policyStateFactory, Boolean continueOnCapturedContext)&lt;/p&gt;
&lt;p&gt;at Polly.Policy.ExecuteAsyncInternal(Func`3 action, Context context, CancellationToken cancellationToken, Boolean continueOnCapturedContext)&lt;/p&gt;
&lt;p&gt;at Polly.Policy.ExecuteAsync(Func`3 action, Context context, CancellationToken cancellationToken, Boolean continueOnCapturedContext)&lt;/p&gt;
</description>
      <pubDate>Tue, 16 Aug 2022 13:15:38 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7921</guid>
      <link>https://github.com/dotnet/orleans/issues/7921</link>
      <title>Issue: [4.0] Inheritance hierarchy deserialization fails after update to 4.0-preview2 - @christiansparre</title>
      <description>&lt;p&gt;We have a few records that are part of an inheritance hierarchy. Ex. Foo &amp;gt; Bar &amp;gt; Baz. After updating from 4.0-preview1 to 4.0-preview2 this fails with &amp;quot;Insufficient data present in buffer.&amp;quot; exceptions - seems to be the &lt;code&gt;IsSpanInput&lt;/code&gt; check in https://github.com/dotnet/orleans/blob/main/src/Orleans.Serialization/Buffers/Reader.cs#L550&lt;/p&gt;
&lt;p&gt;I have made a simple repro here that shows the problem: https://github.com/christiansparre/OrleansSerializationIssueRepro20220816&lt;/p&gt;
&lt;p&gt;The records are as follows&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[GenerateSerializer]
public record Foo([property: Id(1)] string Message) : Bar
{
    public override string Type =&amp;gt; &amp;quot;Foo&amp;quot;;
}

[GenerateSerializer]
public abstract record Bar : Baz;

[GenerateSerializer]
public abstract record Baz
{
    public abstract string Type { get; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Are we missing something in the [GenerateSerializer],[Id] annotations?&lt;/p&gt;
&lt;p&gt;It seems that if &lt;code&gt;Bar&lt;/code&gt; or &lt;code&gt;Baz&lt;/code&gt; have properties in the primary constructor it works, but I have not explored all combinations.&lt;/p&gt;
&lt;p&gt;The &amp;quot;empty&amp;quot; base types are a bit of an edge case maybe, in our solution the inheritance hierarchy is a part of some &amp;quot;generic&amp;quot; settings code. We have not finalized the design yet so might work around this problem if there is not another workaround.&lt;/p&gt;
</description>
      <pubDate>Tue, 16 Aug 2022 12:43:59 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7916</guid>
      <link>https://github.com/dotnet/orleans/issues/7916</link>
      <title>Issue: [v3.6.4]  Source link Authentication failed. - @ElanHasson</title>
      <description>&lt;p&gt;It is trying to auth against dev.azure.com.&lt;/p&gt;
&lt;img width="749" alt="image" src="https://user-images.githubusercontent.com/234704/184190000-8332b7a8-764d-43e6-ab65-f35342aa3e48.png"&gt;
</description>
      <pubDate>Thu, 11 Aug 2022 16:52:14 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7913</guid>
      <link>https://github.com/dotnet/orleans/issues/7913</link>
      <title>Issue: Microsoft.Orleans   Version="3.6.2".  I use Redis as a cluster component, but an error occurred when starting one of the Silo hosts - @wz172</title>
      <description>&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46833139/184060989-f946df94-bb34-44e1-884f-a26de8586b28.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;The error appears to be that the other host in the cluster is not connected because the other host is not started.But this causes my current silo to not boot up completely and eventually an error?Here are other Settings that can be set in SILo without all booting, without affecting my current task of booting the host?&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/46833139/184061241-e10ba56d-9bae-4e51-a705-c12ae2d0d78b.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;However, currently there is no Silo node information, and Redis only caches the Silo host information of the last cluster&lt;/p&gt;
</description>
      <pubDate>Thu, 11 Aug 2022 03:41:49 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7908</guid>
      <link>https://github.com/dotnet/orleans/issues/7908</link>
      <title>Issue: Errors in generated code for records deserializing  - @AndrewP-GH</title>
      <description>&lt;p&gt;I try to use recors in grain interface and get build errors&lt;/p&gt;
&lt;p&gt;Code example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;using Orleans;
using Orleans.Concurrency;

public static class InvoiceCommands
{
    [Immutable]
    public sealed record Fill(
        string CommandId,
        int Currency,
        decimal Cost,
        DateTime CreatedAt,
        InvoiceClient Client);

    [Immutable]
    public sealed record InvoiceClient(
        string ClientId,
        string Name);

    [Immutable]
    public sealed record SetPaid(string CommandId);
}


public interface IInvoice : IGrainWithStringKey
{
    Task Fill(InvoiceCommands.Fill command);
    Task SetPaid(InvoiceCommands.SetPaid command);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Errors:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  OrleansRecords.orleans.g.cs(258, 13): [CS8852] Init-only property or indexer 'InvoiceCommands.SetPaid.CommandId' can only be assigned in an object initializer, or on 'this' or 'base' in an instance constructor or an 'init' accessor.
  OrleansRecords.orleans.g.cs(226, 13): [CS8852] Init-only property or indexer 'InvoiceCommands.InvoiceClient.ClientId' can only be assigned in an object initializer, or on 'this' or 'base' in an instance constructor or an 'init' accessor.
  OrleansRecords.orleans.g.cs(227, 13): [CS8852] Init-only property or indexer 'InvoiceCommands.InvoiceClient.Name' can only be assigned in an object initializer, or on 'this' or 'base' in an instance constructor or an 'init' accessor.
  OrleansRecords.orleans.g.cs(190, 13): [CS8852] Init-only property or indexer 'InvoiceCommands.Fill.Client' can only be assigned in an object initializer, or on 'this' or 'base' in an instance constructor or an 'init' accessor.
  OrleansRecords.orleans.g.cs(191, 13): [CS8852] Init-only property or indexer 'InvoiceCommands.Fill.CommandId' can only be assigned in an object initializer, or on 'this' or 'base' in an instance constructor or an 'init' accessor.
  OrleansRecords.orleans.g.cs(192, 13): [CS8852] Init-only property or indexer 'InvoiceCommands.Fill.Cost' can only be assigned in an object initializer, or on 'this' or 'base' in an instance constructor or an 'init' accessor.
  OrleansRecords.orleans.g.cs(193, 13): [CS8852] Init-only property or indexer 'InvoiceCommands.Fill.CreatedAt' can only be assigned in an object initializer, or on 'this' or 'base' in an instance constructor or an 'init' accessor.
  OrleansRecords.orleans.g.cs(194, 13): [CS8852] Init-only property or indexer 'InvoiceCommands.Fill.Currency' can only be assigned in an object initializer, or on 'this' or 'base' in an instance constructor or an 'init' accessor.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Csproj:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;Project Sdk=&amp;quot;Microsoft.NET.Sdk&amp;quot;&amp;gt;

    &amp;lt;PropertyGroup&amp;gt;
        &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt;
        &amp;lt;TargetFramework&amp;gt;net6.0&amp;lt;/TargetFramework&amp;gt;
        &amp;lt;ImplicitUsings&amp;gt;enable&amp;lt;/ImplicitUsings&amp;gt;
        &amp;lt;Nullable&amp;gt;enable&amp;lt;/Nullable&amp;gt;
    &amp;lt;/PropertyGroup&amp;gt;

    &amp;lt;ItemGroup&amp;gt;
      &amp;lt;PackageReference Include=&amp;quot;Microsoft.Orleans.Core&amp;quot; Version=&amp;quot;3.6.3&amp;quot; /&amp;gt;
      &amp;lt;PackageReference Include=&amp;quot;Microsoft.Orleans.OrleansCodeGenerator.Build&amp;quot; Version=&amp;quot;3.6.3&amp;quot;&amp;gt;
        &amp;lt;PrivateAssets&amp;gt;all&amp;lt;/PrivateAssets&amp;gt;
        &amp;lt;IncludeAssets&amp;gt;runtime; build; native; contentfiles; analyzers; buildtransitive&amp;lt;/IncludeAssets&amp;gt;
      &amp;lt;/PackageReference&amp;gt;
    &amp;lt;/ItemGroup&amp;gt;

&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Is this a bug or I have wrong project configuration?&lt;/p&gt;
</description>
      <pubDate>Wed, 10 Aug 2022 09:21:36 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7907</guid>
      <link>https://github.com/dotnet/orleans/issues/7907</link>
      <title>Issue: Generator 'OrleansSerializationSourceGenerator' failed to generate source, 4.0.0-preview2  - @COCPORN</title>
      <description>&lt;p&gt;I think I've managed to upgrade relatively well to preview2, but I am getting this error message still: &lt;code&gt;CS8785    Generator 'OrleansSerializationSourceGenerator' failed to generate source. It will not contribute to the output and compilation errors may occur as a result. Exception was of type 'InvalidCastException' with message 'Unable to cast object of type 'Microsoft.CodeAnalysis.CSharp.Symbols.PublicModel.TypeParameterSymbol' to type 'Microsoft.CodeAnalysis.INamedTypeSymbol'.' &lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This manifests for me as Orleans picking up the grain interfaces, but not their implementation, it seems. I think they are related.&lt;/p&gt;
&lt;p&gt;It logs like this at runtime, which is similar to what I assume the error message would be if the implementation was just missing:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.ArgumentException: Could not find an implementation for interface HelloWorld.IHelloWorldService
   at Orleans.GrainInterfaceTypeToGrainTypeResolver.GetGrainType(GrainInterfaceType interfaceType) in /_/src/Orleans.Core/Core/GrainInterfaceTypeToGrainTypeResolver.cs:line 149
   at Orleans.GrainFactory.GetGrain(Type interfaceType, IdSpan grainKey, String grainClassNamePrefix) in /_/src/Orleans.Core/Core/GrainFactory.cs:line 214
   at Orleans.GrainFactory.GetGrain(Type grainInterfaceType, Int64 key) in /_/src/Orleans.Core/Core/GrainFactory.cs:line 162
   at Orleans.Runtime.InternalClusterClient.GetGrain(Type grainInterfaceType, Int64 grainPrimaryKey) in /_/src/Orleans.Runtime/Core/InternalClusterClient.cs:line 129
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It seems to me to start occurring with preview2 as the same (or at least similar code) worked fine with preview1, but I am not 100% sure exactly when it started happening.&lt;/p&gt;
&lt;p&gt;Also, this could obviously be related to me not correctly doing the upgrade from preview1 to preview2.&lt;/p&gt;
</description>
      <pubDate>Wed, 10 Aug 2022 06:50:25 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7904</guid>
      <link>https://github.com/dotnet/orleans/issues/7904</link>
      <title>Issue: [Question] Grain activation is jumping between silos during the cluster update - @MaximTkachenko</title>
      <description>&lt;p&gt;I host Orleans cluster in AWS ECS Fargate. I faced the strange behavior:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I update the cluster;&lt;/li&gt;
&lt;li&gt;when silo A with grain B is deactivated this grain is activated on one of the new silos;&lt;/li&gt;
&lt;li&gt;after a few minutes the new silo deactivates grain B (I don't know why) and then the grain is activated on another silo; sometimes I have 2 or 3 such hops between new silos.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;What is the possible reason for such behavior? As I understand when the grain is activated it should work on the home silo.&lt;/p&gt;
</description>
      <pubDate>Tue, 09 Aug 2022 13:54:36 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7902</guid>
      <link>https://github.com/dotnet/orleans/issues/7902</link>
      <title>Issue: Cannot override directory entry pointing to a dead Silo - @benjaminpetit</title>
      <description>&lt;p&gt;When doing a lookup, the distributed grain directory ignores entries pointing to a dead silo but doesn't allow overriding them when creating a new grain activation.&lt;/p&gt;
</description>
      <pubDate>Tue, 09 Aug 2022 13:46:30 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7900</guid>
      <link>https://github.com/dotnet/orleans/issues/7900</link>
      <title>Issue: Orleans for primary/stand-by servers? - @logicaloud</title>
      <description>&lt;p&gt;I'd like to scale an application covering anything from 2 servers to many servers and Orleans seems like a good fit for the &amp;quot;many servers&amp;quot; scenario.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;For just two servers&lt;/strong&gt;: Emphasis would be on redundancy, not load-balancing, and ideally all grains would be created on the primary server with the stand-by server taking over only in case of a failure of the primary server. Any shutdown or crash of the stand-by server should not affect the primary server at all, that is, there should neither be an increase in load nor any delays or temporary loss of functionality.&lt;/p&gt;
&lt;p&gt;Can this currently be achieved with Orleans?&lt;/p&gt;
&lt;p&gt;With my limited knowledge, it looks like the hash-based grain placement could be used to place grains onto the primary server only, is that correct?&lt;/p&gt;
&lt;p&gt;After a primary server failure the stand-by server should take over. This would be, as far as I know, already the standard Orleans behavior.&lt;/p&gt;
&lt;p&gt;Once the primary server is back up, all grains should move from the stand-by server back to the primary server. It looks like, shutting down the stand-by server with the primary server running would move grains back to the primary server although it would not be completely seamless and is not ideal. Is there a better way?&lt;/p&gt;
&lt;p&gt;I'm aware of proposal #7692, which is great, and this would presumably allow moving grains from unwanted placement on the stand-by server back to the primary server. I haven't figured out how the stand-by server can detect that the primary server is back online within Orleans but that should be a relatively minor issue, i.e. it could be one notification away.&lt;/p&gt;
&lt;p&gt;If the the redundant primary/stand-by use case is not yet covered, could this be considered in the future?&lt;/p&gt;
</description>
      <pubDate>Sun, 07 Aug 2022 21:54:29 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7899</guid>
      <link>https://github.com/dotnet/orleans/issues/7899</link>
      <title>Issue: Need help with system design 1-M implementation for Client and Order classes - @P9avel</title>
      <description>&lt;p&gt;Hi, i am need to have acess to Client with orders and each Order separate. I am think need 2 classes for grains.&lt;/p&gt;
&lt;p&gt;public record Order(int Number, IList&lt;Product&gt; Products);&lt;/p&gt;
&lt;p&gt;public interface IClient
{
IList&lt;Order&gt; GetOrders();
}&lt;/p&gt;
&lt;p&gt;public interface IOrder
{
IOrder GetOrder();
}
And now syncronization states in 2 grains for each Order changes. Can you to show beatifull design? How correct implement so tasks?&lt;/p&gt;
</description>
      <pubDate>Sat, 06 Aug 2022 19:32:28 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7898</guid>
      <link>https://github.com/dotnet/orleans/issues/7898</link>
      <title>Issue: [question]a little confusion about ProcessSiloAddEvent(SiloAddress addedSilo) ' in GrainDirectoryHandoffManager.cs - @yulei1990</title>
      <description>&lt;p&gt;in this function 'internal void ProcessSiloAddEvent(SiloAddress addedSilo) ' of GrainDirectoryHandoffManager.cs
`
// Reset our follower list to take the changes into account
ResetFollowers();&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;            // check if this is one of our successors (i.e., if I should hold this silo's copy)
            // (if yes, adjust local and/or copied directory partitions by splitting them between old successors and the new one)
            // NOTE: We need to move part of our local directory to the new silo if it is an immediate successor.
            List&amp;lt;SiloAddress&amp;gt; successors = localDirectory.FindSuccessors(localDirectory.MyAddress, 1);
            if (!successors.Contains(addedSilo))
            {
                if (logger.IsEnabled(LogLevel.Debug)) logger.Debug($&amp;quot;{addedSilo} is not one of my successors.&amp;quot;);
                return;
            }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;`
List&lt;SiloAddress&gt; successors = localDirectory.FindSuccessors(localDirectory.MyAddress, 1);&lt;/p&gt;
&lt;p&gt;when the above code executes,  only the immediate successor of myAddress is returned.
so, if the immediate silo is not &amp;quot;addedSilo&amp;quot;, then the following if statement will always be true and the function return immediately. why only one successor is needed here.
i get stuck in there why only pass &amp;quot;1&amp;quot; to the FindSuccessors function.&lt;/p&gt;
&lt;p&gt;looking forward to your reply&lt;/p&gt;
</description>
      <pubDate>Sat, 06 Aug 2022 07:41:14 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7897</guid>
      <link>https://github.com/dotnet/orleans/issues/7897</link>
      <title>Issue: Is it safe to call HttpContext inside the grain? - @MaximTkachenko</title>
      <description>&lt;p&gt;I have an http endpoint which puts id into the current httpcontext and then call the grain:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HttpContext.Items[&amp;quot;id&amp;quot;] = Guid.NewGuid().ToString();
var d = await _cluster.GetGrain&amp;lt;IHttpGrain&amp;gt;(1).GetId();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The grain returns this id from the current httpcontext (&lt;strong&gt;this grain activation and httprequest are on the same server&lt;/strong&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class HttpGrain : Grain, IHttpGrain
{
    private readonly IHttpContextAccessor _http;    
    public HttpGrain(IHttpContextAccessor http)
    {
        _http = http;
    }
    
    public async Task&amp;lt;string&amp;gt; GetId()
    {
        return Task.FromResult((string)_http.HttpContext.Items[&amp;quot;id&amp;quot;]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I call the endpoint like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var http = new HttpClient();
var tasks = new List&amp;lt;Task&amp;lt;string&amp;gt;&amp;gt;
{
    http.GetStringAsync(&amp;quot;http://localhost:8080/test&amp;quot;),
    http.GetStringAsync(&amp;quot;http://localhost:8080/test&amp;quot;),
    http.GetStringAsync(&amp;quot;http://localhost:8080/test&amp;quot;),
    http.GetStringAsync(&amp;quot;http://localhost:8080/test&amp;quot;),
    http.GetStringAsync(&amp;quot;http://localhost:8080/test&amp;quot;),
    http.GetStringAsync(&amp;quot;http://localhost:8080/test&amp;quot;),
    http.GetStringAsync(&amp;quot;http://localhost:8080/test&amp;quot;),
    http.GetStringAsync(&amp;quot;http://localhost:8080/test&amp;quot;),
};
await Task.WhenAll(tasks);
foreach (var result in tasks.Select(x =&amp;gt; x.Result))
{
    Console.WriteLine(result);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;055fb4a5-3151-4028-ae1d-a486cc93171f
055fb4a5-3151-4028-ae1d-a486cc93171f
055fb4a5-3151-4028-ae1d-a486cc93171f
055fb4a5-3151-4028-ae1d-a486cc93171f
055fb4a5-3151-4028-ae1d-a486cc93171f
abb34f03-bd83-487c-8892-5577d3139878
abb34f03-bd83-487c-8892-5577d3139878
abb34f03-bd83-487c-8892-5577d3139878
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I suppose it's because Orleans has its own &lt;code&gt;TaskScheduler&lt;/code&gt; and puts tasks into the queue and that's why in some cases it's mixing, i.e. &lt;code&gt;AsyncLocal&lt;/code&gt; used in &lt;code&gt;IHttpContextAccessor&lt;/code&gt; works incorrectly in that case. Could you explain this behavior with more details? Is a calling &lt;code&gt;IHttpContextAccessor&lt;/code&gt; inside the grain a bad idea or it's possible to make it work?&lt;/p&gt;
</description>
      <pubDate>Fri, 05 Aug 2022 08:35:22 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7892</guid>
      <link>https://github.com/dotnet/orleans/issues/7892</link>
      <title>Issue: How to config Orleans in Worker? - @P9avel</title>
      <description>&lt;p&gt;Hi, i am want to have Options and config Orleans. I am want to do like this&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;var builder = Host.CreateDefaultBuilder(args);

builder.ConfigureServices((hostContext, services) =&amp;gt;
{
    var orleansSection = hostContext.Configuration.GetSection(OrleansConfiguration.SectionName);
    var orleansConfig = orleansSection.Get&amp;lt;OrleansConfiguration&amp;gt;();
    services.Configure&amp;lt;OrleansConfiguration&amp;gt;(orleans =&amp;gt; orleansSection.Bind(orleans));

    services.AddSingleton(orleansConfig);

    hostContext.UseOrleans(siloBuilder =&amp;gt;
    {
        

        siloBuilder.UseLocalhostClustering(siloPort, 30000, new IPEndPoint(IPAddress.Loopback, 11111))
            .Configure&amp;lt;ClusterOptions&amp;gt;(opts =&amp;gt;
            {
                opts.ClusterId = orleansConfig.ClusterId;
                opts.ServiceId = orleansConfig.ServiceId;
            })
            ;
    });

});
   
IHost host = builder.Build();

await host.RunAsync();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;How correct to call UseOrleans here?&lt;/p&gt;
</description>
      <pubDate>Tue, 02 Aug 2022 07:30:39 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7891</guid>
      <link>https://github.com/dotnet/orleans/issues/7891</link>
      <title>Issue: Slow performance on UseLocalhostClustering - @P9avel</title>
      <description>&lt;p&gt;I am user WebApi application on Net 6 and Co-hosting so&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;public static IHostBuilder UseOrleansDefaults(this IHostBuilder host, string clusterId, string serviceId, bool useDashboard, int siloPort)
    {
        host.UseOrleans(siloBuilder =&amp;gt;
        {
            if (useDashboard)
                siloBuilder.UseDashboard(options =&amp;gt; { });

            siloBuilder.UseLocalhostClustering(siloPort, 30000, new IPEndPoint(IPAddress.Loopback, 11111))
                .Configure&amp;lt;ClusterOptions&amp;gt;(opts =&amp;gt;
                {
                    opts.ClusterId = clusterId;
                    opts.ServiceId = serviceId;
                })
                .Configure&amp;lt;EndpointOptions&amp;gt;(opts =&amp;gt;
                {
                   // opts.AdvertisedIPAddress = IPAddress.Loopback;
                });
        });
        return host;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I am created simple grain&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;public interface IRobotMarketplace: IGrainWithStringKey
{
    Task&amp;lt;string&amp;gt; GetKeyValue();
}

public class RobotMarketplace: Grain, IRobotMarketplace
{
    private readonly IReadOnlyList&amp;lt;Robot&amp;gt; Empty = new List&amp;lt;Robot&amp;gt;();

    private readonly ILogger&amp;lt;RobotMarketplace&amp;gt; _logger;

    public RobotMarketplace(ILogger&amp;lt;RobotMarketplace&amp;gt; logger)
    {
        _logger = logger;
    }

    public Task&amp;lt;string&amp;gt; GetKeyValue()
    {
        return Task.FromResult(this.GetPrimaryKeyString());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And i am created 1000 Grains and try read 1000 grains,&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt; [HttpGet(&amp;quot;testcreate1000&amp;quot;)]
    public async Task&amp;lt;IActionResult&amp;gt; TestCreate1000(CancellationToken cancellationToken)
    {
        var count = 1_000;

        guids.Clear();

        var sw = new Stopwatch();
        sw.Start();

        for (int i = 1; i &amp;lt;= count; i++)
        {
            var guid = Guid.NewGuid();
            guids.Add(guid);
            var testGrain = _clusterClient.GetGrain&amp;lt;IRobotMarketplace&amp;gt;(guid.ToString());

            var res = new
            {
                Key = await testGrain.GetKeyValue(),
            };
        }

        sw.Stop();
       

        return Ok($&amp;quot;Created {count} objects in {sw.ElapsedMilliseconds} msec&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This method takes 3,8 seconds. For reading i am use&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt; [HttpGet(&amp;quot;testread1000&amp;quot;)]
    public async Task&amp;lt;IActionResult&amp;gt; TestRead1000(CancellationToken cancellationToken)
    {
        var count = 1_000;

        var sw = new Stopwatch();
        sw.Start();

        foreach (var guid in guids)
        {
            var testGrain = _clusterClient.GetGrain&amp;lt;IRobotMarketplace&amp;gt;(guid.ToString());

           var res = new
                {
                    Key = await testGrain.GetKeyValue()
                };
        }

        sw.Stop();
       

        return Ok($&amp;quot;Read {count} objects {sw.ElapsedMilliseconds} in msec&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This method takes 300millisec.   Why so slowlly?
&lt;img src="https://user-images.githubusercontent.com/95086762/182167071-728e4e35-59cf-4a2d-9f27-536daed278a7.png" alt="image" /&gt;&lt;/p&gt;
</description>
      <pubDate>Mon, 01 Aug 2022 14:11:42 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/orleans/issues/7888</guid>
      <link>https://github.com/dotnet/orleans/issues/7888</link>
      <title>Issue: Calling ReadStateAsync() not working when called directly - @dejay166</title>
      <description>&lt;p&gt;I am trying to implement a way of getting the Grain In-Memory state to be updated with the latest persisted state.  The reason for this is that I want a way of correcting issues in the store directly(dynamo db) without having to wait for the grain to de activate and re activate again.&lt;/p&gt;
&lt;p&gt;Looking at the the documentation here https://docs.microsoft.com/en-us/dotnet/orleans/grains/grain-persistence/
I should be able to call ReadStateAsync() so that the state is updated but this does not seem to work.&lt;/p&gt;
&lt;p&gt;I know the ReadStateAsync Method works generally because I have no issues loading grains.&lt;/p&gt;
&lt;p&gt;Here is the code that I am calling&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        public async Task RefreshState()
        {
            try
            {
                await Persistence.ReadStateAsync();
            }
            catch (Exception e)
            {
                throw;
            }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I get no exception from this and the state is not updated. I am using Orleans 3.6.2.&lt;/p&gt;
&lt;p&gt;Repro Steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Have a grain state loaded into memory.&lt;/li&gt;
&lt;li&gt;Edit the state in the persistence store (for me this is DynamoDb)&lt;/li&gt;
&lt;li&gt;Programatically call the ReadStateAsync() method&lt;/li&gt;
&lt;li&gt;Check that the state has been updated to reflect the change made in the store&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If you need any other details, please let me know.&lt;/p&gt;
</description>
      <pubDate>Fri, 29 Jul 2022 14:56:32 Z</pubDate>
    </item>
  </channel>
</rss>