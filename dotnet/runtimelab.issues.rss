<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>dotnet/runtimelab Issues</title>
    <description>Issues from https://github.com/dotnet/runtimelab, generated by https://github.com/meziantou/IssuesToRss/</description>
    <managingEditor>meziantousite@outlook.com</managingEditor>
    <ttl>60</ttl>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1992</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1992</link>
      <title>Issue: [NativeAOT-LLVM, WASM] Disable Reflection, IL scanner, RuntimeError: memory access out of bounds - @Kanawanagasaki</title>
      <description>&lt;p&gt;Hi, I was experimenting with compiling dotnet console application to WebAssembly. When disable reflection by adding &lt;code&gt;&amp;lt;IlcDisableReflection&amp;gt;true&amp;lt;/IlcDisableReflection&amp;gt;&lt;/code&gt; in .csproj i got &lt;code&gt;ILCompiler.ScannerFailedException&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ILCompiler.ScannerFailedException: VTable of type 'System.Runtime.InteropServices.DllImportSearchPath' not computed by the IL scanner. You can work around by running the compilation with scanner disabled.
     at ILCompiler.ILScanResults.ScannedVTableProvider.GetSlice(TypeDesc type)
     at System.Collections.Concurrent.ConcurrentDictionary`2.GetOrAdd(TKey key, Func`2 valueFactory)
     at ILCompiler.DependencyAnalysis.ConstructedEETypeNode.ComputeNonRelocationBasedDependencies(NodeFactory factory)
     at ILCompiler.DependencyAnalysis.ObjectNode.GetStaticDependencies(NodeFactory factory)
     at ILCompiler.DependencyAnalysisFramework.DependencyAnalyzer`2.GetStaticDependenciesImpl(DependencyNodeCore`1 node)
     at ILCompiler.DependencyAnalysisFramework.DependencyAnalyzer`2.GetStaticDependencies(DependencyNodeCore`1 node)
     at ILCompiler.DependencyAnalysisFramework.DependencyAnalyzer`2.ProcessMarkStack()
     at ILCompiler.DependencyAnalysisFramework.DependencyAnalyzer`2.ComputeMarkedNodes()
     at ILCompiler.LLVMCodegenCompilation.CompileInternal(String outputFile, ObjectDumper dumper)
     at ILCompiler.Compilation.ILCompiler.ICompilation.Compile(String outputFile, ObjectDumper dumper)
     at ILCompiler.Program.Run(String[] args)
     at ILCompiler.Program.Main(String[] args)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The exception message prompts me to disable the scanner, but I don't know how.
While trying to add various properties to the .csproj, I found that with  &lt;code&gt;&amp;lt;InvariantGlobalization&amp;gt;true&amp;lt;/InvariantGlobalization&amp;gt;&lt;/code&gt; property console application would compile successfully. But this time after i run it with node or in browser it will throw &lt;code&gt;RuntimeError: memory access out of bounds&lt;/code&gt; Exception:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RuntimeError: memory access out of bounds
    at __GenericLookupFromType_S_P_CoreLib_System_Collections_Generic_Dictionary_2&amp;lt;System___Canon__System___Canon&amp;gt;_TypeHandle_TKey_System___Canon (wasm://wasm/00d14eda:wasm-function[546]:0x66411)
    at S_P_CoreLib_System_Collections_Generic_Dictionary_2&amp;lt;System___Canon__System___Canon&amp;gt;___ctor_2 (wasm://wasm/00d14eda:wasm-function[542]:0x65e6b)
    at S_P_CoreLib_System_Collections_Generic_Dictionary_2&amp;lt;System___Canon__System___Canon&amp;gt;___ctor (wasm://wasm/00d14eda:wasm-function[1873]:0x136a15)
    at S_P_CoreLib_System_AppContext__SetData (wasm://wasm/00d14eda:wasm-function[285]:0x30ac7)
    at Internal_CompilerGenerated__Module___SetAppContextSwitches (wasm://wasm/00d14eda:wasm-function[1555]:0x12739c)
    at StartupCodeMain (wasm://wasm/00d14eda:wasm-function[159]:0x11d8c)
    at __managed__Main (wasm://wasm/00d14eda:wasm-function[1503]:0x124425)
    at main (wasm://wasm/00d14eda:wasm-function[4036]:0x1c7350)
    at C:\Users\Kanawanagasaki\Desktop\NativeAOTLLVMTest\bin\Debug\net7.0\browser-wasm\native\NativeAOTLLVMTest.js:977:22
    at callMain (C:\Users\Kanawanagasaki\Desktop\NativeAOTLLVMTest\bin\Debug\net7.0\browser-wasm\native\NativeAOTLLVMTest.js:5253:15)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It would be very handy if the console application ran without reflection, because it drastically reduces the size of the .wasm file from 18MB to 3.5MB.&lt;/p&gt;
&lt;h3&gt;Steps to reproduce:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;mkdir NativeAOTLLVMTest&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd NativeAOTLLVMTest&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dotnet new console&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dotnet new nugetconfig&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;in nuget.config add&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;add key=&amp;quot;dotnet-experimental&amp;quot; value=&amp;quot;https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-experimental/nuget/v3/index.json&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="6"&gt;
&lt;li&gt;in NativeAOTLLVMTest.csproj add&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;ItemGroup&amp;gt;
  &amp;lt;PackageReference Include=&amp;quot;Microsoft.DotNet.ILCompiler.LLVM; runtime.win-x64.Microsoft.DotNet.ILCompiler.LLVM&amp;quot; Version=&amp;quot;7.0.0-*&amp;quot; /&amp;gt;
&amp;lt;/ItemGroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="7"&gt;
&lt;li&gt;in NativeAOTLLVMTest.csproj add&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;IlcDisableReflection&amp;gt;true&amp;lt;/IlcDisableReflection&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="8"&gt;
&lt;li&gt;&lt;code&gt;dotnet publish -r browser-wasm -c Debug /p:TargetArchitecture=wasm /p:PlatformTarget=AnyCPU /p:MSBuildEnableWorkloadResolver=false --self-contained&lt;/code&gt;
&lt;em&gt;Native code generator will fail with &lt;code&gt;ILCompiler.ScannerFailedException:&lt;/code&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;in NativeAOTLLVMTest.csproj add&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;InvariantGlobalization&amp;gt;true&amp;lt;/InvariantGlobalization&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="10"&gt;
&lt;li&gt;&lt;code&gt;dotnet publish -r browser-wasm -c Debug /p:TargetArchitecture=wasm /p:PlatformTarget=AnyCPU /p:MSBuildEnableWorkloadResolver=false --self-contained&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd .\bin\Debug\net7.0\browser-wasm\native&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node .\NativeAOTLLVMTest.js&lt;/code&gt;
&lt;em&gt;node.js will throw &lt;code&gt;RuntimeError: memory access out of bounds&lt;/code&gt; exception&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      <pubDate>Wed, 14 Sep 2022 16:14:08 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1990</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1990</link>
      <title>Issue: Question: NativeAOT-LLVM: leave targets - @yowl</title>
      <description>&lt;p&gt;The IL backend has a bug that means the finally block is called twice if an exception occurs and is caught as in the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;private static void TryFinallyWithCatch()
{
    try
    {
        throw new Exception();
    }
    catch {}
    finally
    {
        finallyCalled++;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The IL for this looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;.method void TryFinallyWithCatch() cil managed
{
  // Code size: 31
  .maxstack 2

  .try IL_0001 to IL_0008 catch object handler IL_0008 to IL_000D
  .try IL_0001 to IL_000F finally handler IL_000F to IL_001E
  IL_0000:  nop
  IL_0001:  nop
  IL_0002:  newobj      instance void [System.Private.CoreLib]System.Exception::.ctor()
  IL_0007:  throw
  IL_0008:  pop
  IL_0009:  nop
  IL_000A:  nop
  IL_000B:  leave.s     IL_000D
  IL_000D:  leave.s     IL_001E
  IL_000F:  nop
  IL_0010:  ldsfld      int32 Program::finallyCalled
  IL_0015:  ldc.i4.1
  IL_0016:  add
  IL_0017:  stsfld      int32 Program::finallyCalled
  IL_001C:  nop
  IL_001D:  endfinally
  IL_001E:  ret
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The 2 leave targets&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  IL_000B:  leave.s     IL_000D
  IL_000D:  leave.s     IL_001E
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Is one for the try and one for the catch?.  If so why are they both in the catch handler region, after all it is &lt;code&gt;IL_0008 to IL_000D&lt;/code&gt;  ?&lt;/p&gt;
&lt;p&gt;Thanks&lt;/p&gt;
</description>
      <pubDate>Mon, 12 Sep 2022 01:31:29 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1987</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1987</link>
      <title>Issue: NativeAOT-LLVM: RyuJIT backend is using RhpAssignRef for addresses outside the heap - @yowl</title>
      <description>&lt;p&gt;Not looked closely at this, but at least for &lt;code&gt;S_P_TypeLoader_Internal_NativeFormat_NativeHashtable_Enumerator___ctor&lt;/code&gt; I noticed that the RyuJIT-&amp;gt;LLVM was using &lt;code&gt;RhpAssignRef &lt;/code&gt; to store a value at an address outside the heap&lt;/p&gt;
</description>
      <pubDate>Sat, 10 Sep 2022 21:47:11 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1986</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1986</link>
      <title>Issue: green-threads experiment branch mirroring broken due to credscan - @jkoritzinsky</title>
      <description>&lt;p&gt;https://dev.azure.com/dnceng/internal/_build/results?buildId=1987560&amp;amp;view=logs&amp;amp;j=a3453f18-ed27-56b8-78ee-81a7631275fb&amp;amp;t=1ec614b8-726e-5075-1cd1-dd16c6e99f29&amp;amp;l=78&lt;/p&gt;
</description>
      <pubDate>Thu, 08 Sep 2022 18:52:00 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1984</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1984</link>
      <title>Issue: NativeAOT-LLVM: heap corruption - @yowl</title>
      <description>&lt;p&gt;Hi,&lt;/p&gt;
&lt;p&gt;I wonder if anyone can look at this, and maybe give me some more ideas as I've been looking at it for quite a few hours without success, thanks.&lt;/p&gt;
&lt;p&gt;If I turn on the &lt;code&gt;HeapVerifyLevel&lt;/code&gt; setting in &lt;code&gt;gcconfig.h&lt;/code&gt; to 7 (i.e. all 3 flags), then I can make the verify_heap function fail in node's v8 with this code inserted into &lt;code&gt;HelloWasm.cs&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;Fails at the third GC.Collect.  Previous to this code, there has been a around a 100 other GC Collects, manual, and automatic that pass the verify checks.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GC.Collect();
PrintLine(&amp;quot;collect 4&amp;quot;);

GC.Collect();
var arrayType = GetArrayType();
PrintLine(&amp;quot;collect 4a&amp;quot;);
GC.Collect();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where &lt;code&gt;GetArrayType&lt;/code&gt; is&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private static Type GetArrayType()
{
    return typeof(object[]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Fails with (I have a printf(&amp;quot;garbage_collect&amp;quot;) in &lt;code&gt;garbage_collect&lt;/code&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;garbage_collect
collect 4
garbage_collect
collect 4a
garbage_collect
E:\GitHub\runtimelab\artifacts\tests\coreclr\Browser.wasm.Debug\nativeaot\SmokeTests\HelloWasm\HelloWasm\native\HelloWasm.js:386
      throw ex;
      ^

RuntimeError: unreachable
    at GCToOSInterface::DebugBreak() (wasm-function[21832]:0xf33c8b)
    at WKS::gc_heap::verify_heap(int) (wasm-function[21191]:0xeada88)
    at WKS::gc_heap::garbage_collect(int) (wasm-function[21108]:0xe7ad2a)
    at WKS::GCHeap::GarbageCollectGeneration(unsigned int, gc_reason) (wasm-function[21105]:0xe79ec3)
    at WKS::GCHeap::GarbageCollectTry(int, int, int) (wasm-function[21487]:0xf117ea)
    at WKS::GCHeap::GarbageCollect(int, bool, int) (wasm-function[21486]:0xf11494)
    at RhpCollect (wasm-function[20100]:0xe0ee7b)
    at S_P_CoreLib_System_Runtime_InternalCalls__RhpCollect (wasm-function[10626]:0x689ecf)
    at S_P_CoreLib_System_Runtime_InternalCalls__RhCollect (wasm-function[7478]:0x4dfc6f)
    at RhCollect (wasm-function[7477]:0x4dfc06)
    at S_P_CoreLib_System_GC__Collect_0 (wasm-function[8161]:0x54580a)
    at HelloWasm_Program__Main (wasm-function[8764]:0x5ab1e3)
    at HelloWasm__Module___MainMethodWrapper (wasm-function[10672]:0x68f395)
    at StartupCodeMain (wasm-function[10664]:0x68ecd7)
    at __managed__Main (wasm-function[20035]:0xe0c408)
    at main (wasm-function[21930]:0xf3b259)
    at E:\GitHub\runtimelab\artifacts\tests\coreclr\Browser.wasm.Debug\nativeaot\SmokeTests\HelloWasm\HelloWasm\native\HelloWasm.js:1747:22
    at callMain (E:\GitHub\runtimelab\artifacts\tests\coreclr\Browser.wasm.Debug\nativeaot\SmokeTests\HelloWasm\HelloWasm\native\HelloWasm.js:7933:15)
    at doRun (E:\GitHub\runtimelab\artifacts\tests\coreclr\Browser.wasm.Debug\nativeaot\SmokeTests\HelloWasm\HelloWasm\native\HelloWasm.js:7990:23)
    at run (E:\GitHub\runtimelab\artifacts\tests\coreclr\Browser.wasm.Debug\nativeaot\SmokeTests\HelloWasm\HelloWasm\native\HelloWasm.js:8005:5)
    at runCaller (E:\GitHub\runtimelab\artifacts\tests\coreclr\Browser.wasm.Debug\nativeaot\SmokeTests\HelloWasm\HelloWasm\native\HelloWasm.js:7911:19)
    at removeRunDependency (E:\GitHub\runtimelab\artifacts\tests\coreclr\Browser.wasm.Debug\nativeaot\SmokeTests\HelloWasm\HelloWasm\native\HelloWasm.js:1669:7)
    at receiveInstance (E:\GitHub\runtimelab\artifacts\tests\coreclr\Browser.wasm.Debug\nativeaot\SmokeTests\HelloWasm\HelloWasm\native\HelloWasm.js:1836:5)
    at receiveInstantiationResult (E:\GitHub\runtimelab\artifacts\tests\coreclr\Browser.wasm.Debug\nativeaot\SmokeTests\HelloWasm\HelloWasm\native\HelloWasm.js:1854:5)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If I change &lt;code&gt;GetArrayType&lt;/code&gt; to&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private static Type GetArrayType()
{
    return typeof(object);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then it passes this point.  So it looks like there might be something funny with &lt;code&gt;object[]&lt;/code&gt;, although it could be coincidence.  If I look at the method table for &lt;code&gt;object[]&lt;/code&gt; I see&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@&amp;quot;__MethodTable___Array&amp;lt;Object&amp;gt;___REALBASE&amp;quot; = global [26 x i32*] 
[
i32* inttoptr (i32 -12 to i32*), 
i32* inttoptr (i32 8 to i32*), 
i32* inttoptr (i32 1 to i32*), 
i32* inttoptr (i32 -1054736380 to i32*),
i32* inttoptr (i32 12 to i32*), 
i32* bitcast ([10 x i32*]* @__MethodTable_Object to i32*), 
i32* inttoptr (i32 720900 to i32*), 
i32* inttoptr (i32 -1744651090 to i32*), 
i32* bitcast (void (i8*, i8*)* @Object__ToString to i32*), 
i32* bitcast (i8 (i8*)* @Object__Equals to i32*),
i32* bitcast (i32 (i8*)* @Object__GetHashCode to i32*), 
i32* bitcast ([4 x i32*]* @&amp;quot;__GenericDict_S_P_CoreLib_System_Array_1&amp;lt;Object&amp;gt;&amp;quot; to i32*), 
i32* bitcast ([6 x i32*]* @__MethodTable_S_P_CoreLib_System_Collections_IEnumerable to i32*), 
i32* bitcast ([7 x i32*]* @__MethodTable_S_P_CoreLib_System_Collections_ICollection to i32*),
i32* bitcast ([8 x i32*]* @__MethodTable_S_P_CoreLib_System_Collections_IList to i32*), 
i32* bitcast ([6 x i32*]* @__MethodTable_S_P_CoreLib_System_Collections_IStructuralComparable to i32*),
i32* bitcast ([6 x i32*]* @__MethodTable_S_P_CoreLib_System_Collections_IStructuralEquatable to i32*), 
i32* bitcast ([6 x i32*]* @__MethodTable_S_P_CoreLib_System_ICloneable to i32*), 
i32* bitcast ([10 x i32*]* @&amp;quot;__MethodTable_S_P_CoreLib_System_Collections_Generic_IEnumerable_1&amp;lt;Object&amp;gt;&amp;quot; to i32*), 
i32* bitcast ([11 x i32*]* @&amp;quot;__MethodTable_S_P_CoreLib_System_Collections_Generic_ICollection_1&amp;lt;Object&amp;gt;&amp;quot; to i32*), 
i32* bitcast ([12 x i32*]* @&amp;quot;__MethodTable_S_P_CoreLib_System_Collections_Generic_IList_1&amp;lt;Object&amp;gt;&amp;quot; to i32*), 
i32* bitcast ([11 x i32*]* @&amp;quot;__MethodTable_S_P_CoreLib_System_Collections_Generic_IReadOnlyCollection_1&amp;lt;Object&amp;gt;&amp;quot; to i32*), 
i32* bitcast ([12 x i32*]* @&amp;quot;__MethodTable_S_P_CoreLib_System_Collections_Generic_IReadOnlyList_1&amp;lt;Object&amp;gt;&amp;quot; to i32*), 
i32* bitcast ([2 x i32*]* @__typemanager_indirection to i32*), i32* bitcast ([2 x i32*]* @&amp;quot;__optionalfields___MethodTable___Array&amp;lt;Object&amp;gt;&amp;quot; to i32*), 
i32* bitcast ([5 x i32*]* @&amp;quot;__SealedVTable___MethodTable___Array&amp;lt;System___Canon&amp;gt;&amp;quot; to i32*)
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Is there anything that sticks out there? I can only see that the last entry is a over &lt;code&gt;Canon&lt;/code&gt; where as the other generic entries are over &lt;code&gt;Object&lt;/code&gt;.  Is that ok?&lt;/p&gt;
</description>
      <pubDate>Thu, 08 Sep 2022 00:42:03 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1983</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1983</link>
      <title>Issue: NativeAOT-LLVM: support wasm exceptions - @yowl</title>
      <description>&lt;p&gt;We should support wasm-exceptions instead of exceptions through javascript (Emscripten exceptions).  This will allow exception support in non javascript hosts and should make the code a bit smaller.
This C++&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cpp"&gt;#include &amp;lt;stdio.h&amp;gt;

void throws()
{
  throw 1;
}

int main() {
  try {
    throws();
  } catch(...) {
    puts(&amp;quot;catch!&amp;quot;);
  }
  return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Goes to this LLVM as a guide&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-ll"&gt;
@_ZTIi = external constant ptr
@.str = private unnamed_addr constant [7 x i8] c&amp;quot;catch!\00&amp;quot;, align 1, !dbg !0

define dso_local void @_Z6throwsv() #0 !dbg !19 {
  %1 = call ptr @__cxa_allocate_exception(i64 4) #2, !dbg !23
  store i32 1, ptr %1, align 16, !dbg !23
  call void @__cxa_throw(ptr %1, ptr @_ZTIi, ptr null) #5, !dbg !23
  unreachable, !dbg !23
}

declare ptr @__cxa_allocate_exception(i64)

declare void @__cxa_throw(ptr, ptr, ptr)

define dso_local noundef i32 @main() #1 personality ptr @__gxx_wasm_personality_v0 !dbg !24 {
  %1 = alloca i32, align 4
  %2 = alloca ptr, align 8
  store i32 0, ptr %1, align 4
  invoke void @_Z6throwsv()
          to label %15 unwind label %3, !dbg !28

3:                                                ; preds = %0
  %4 = catchswitch within none [label %5] unwind to caller, !dbg !30

5:                                                ; preds = %3
  %6 = catchpad within %4 [ptr null], !dbg !30
  %7 = call ptr @llvm.wasm.get.exception(token %6), !dbg !30
  store ptr %7, ptr %2, align 8, !dbg !30
  %8 = call i32 @llvm.wasm.get.ehselector(token %6), !dbg !30
  br label %9, !dbg !30

9:                                                ; preds = %5
  %10 = load ptr, ptr %2, align 8, !dbg !30
  %11 = call ptr @__cxa_begin_catch(ptr %10) #2 [ &amp;quot;funclet&amp;quot;(token %6) ], !dbg !30
  %12 = invoke i32 @puts(ptr noundef @.str) [ &amp;quot;funclet&amp;quot;(token %6) ]
          to label %13 unwind label %16, !dbg !31

13:                                               ; preds = %9
  call void @__cxa_end_catch() [ &amp;quot;funclet&amp;quot;(token %6) ], !dbg !33
  br label %14, !dbg !33

14:                                               ; preds = %13, %15
  ret i32 0, !dbg !34

15:                                               ; preds = %0
  br label %14, !dbg !30

16:                                               ; preds = %9
  %17 = cleanuppad within %6 [], !dbg !33
  invoke void @__cxa_end_catch() [ &amp;quot;funclet&amp;quot;(token %17) ]
          to label %18 unwind label %19, !dbg !33

18:                                               ; preds = %16
  cleanupret from %17 unwind to caller, !dbg !33

19:                                               ; preds = %16
  %20 = cleanuppad within %17 [], !dbg !33
  call void @_ZSt9terminatev() #6 [ &amp;quot;funclet&amp;quot;(token %20) ], !dbg !33
  unreachable, !dbg !33
}

declare i32 @__gxx_wasm_personality_v0(...)
declare ptr @llvm.wasm.get.exception(token) #2
declare i32 @llvm.wasm.get.ehselector(token) #2
declare i32 @llvm.eh.typeid.for(ptr) #3
declare ptr @__cxa_begin_catch(ptr)
declare i32 @puts(ptr noundef) #4
declare void @__cxa_end_catch()
declare void @_ZSt9terminatev()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;https://godbolt.org/ can be used to try other C++ examples with the options &lt;code&gt;-S -emit-llvm -fwasm-exceptions&lt;/code&gt;&lt;/p&gt;
</description>
      <pubDate>Fri, 02 Sep 2022 20:25:52 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1970</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1970</link>
      <title>Issue: NativeAOT-LLVM: packages not building or publishing - @yowl</title>
      <description>&lt;p&gt;Hi,&lt;/p&gt;
&lt;p&gt;The last couple of merges have not produced new artifacts at&lt;/p&gt;
&lt;p&gt;https://dev.azure.com/dnceng/public/_artifacts/feed/dotnet-experimental&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/2720041/187204634-d99786a4-2f47-436e-9eba-9e5d185af11a.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;Can you see what the problem is?&lt;/p&gt;
</description>
      <pubDate>Mon, 29 Aug 2022 12:49:11 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1965</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1965</link>
      <title>Issue: [NativeAOT][Build Error]One or more errors occurred. - @submaie</title>
      <description>&lt;p&gt;Building Host  Operation System: Windows 11 Pro v 25182.1010
TargetFramework : net6.0-windows10.0.19041.0
TrimMode: copyused
Target runtime: win-x64&lt;/p&gt;
&lt;p&gt;Package r:eference : Avalonia.Desktop v 0.10.18
Package r:eference : Avalonia.AvaloniaEdit v 0.10.12.2
Package r:eference : Microsoft.Data.Sqlite v 6.0.8
Package r:eference : NPOI v 2.5.6
Package r:eference : System.Data.OleDb v6.0.0&lt;/p&gt;
&lt;p&gt;Error Msg:
2022/8/24 10:43:17
System.AggregateException: One or more errors occurred. ---&amp;gt; Microsoft.WebTools.Shared.Exceptions.WebToolsException: 发布时遇到错误。我们无法确定错误的原因。有关详细信息，请查看输出日志。
--- End of inner exception stack trace ---
---&amp;gt; (内部异常 #0) Microsoft.WebTools.Shared.Exceptions.WebToolsException: 发布时遇到错误。我们无法确定错误的原因。有关详细信息，请查看输出日志。&amp;lt;---&lt;/p&gt;
&lt;p&gt;Microsoft.WebTools.Shared.Exceptions.WebToolsException: 发布时遇到错误。我们无法确定错误的原因。有关详细信息，请查看输出日志。&lt;/p&gt;
&lt;p&gt;===================
One or more errors occurred. (Code generation failed for method '[Microsoft.Windows.SDK.NET]&lt;GuidPatcherImplementationDetails&gt;+&lt;SignatureCache&gt;Windows.Foundation.AsyncOperationWithProgressCompletedHandler&lt;code&gt;2&amp;lt;TResult,TProgress&amp;gt;&amp;lt;System.__Canon,int32&amp;gt;..cctor()') 1&amp;gt;System.AggregateException: One or more errors occurred. (Code generation failed for method '[Microsoft.Windows.SDK.NET]&amp;lt;GuidPatcherImplementationDetails&amp;gt;+&amp;lt;SignatureCache&amp;gt;Windows.Foundation.AsyncOperationWithProgressCompletedHandler&lt;/code&gt;2&amp;lt;TResult,TProgress&amp;gt;&amp;lt;System.__Canon,int32&amp;gt;..cctor()')
1&amp;gt; ---&amp;gt; ILCompiler.CodeGenerationFailedException: Code generation failed for method '[Microsoft.Windows.SDK.NET]&lt;GuidPatcherImplementationDetails&gt;+&lt;SignatureCache&gt;Windows.Foundation.AsyncOperationWithProgressCompletedHandler&lt;code&gt;2&amp;lt;TResult,TProgress&amp;gt;&amp;lt;System.__Canon,int32&amp;gt;..cctor()' 1&amp;gt; ---&amp;gt; System.InvalidOperationException: [Microsoft.Windows.SDK.NET]&amp;lt;GuidPatcherImplementationDetails&amp;gt;+&amp;lt;SignatureCache&amp;gt;Windows.Foundation.AsyncOperationWithProgressCompletedHandler&lt;/code&gt;2&amp;lt;TResult,TProgress&amp;gt;&amp;lt;System.__Canon,int32&amp;gt;: TypeHandle: [Microsoft.Windows.SDK.NET]&lt;GuidPatcherImplementationDetails&gt;+&lt;SignatureCache&gt;Windows.Foundation.AsyncOperationWithProgressCompletedHandler&lt;code&gt;2&amp;lt;TResult,TProgress&amp;gt;&amp;lt;!0_System.__Canon,int32&amp;gt; 1&amp;gt;   at ILCompiler.DependencyAnalysis.PrecomputedDictionaryLayoutNode.GetSlotForEntry(GenericLookupResult entry) in /_/src/coreclr/tools/aot/ILCompiler.Compiler/Compiler/DependencyAnalysis/DictionaryLayoutNode.cs:line 230 1&amp;gt;   at ILCompiler.Compilation.ComputeGenericLookup(MethodDesc contextMethod, ReadyToRunHelperId lookupKind, Object targetOfLookup) in /_/src/coreclr/tools/aot/ILCompiler.Compiler/Compiler/Compilation.cs:line 398 1&amp;gt;   at Internal.JitInterface.CorInfoImpl.ComputeLookup(CORINFO_RESOLVED_TOKEN&amp;amp; pResolvedToken, Object entity, ReadyToRunHelperId helperId, CORINFO_LOOKUP&amp;amp; lookup) in /_/src/coreclr/tools/aot/ILCompiler.RyuJit/JitInterface/CorInfoImpl.RyuJit.cs:line 257 1&amp;gt;   at Internal.JitInterface.CorInfoImpl.embedGenericHandle(CORINFO_RESOLVED_TOKEN&amp;amp; pResolvedToken, Boolean fEmbedParent, CORINFO_GENERICHANDLE_RESULT&amp;amp; pResult) in /_/src/coreclr/tools/aot/ILCompiler.RyuJit/JitInterface/CorInfoImpl.RyuJit.cs:line 1746 1&amp;gt;   at Internal.JitInterface.CorInfoImpl._embedGenericHandle(IntPtr thisHandle, IntPtr* ppException, CORINFO_RESOLVED_TOKEN* pResolvedToken, Byte fEmbedParent, CORINFO_GENERICHANDLE_RESULT* pResult) in /_/src/coreclr/tools/Common/JitInterface/CorInfoBase.cs:line 1987 1&amp;gt;   --- End of inner exception stack trace --- 1&amp;gt;   at Internal.JitInterface.CorInfoImpl.CompileMethodInternal(IMethodNode methodCodeNodeNeedingCode, MethodIL methodIL) in /_/src/coreclr/tools/Common/JitInterface/CorInfoImpl.cs:line 379 1&amp;gt;   at Internal.JitInterface.CorInfoImpl.CompileMethod(MethodCodeNode methodCodeNodeNeedingCode, MethodIL methodIL) in /_/src/coreclr/tools/aot/ILCompiler.RyuJit/JitInterface/CorInfoImpl.RyuJit.cs:line 63 1&amp;gt;   at ILCompiler.RyuJitCompilation.CompileSingleMethod(CorInfoImpl corInfo, MethodCodeNode methodCodeNodeNeedingCode) in /_/src/coreclr/tools/aot/ILCompiler.RyuJit/Compiler/RyuJitCompilation.cs:line 190 1&amp;gt;   at ILCompiler.RyuJitCompilation.CompileSingleMethod(MethodCodeNode methodCodeNodeNeedingCode) in /_/src/coreclr/tools/aot/ILCompiler.RyuJit/Compiler/RyuJitCompilation.cs:line 175 1&amp;gt;   at System.Threading.Tasks.Parallel.&amp;lt;&amp;gt;c__DisplayClass19_0&lt;/code&gt;1.&lt;ForWorker&gt;b__1(RangeWorker&amp;amp; currentWorker, Int32 timeout, Boolean&amp;amp; replicationDelegateYieldedBeforeCompletion)
1&amp;gt;--- End of stack trace from previous location ---
1&amp;gt;   at System.Threading.Tasks.Parallel.&amp;lt;&amp;gt;c__DisplayClass19_0&lt;code&gt;1.&amp;lt;ForWorker&amp;gt;b__1(RangeWorker&amp;amp; currentWorker, Int32 timeout, Boolean&amp;amp; replicationDelegateYieldedBeforeCompletion) 1&amp;gt;   at System.Threading.Tasks.TaskReplicator.Replica.Execute() 1&amp;gt;   --- End of inner exception stack trace --- 1&amp;gt;   at System.Threading.Tasks.TaskReplicator.Run[TState](ReplicatableUserAction&lt;/code&gt;1 action, ParallelOptions options, Boolean stopOnFirstFailure)
1&amp;gt;   at System.Threading.Tasks.Parallel.ForWorker[TLocal](Int32 fromInclusive, Int32 toExclusive, ParallelOptions parallelOptions, Action&lt;code&gt;1 body, Action&lt;/code&gt;2 bodyWithState, Func&lt;code&gt;4 bodyWithLocal, Func&lt;/code&gt;1 localInit, Action&lt;code&gt;1 localFinally) 1&amp;gt;--- End of stack trace from previous location --- 1&amp;gt;   at System.Threading.Tasks.Parallel.ForWorker[TLocal](Int32 fromInclusive, Int32 toExclusive, ParallelOptions parallelOptions, Action&lt;/code&gt;1 body, Action&lt;code&gt;2 bodyWithState, Func&lt;/code&gt;4 bodyWithLocal, Func&lt;code&gt;1 localInit, Action&lt;/code&gt;1 localFinally)
1&amp;gt;   at ILCompiler.RyuJitCompilation.CompileMultiThreaded(List&lt;code&gt;1 methodsToCompile) in /_/src/coreclr/tools/aot/ILCompiler.RyuJit/Compiler/RyuJitCompilation.cs:line 150 1&amp;gt;   at ILCompiler.RyuJitCompilation.ComputeDependencyNodeDependencies(List&lt;/code&gt;1 obj) in /&lt;em&gt;/src/coreclr/tools/aot/ILCompiler.RyuJit/Compiler/RyuJitCompilation.cs:line 140
1&amp;gt;   at ILCompiler.DependencyAnalysisFramework.DependencyAnalyzer`2.ComputeMarkedNodes() in /&lt;/em&gt;/src/coreclr/tools/aot/ILCompiler.DependencyAnalysisFramework/DependencyAnalyzer.cs:line 315
1&amp;gt;   at ILCompiler.RyuJitCompilation.CompileInternal(String outputFile, ObjectDumper dumper) in /&lt;em&gt;/src/coreclr/tools/aot/ILCompiler.RyuJit/Compiler/RyuJitCompilation.cs:line 88
1&amp;gt;   at ILCompiler.Compilation.ILCompiler.ICompilation.Compile(String outputFile, ObjectDumper dumper) in /&lt;/em&gt;/src/coreclr/tools/aot/ILCompiler.Compiler/Compiler/Compilation.cs:line 526
1&amp;gt;   at ILCompiler.Program.Run(String[] args) in /&lt;em&gt;/src/coreclr/tools/aot/ILCompiler/Program.cs:line 910
1&amp;gt;   at ILCompiler.Program.Main(String[] args) in /&lt;/em&gt;/src/coreclr/tools/aot/ILCompiler/Program.cs:line 1102
1&amp;gt;命令“&amp;quot;C:\Users\username.nuget\packages\runtime.win-x64.microsoft.dotnet.ilcompiler\7.0.0-preview.7.22375.6\tools\ilc&amp;quot; @&amp;quot;obj\x64\Release\net6.0-windows10.0.19041.0\win-x64\native\xReportGenerator.ilc.rsp&amp;quot;”已退出，代码为 1。
========== “生成”: 0 成功，0 失败，1 更新，0 已跳过 ==========
========== “发布”: 0 成功，1 失败，0已跳过 ==========&lt;/p&gt;
</description>
      <pubDate>Wed, 24 Aug 2022 03:04:58 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1964</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1964</link>
      <title>Issue: Question: NativeAOT-LLVM: strategy for PRs for RyuJIT with optimisations on - @yowl</title>
      <description>&lt;p&gt;I'd like to make a bit of progress on removing&lt;/p&gt;
&lt;p&gt;https://github.com/dotnet/runtimelab/blob/feature/NativeAOT-LLVM/src/coreclr/nativeaot/BuildIntegration/Microsoft.NETCore.Native.targets#L19-L20&lt;/p&gt;
&lt;p&gt;I've not really got any idea how many issues there are going to be.  The first ones have already been discussed in https://github.com/dotnet/runtimelab/issues/1859.  Would it be ok to create PRs of individual issues even though on their own they wont be able to compile with optimisations and the flag will have to still be &lt;code&gt;false&lt;/code&gt;.  It would keep the PRs small at the cost of potentially not being correct.&lt;/p&gt;
&lt;p&gt;Alternatively I can work through all the issues with a potentially large PR at the end that allows the tests to run.&lt;/p&gt;
&lt;p&gt;Any preference?&lt;/p&gt;
&lt;p&gt;@SingleAccretion @jkotas&lt;/p&gt;
</description>
      <pubDate>Tue, 23 Aug 2022 23:01:33 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1961</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1961</link>
      <title>Issue: [NativeAOT-LLVM]  [WASM] Cross-OS native compilation is not supported - @inkeliz</title>
      <description>&lt;p&gt;I'm trying to compile to WASM, using the following command line:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dotnet publish -r browser-wasm -c Debug /p:TargetArchitecture=wasm /p:PlatformTarget=AnyCPU /p:MSBuildEnableWorkloadResolver=false --self-containe
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, that returns:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\Users\lucas\.nuget\packages\microsoft.dotnet.ilcompiler\7.0.0-preview.7.22375.6\build\Microsoft.NETCore.Native.Publi
sh.targets(54,5): error : Cross-OS native compilation is not supported. [X:\karmem\benchmark\dotnetllvm\dotnetllvm.cspr
oj]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assuming that WASM is always cross-compile, how I can enable that?&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;CSPROJ:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;Project Sdk=&amp;quot;Microsoft.NET.Sdk&amp;quot;&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputType&amp;gt;Exe&amp;lt;/OutputType&amp;gt;
    &amp;lt;TargetFramework&amp;gt;net7.0&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;ImplicitUsings&amp;gt;enable&amp;lt;/ImplicitUsings&amp;gt;
    &amp;lt;Nullable&amp;gt;enable&amp;lt;/Nullable&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.DotNet.ILCompiler&amp;quot; Version=&amp;quot;7.0.0-*&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.DotNet.ILCompiler.LLVM&amp;quot;&amp;gt;
      &amp;lt;Version&amp;gt;7.0.0-*&amp;lt;/Version&amp;gt;
    &amp;lt;/PackageReference&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;runtime.win-x64.Microsoft.DotNet.ILCompiler.LLVM&amp;quot;&amp;gt;
      &amp;lt;Version&amp;gt;7.0.0-*&amp;lt;/Version&amp;gt;
    &amp;lt;/PackageReference&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;

&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;NuGet Config:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;configuration&amp;gt;
  &amp;lt;packageSources&amp;gt;
    &amp;lt;add key=&amp;quot;dotnet-experimental&amp;quot; value=&amp;quot;https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-experimental/nuget/v3/index.json&amp;quot; /&amp;gt;
    &amp;lt;add key=&amp;quot;nuget&amp;quot; value=&amp;quot;https://api.nuget.org/v3/index.json&amp;quot; /&amp;gt;
  &amp;lt;/packageSources&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;EMCC:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;emcc (Emscripten gcc/clang-like replacement + linker emulating GNU ld) 3.1.12 (38d1292ba2f5b4a7c8518931f5ae6f97ef0f6827)
clang version 15.0.0 (https://github.com/llvm/llvm-project d58cc0839ee5935e649dbbc18c898a8e4bcd6724)
Target: wasm32-unknown-emscripten
Thread model: posix
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Tue, 16 Aug 2022 14:34:08 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1959</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1959</link>
      <title>Issue: "Unresolved external symbol" when trying to P/Invoke exported function from separate library - @Michael-Kelley</title>
      <description>&lt;p&gt;I am currently writing a minimal CoreLib designed to be easily portable to use in my C# OS, and I would like to split platform-specific code into its own library.&lt;/p&gt;
&lt;p&gt;I have 3 projects:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bbCoreLib, a .Net 6.0 library which is the minimal CoreLib implementation&lt;/li&gt;
&lt;li&gt;bbCoreLib.Desktop, a .Net 6.0 library which contains desktop-specific code required to print to a console, get input, etc.&lt;/li&gt;
&lt;li&gt;Test.Desktop, a .Net 6.0 NativeAOT-compiled application which is currently just a simple test application that writes to the console.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In bbCoreLib, I have some code like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[DllImport(&amp;quot;*&amp;quot;)]
static extern unsafe void bbPrint(char* message, int length);

public static unsafe void WriteLine(string message) {
    fixed (char* pMessage = message) {
        bbPrint(pMessage, message.Length);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;bbPrint&lt;/code&gt; is implemented in bbCoreLib.Desktop like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[UnmanagedCallersOnly(EntryPoint = &amp;quot;bbPrint&amp;quot;)]
[RuntimeExport(&amp;quot;bbPrint&amp;quot;)]
public static unsafe void bbPrint(char* message, int length) {
    Win32.WriteConsoleW(Win32.GetStdHandle(-11), message, length, out int _, null);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Test.Desktop references both bbCoreLib and bbCoreLib.Desktop and contains no code besides this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;static int Main() {
    Console.WriteLine(&amp;quot;Hello from bbCoreLib Tests.Desktop!&amp;quot;);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The problem is that the ILC compiler can't seem to find bbPrint, resulting in this linker error: &lt;code&gt;Tests.Desktop.obj : error LNK2001: unresolved external symbol bbPrint [D:\Projects\VS2022\bbCoreLib\Tests.Desktop\Tests .Desktop.csproj]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Does NativeAOT support P/Invoke calls like this? If so, what am I doing wrong?&lt;/p&gt;
</description>
      <pubDate>Sun, 14 Aug 2022 19:42:22 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1955</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1955</link>
      <title>Issue: [Hot Cold Splitting] Implement validation mode in R2RDump - @cshung</title>
      <description>&lt;p&gt;It makes little sense to continue running the test if we knew the generated binary is wrong. To do that, we can do some basic checks.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[x] Check RuntimeFunctions are sorted by RVA&lt;/li&gt;
&lt;li&gt;[x] Check RuntimeFunctions intervals does not overlap&lt;/li&gt;
&lt;li&gt;[x] Check all RuntimeFunctions share the same PersonalityRoutine RVA&lt;/li&gt;
&lt;li&gt;[x] Integrate with the test infrastructure&lt;/li&gt;
&lt;/ul&gt;
</description>
      <pubDate>Sun, 07 Aug 2022 21:22:45 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1954</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1954</link>
      <title>Issue: [Hot Cold Splitting] Make hot cold splitting works with ReadyToRunFileLayoutOptimizer - @cshung</title>
      <description>&lt;p&gt;#1956 disabled the ReadyToRunFileLayoutOptimizer because it was causing issues. We need to figure out how to integrate these two features and re-enable the optimizer.&lt;/p&gt;
</description>
      <pubDate>Sun, 07 Aug 2022 21:18:43 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1950</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1950</link>
      <title>Issue: [Hot Cold Splitting] Test failures - @cshung</title>
      <description>&lt;h1&gt;Repro steps:&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Checkout my &lt;code&gt;private/hot-cold-devenv&lt;/code&gt; branch &lt;a href="https://github.com/cshung/runtimelab/tree/private/hot-cold-devenv"&gt;here&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Run these commands in a Command Prompt (not Powershell)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;bc.cmd
blo.cmd
bctg.cmd
bs.cmd
cr.cmd
cgt_on.cmd
rs.cmd
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Note, these scripts create environment variables, make sure you close the prompt when you are done with it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;After building once, you can run &lt;code&gt;rs.cmd&lt;/code&gt; again to reproduce the issue again without rebuilding, you can also run it with &lt;code&gt;ds.cmd&lt;/code&gt; to debug.&lt;/p&gt;
&lt;p&gt;Feel free to change &lt;code&gt;bs.cmd&lt;/code&gt;, &lt;code&gt;ds.cmd&lt;/code&gt; and &lt;code&gt;rs.cmd&lt;/code&gt; so that you can run another test.&lt;/p&gt;
</description>
      <pubDate>Wed, 03 Aug 2022 21:05:24 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1948</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1948</link>
      <title>Issue: NativeAOT not Stripping Symbols - @jamsoft</title>
      <description>&lt;p&gt;Going on from the last couple of comments on &lt;a href="https://github.com/dotnet/runtimelab/issues/597"&gt;this thread&lt;/a&gt;. I have been trying to get my application to strip the debug symbols.&lt;/p&gt;
&lt;p&gt;I've tried adding it to my csproj file in the main &lt;code&gt;PropertyGroup&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;    &amp;lt;/PropertyGroup&amp;gt;
        ...
        &amp;lt;StripSymbols&amp;gt;true&amp;lt;/StripSymbols&amp;gt;
    &amp;lt;/PropertyGroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I've also tried specifying it on the command:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dotnet publish MyApp.csproj -c:Release --runtime linux-x64 -v:m --self-contained true -p:StripSymbols=true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But I'm still getting huge executables on Linux and OSX.&lt;/p&gt;
&lt;p&gt;Is this version dependent? I'm targeting .NET 6 at the moment and it seems I've had issues with these entries previously as they are commented out (I can't remember why though, I think I ran into compiler issues - am investigating that now as I didn't add any comments).&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!--        &amp;lt;PublishAot&amp;gt;true&amp;lt;/PublishAot&amp;gt; &amp;gt;NET 7+ --&amp;gt; 
&amp;lt;!--        &amp;lt;PublishTrimmed&amp;gt;true&amp;lt;/PublishTrimmed&amp;gt;--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I'm wondering if the &lt;code&gt;&amp;lt;StripSymbols&amp;gt;&lt;/code&gt; not working for me is related?&lt;/p&gt;
</description>
      <pubDate>Mon, 01 Aug 2022 09:24:38 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1947</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1947</link>
      <title>Issue: [Hot Cold Splitting] R2RDump crashes when the first function is not split - @cshung</title>
      <description>&lt;h1&gt;Symptom:&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;Error: System.Collections.Generic.KeyNotFoundException: The given key '0' was not present in the dictionary.
   at System.Collections.Generic.SortedDictionary`2.get_Item(TKey key)
   at ILCompiler.Reflection.ReadyToRun.ReadyToRunReader.CountRuntimeFunctions(Boolean[] isEntryPoint, SortedDictionary`2 dScratch) in C:\dev\runtime\src\coreclr\tools\aot\ILCompiler.Reflection.ReadyToRun\ReadyToRunReader.cs:line 1081
   at ILCompiler.Reflection.ReadyToRun.ReadyToRunReader.EnsureMethods() in C:\dev\runtime\src\coreclr\tools\aot\ILCompiler.Reflection.ReadyToRun\ReadyToRunReader.cs:line 493
   at ILCompiler.Reflection.ReadyToRun.ReadyToRunAssembly.get_Methods() in C:\dev\runtime\src\coreclr\tools\aot\ILCompiler.Reflection.ReadyToRun\ReadyToRunReader.cs:line 73
   at R2RDump.TextDumper.DumpSectionContents(ReadyToRunSection section) in C:\dev\runtime\src\coreclr\tools\r2rdump\TextDumper.cs:line 377
   at R2RDump.TextDumper.DumpSection(ReadyToRunSection section) in C:\dev\runtime\src\coreclr\tools\r2rdump\TextDumper.cs:line 122
   at R2RDump.TextDumper.DumpHeader(Boolean dumpSections) in C:\dev\runtime\src\coreclr\tools\r2rdump\TextDumper.cs:line 83
   at R2RDump.R2RDump.Dump(ReadyToRunReader r2r) in C:\dev\runtime\src\coreclr\tools\r2rdump\R2RDump.cs:line 334
   at R2RDump.R2RDump.Run() in C:\dev\runtime\src\coreclr\tools\r2rdump\R2RDump.cs:line 591
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Repro steps:&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Checkout my &lt;code&gt;private/hot-cold-devenv&lt;/code&gt; branch &lt;a href="https://github.com/cshung/runtimelab/tree/private/hot-cold-devenv"&gt;here&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Run these commands in a Command Prompt (not Powershell)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;bc.cmd
blo.cmd
bctg.cmd
bs.cmd
cr.cmd
cgt-on.cmd
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Note, these scripts create environment variables, make sure you close the prompt when you are done with it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Then run&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;artifacts\tests\coreclr\windows.x64.Debug\GC\Stress\Framework\ReliabilityFramework\ReliabilityFramework.cmd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That test will take a very long time, we don't need to wait until it completes, just presses Ctrl+C once you see&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Loading all tests: ...................
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Running R2RDump with the following command will fail:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dotnet.cmd artifacts\bin\coreclr\windows.x64.Debug\R2RDump\R2RDump.dll --header --sc --in artifacts\tests\coreclr\windows.x64.Debug\GC\Stress\Framework\ReliabilityFramework\ReliabilityFramework.dll
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;Plausible causes:&lt;/h1&gt;
&lt;p&gt;Your code assumed all functions will be split, and that is not the case, sometimes we never split a function.&lt;/p&gt;
</description>
      <pubDate>Sun, 31 Jul 2022 19:47:57 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1946</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1946</link>
      <title>Issue: [Hot Cold Splitting] Support splitting on ARM64 - @amanasifkhalid</title>
      <description>&lt;p&gt;This issue starts of paper trail of known ARM64 tasks. As this list grows, feel free to break it up into separate issues.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[ ] As of writing, if I try running Crossgen on &lt;code&gt;System.Private.CoreLib&lt;/code&gt; with &lt;code&gt;--targetarch:arm64&lt;/code&gt; set, the following assert is hit before Crossgen can begin emitting the PE file: &lt;code&gt;!m_VariableLiveRanges-&amp;gt;back().m_EndEmitLocation.Valid()&lt;/code&gt; in &lt;code&gt;src\coreclr\jit\codegencommon.cpp:8771&lt;/code&gt;. If this is reproducible, this needs to be investigated and resolved (along with any other asserts encountered) before proceeding with other known issues.&lt;/li&gt;
&lt;li&gt;[ ] When emitting long jumps between the hot/cold sections, the JIT emits a relocation of type &lt;code&gt;IMAGE_REL_ARM64_BRANCH26&lt;/code&gt; to the host. In Crossgen2, this type corresponds to &lt;code&gt;RelocType.IMAGE_REL_BASED_ARM64_BRANCH26&lt;/code&gt;. Currently, &lt;code&gt;ProcessRelocation()&lt;/code&gt; in &lt;code&gt;src\coreclr\tools\aot\ILCompiler.ReadyToRun\ObjectWriter\RelocationHelper.cs&lt;/code&gt; does not handle this relocation type, so when it is encountered, Crossgen2 will throw an exception. This needs to be fixed by adding a case to the switch statement. As far as I know, since unconditional branches are the same size on ARM32 and ARM64, this relocation type should be handled the same way as &lt;code&gt;RelocType.IMAGE_REL_BASED_THUMB_BRANCH24&lt;/code&gt;. However, this will need to be verified.&lt;/li&gt;
&lt;li&gt;[ ] On x64, we rely on chained unwind info to differentiate between cold EH funclets and cold main body fragments. Because there is no concept of chained unwind info on ARM64, we will need to find a workaround for this. I haven't spent much time looking into this, but I do notice we already pass a boolean variable &lt;code&gt;isFunclet&lt;/code&gt; to &lt;code&gt;reserveUnwindInfo&lt;/code&gt;. I wonder if we could introduce a flag into the unwind info data structure used at runtime that reflects this value. If not, we may want to consult Bruce on if ARM64 unwind info has any data we can leverage to distinguish EH funclets from main body fragments.&lt;/li&gt;
&lt;/ul&gt;
</description>
      <pubDate>Thu, 28 Jul 2022 23:16:15 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1941</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1941</link>
      <title>Issue: DllImportGenerator can't run - @jerviscui</title>
      <description>&lt;p&gt;I clone the DllImportGenerator project and open sln by VS2022.
And then build the solution, there are 40 mistakes:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Error CS8795 &amp;quot;NativeExportsNE.Sum(int, int)&amp;quot; must have an implementation part because it has an accessibility modifier. \runtimelab\DllImportGenerator\Demo\ program.cs 11 activity&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      <pubDate>Wed, 20 Jul 2022 12:01:18 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1935</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1935</link>
      <title>Issue: Common Language Runtime detected an invalid program - @Bxaa</title>
      <description>&lt;p&gt;Hi,
Common Language Runtime detected an invalid program. The body of method 'Void ComFactory..ctor()' is invalid&lt;/p&gt;
&lt;p&gt;Code sample for reproduce:
https://drive.google.com/file/d/1Mw2gPtAdYR8dWpyj5nUu9KgxTlTKTtoV/view?usp=sharing&lt;/p&gt;
</description>
      <pubDate>Thu, 14 Jul 2022 08:46:55 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1932</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1932</link>
      <title>Issue: Where is WASM AOT support developed? dotnet/runtime vs. dotnet/runtimelab - @hannesd</title>
      <description>&lt;p&gt;I've been looking for a way to build WASM from C# AOT, no JIT involved once code is run in the browser. The number of projects and people out there who try to solve this is very confusing to me. At this point I have narrowed it down to dotnet/runtimelab and dotnet/runtime (the uno platform seems to use dotnet/runtime). To me they look like they are the &amp;quot;official&amp;quot; projects.&lt;/p&gt;
&lt;p&gt;First tests indicate that dotnet/runtime mono/wasm is stable and performs well while dotnet/runtimelab NativeAOT-LLVM is not as mature.&lt;/p&gt;
&lt;p&gt;Hence my question: How are these projects related and which one should I use? It looks like dotnet/runtime has seen more development activity recently. Is this where the official AOT support for C# is built by the community?&lt;/p&gt;
</description>
      <pubDate>Mon, 11 Jul 2022 11:54:12 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1928</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1928</link>
      <title>Issue: Linux build exited with code 137 - @jamsoft</title>
      <description>&lt;p&gt;I'm running into an error on Linux that I can't find much info on. The error is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error MSB3073: The command &amp;quot;&amp;quot;/home/&amp;lt;&amp;gt;/.nuget/packages/runtime.linux-x64.microsoft.dotnet.ilcompiler/7.0.0-preview.5.22301.12/tools/ilc&amp;quot; @&amp;quot;obj/Release/net6.0/linux-x64/native/MyApp.ilc.rsp&amp;quot;&amp;quot; exited with code 137
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The only mention of this I can find is on the old CoreRT repo where the compilation was running out of memory running in a container. My build is running on a real box running PopOS with 16GB RAM.&lt;/p&gt;
&lt;p&gt;Would it be worth trying it in a VM with 32 GB RAM allocated?&lt;/p&gt;
&lt;p&gt;It gets really close to the end of the process but then bombs.&lt;/p&gt;
</description>
      <pubDate>Mon, 04 Jul 2022 13:30:45 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1925</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1925</link>
      <title>Issue: [Question] Could not find method  - @jamsoft</title>
      <description>&lt;p&gt;I've hit quite a roadblock with no idea how to fix.&lt;/p&gt;
&lt;p&gt;At runtime I get an error:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;InvalidOperationException: Could not find method 'IncludeReference' on type 'Microsoft.EntityFrameworkCore.Query.RelationalShapedQueryCompilingExpressionVisitor+ShaperProcessingExpressionVisitor'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which is referencing &lt;a href="https://github.com/dotnet/efcore/blob/5887391bdb1d340aedf37751086670828035029a/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs#L34"&gt;this line of code&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private static readonly MethodInfo IncludeReferenceMethodInfo
    = typeof(ShaperProcessingExpressionVisitor).GetTypeInfo().GetDeclaredMethod(nameof(IncludeReference))!;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But I've no idea how to set this up in my &lt;code&gt;rd.xml&lt;/code&gt; file. I tried:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;Type Name=&amp;quot;Microsoft.EntityFrameworkCore.Query.RelationalShapedQueryCompilingExpressionVisitor+ShaperProcessingExpressionVisitor&amp;quot; Dynamic=&amp;quot;Required All&amp;quot; MarshalDelegate=&amp;quot;Required All&amp;quot; Serialize=&amp;quot;Required All&amp;quot;&amp;gt;
    &amp;lt;Method Name=&amp;quot;IncludeReference&amp;quot; Dynamic=&amp;quot;Required&amp;quot; /&amp;gt;
&amp;lt;/Type&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But that just errors with &lt;code&gt;EXEC : error : Could not find Method(s)&lt;/code&gt; Are there any examples of handling this kind of code?&lt;/p&gt;
</description>
      <pubDate>Fri, 01 Jul 2022 18:33:48 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1924</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1924</link>
      <title>Issue: [Question] Calling C DLL Through DLLImport in Dependency - @jamsoft</title>
      <description>&lt;p&gt;I'm working through compiling my application (.NET6.0/AvaloniaUI). It's slow going but I'm making progress and working on my &lt;code&gt;rd.xml&lt;/code&gt; file as I go.&lt;/p&gt;
&lt;p&gt;The issue I'm facing has me confused. I'm not even 100% sure my scenario is supported from reading the docs but I'm just not experienced enough to know for sure. It doesn't feel like an outlandish requirement so I'm hoping it's my inexperience that's the issue.&lt;/p&gt;
&lt;p&gt;During application initialisation my application calls into a .NET managed library that wraps the functionality of a C library.&lt;/p&gt;
&lt;p&gt;My rd.xml entry for the managed library is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;Assembly Name=&amp;quot;AssemblyName&amp;quot; Dynamic=&amp;quot;Required All&amp;quot; MarshalDelegate=&amp;quot;Required All&amp;quot; Serialize=&amp;quot;Required All&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This libraries calls to the C library are decorated with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[DllImport(&amp;quot;dllname&amp;quot;, EntryPoint = &amp;quot;methodname&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first call it failed on is an instruction sent to this C library to load another C library that is a plugin to the main C library. So whilst it's obviously not using the unsupported &lt;code&gt;Assembly.Load&lt;/code&gt; API I'm unsure whether to expect something like that to work given the published limitations on dynamic loading, but I'm also thinking that's limited to the &amp;quot;user code&amp;quot; of the application, not 3rd party dependencies also not using &lt;code&gt;Assembly.Load&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So as A test, I removed all the plugin load code to simplify things.&lt;/p&gt;
&lt;p&gt;It then started failing on the next call to the main C library. The error is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0xC0000005: Access violation reading location 0x0000000000000000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All the C dependencies are in the same / expected location next to the main .exe file. The layout mirrors the non NativeAOT layout.&lt;/p&gt;
&lt;p&gt;If I remove the dependencies and debug the application the error is that it cannot find the C library.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Unable to [find?] native library 'dllname' or one of its dependencies
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If I put the dependencies back, I just get the access violation which seems to suggest it found the dll but cannot access it.&lt;/p&gt;
&lt;p&gt;I've tried various settings out of desperation, such as &lt;code&gt;&amp;lt;DirectPInvoke Include=&amp;quot;dllname&amp;quot; /&amp;gt;&lt;/code&gt; but I'm not doing the PInvoke from my code, the 3rd party is. The &lt;code&gt;NativeLibrary&lt;/code&gt; seems the most appropriate but it needs a *.lib or *.a file.&lt;/p&gt;
&lt;p&gt;I guess the first question is, can I even do what I need to do? If I can, is this documented anywhere or could I get a little nudge in the right direction?&lt;/p&gt;
&lt;p&gt;TIA.&lt;/p&gt;
&lt;p&gt;Setup: Rider, Release, Any CPU, .NET 6.0, win-x64, AvaloniaUI 0.10.15, ILCompiler 7.0.0-alpha.1.22074.1&lt;/p&gt;
</description>
      <pubDate>Fri, 01 Jul 2022 07:23:50 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1918</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1918</link>
      <title>Issue: [Hot cold splitting] Support split-eh - @cshung</title>
      <description>&lt;p&gt;As the PR https://github.com/dotnet/runtime/pull/71236 is merged, we should update crossgen2 to support cold funclets.&lt;/p&gt;
&lt;p&gt;Here are a few things to do:&lt;/p&gt;
&lt;p&gt;On the JIT side:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;[x] Consider making eh-split configurable. As you can see, there is a lot of work on the crossgen2/vm side to catch up. It would be bad if we can't update the lab branch before we have done all of these.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[x] Make sure the JIT reports the unwind info accurately. The expectation is we get exactly one pair of &lt;code&gt;reserveUnwindInfo&lt;/code&gt; and &lt;code&gt;allocUnwindInfo&lt;/code&gt; for each runtime function. There are only two cases, case 1 is that it is the main function or a funclet, then in the JIT, we should have generated the right unwind info data, we need to right data and the right flags. Another case is that it is a cold block that is not a funclet, and we would like to get a callback with the right range but with a &lt;code&gt;unwindSize == 0&lt;/code&gt; so that we know we have to generate a chained unwind info.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;On the crossgen2 side:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;[x] Expect more than 1 calls to &lt;code&gt;reserveUnwindInfo&lt;/code&gt; &lt;a href="https://github.com/dotnet/runtimelab/blob/7ccc22fabe7d516d9d8ea7c124fa79dbca654e8a/src/coreclr/tools/Common/JitInterface/CorInfoImpl.cs#L3465"&gt;here&lt;/a&gt; and &lt;code&gt;allocUnwindInfo&lt;/code&gt; &lt;a href="https://github.com/dotnet/runtimelab/blob/7ccc22fabe7d516d9d8ea7c124fa79dbca654e8a/src/coreclr/tools/Common/JitInterface/CorInfoImpl.cs#L3473"&gt;here&lt;/a&gt; for the cold code. They are both in &lt;code&gt;CorInfoImpl.cs&lt;/code&gt; and it is our entry point to the JIT questions. Before eh-splitting, the only cold funclet appears to be always zero sized, so I just ignored it &lt;a href="https://github.com/dotnet/runtimelab/blob/7ccc22fabe7d516d9d8ea7c124fa79dbca654e8a/src/coreclr/tools/Common/JitInterface/CorInfoImpl.cs#L3502"&gt;here&lt;/a&gt;. After eh-splitting, there could be non-trivial unwind-info allocated with the cold funclet, and we need to remember them in a structure parallel to &lt;code&gt;_frameInfos&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[x] Adapt &lt;code&gt;MethodGCInfoNode.CalculateFuncletOffsets&lt;/code&gt; &lt;a href="https://github.com/dotnet/runtimelab/blob/7ccc22fabe7d516d9d8ea7c124fa79dbca654e8a/src/coreclr/tools/aot/ILCompiler.ReadyToRun/Compiler/DependencyAnalysis/ReadyToRun/MethodGCInfoNode.cs#L40"&gt;here&lt;/a&gt;. Before eh-split, the cold code is always just some code that has no interest unwind info on its own, so we are expected to always generate exactly a default chained unwind info for it. Therefore, if we have cold code, the offset to that cold code unwind info is always at the end, and there is always exactly one of it. This layout (i.e. generating the cold code unwind info right after its hot counter part) is not ideal from the density point of view, and the work to optimize it is tracked as &lt;a href="https://github.com/dotnet/runtimelab/issues/1902"&gt;this&lt;/a&gt; issue.  Regardless of whether we pack or not, we need to return the right offsets to the cold funclet unwind data.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[x] Adapt&lt;code&gt;MethodGCInfoNode.GetData&lt;/code&gt; &lt;a href="https://github.com/dotnet/runtimelab/blob/7ccc22fabe7d516d9d8ea7c124fa79dbca654e8a/src/coreclr/tools/aot/ILCompiler.ReadyToRun/Compiler/DependencyAnalysis/ReadyToRun/MethodGCInfoNode.cs#L132"&gt;here&lt;/a&gt; to emit the cold funclet unwind data. Note how I generated the chained unwind info &lt;a href="https://github.com/dotnet/runtimelab/blob/7ccc22fabe7d516d9d8ea7c124fa79dbca654e8a/src/coreclr/tools/aot/ILCompiler.ReadyToRun/Compiler/DependencyAnalysis/ReadyToRun/MethodGCInfoNode.cs#L177"&gt;here&lt;/a&gt;. The rest should follow a similar pattern.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[x] Adapt &lt;code&gt;RuntimeFunctionsTableNode.GetData&lt;/code&gt; &lt;a href="https://github.com/dotnet/runtimelab/blob/7ccc22fabe7d516d9d8ea7c124fa79dbca654e8a/src/coreclr/tools/aot/ILCompiler.ReadyToRun/Compiler/DependencyAnalysis/ReadyToRun/RuntimeFunctionsTableNode.cs#L60"&gt;here&lt;/a&gt; to generate the runtime function table entry. With the &lt;code&gt;CalculateFuncletOffsets&lt;/code&gt; change, we should get the offsets to the unwind info for the cold code, but we also need to generate the entries in the runtime function table to point to them. Note that we are hard coded to generate exactly one entry in the table in &lt;a href="https://github.com/dotnet/runtimelab/blob/7ccc22fabe7d516d9d8ea7c124fa79dbca654e8a/src/coreclr/tools/aot/ILCompiler.ReadyToRun/Compiler/DependencyAnalysis/ReadyToRun/RuntimeFunctionsTableNode.cs#L104"&gt;this&lt;/a&gt; block, so we need to generate the right amount of entries pointing to the right locations. That information should be collected earlier in the parallel structure. Be careful about the &lt;code&gt;mapping&lt;/code&gt; variable so that we generate only one pair per cold block (not per runtime function entry).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;On the VM side:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;[x] Adapt &lt;code&gt;ReadyToRunJitManager::JitCodeToMethodInfo&lt;/code&gt; &lt;a href="https://github.com/dotnet/runtimelab/blob/7ccc22fabe7d516d9d8ea7c124fa79dbca654e8a/src/coreclr/vm/codeman.cpp#L6065"&gt;here&lt;/a&gt; to account for the possibility of cold funclets. In particular, if the cold block contains multiple funclets, it is possible that the corresponding runtime function is not on the scratch map, so &lt;a href="https://github.com/dotnet/runtimelab/blob/7ccc22fabe7d516d9d8ea7c124fa79dbca654e8a/src/coreclr/vm/codeman.cpp#L6117"&gt;this&lt;/a&gt; check will fail. We need some solution to figure out how to solve that.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[x] Avoid reporting the cold code is not a funclet &lt;a href="https://github.com/dotnet/runtimelab/blob/7ccc22fabe7d516d9d8ea7c124fa79dbca654e8a/src/coreclr/vm/codeman.cpp#L6253"&gt;here&lt;/a&gt;. But eliminating the loop is wrong because it could be a cold block that is not a funclet (which means it's start address is not the same as the function entry point), we probably need to inspect the unwind info and look for the chained unwind info flag.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[x] Adapt &lt;code&gt;ReadyToRunJitManager:: JitTokenToMethodRegionInfo&lt;/code&gt; &lt;a href="https://github.com/dotnet/runtimelab/blob/b3ce055008bcca56f9c13b8570d971418bbbb8ea/src/coreclr/vm/codeman.cpp#L6377"&gt;here&lt;/a&gt;. Right now the code assumed the method can have only one cold runtime function, so it only subtract the size of one runtime function.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[x] Adapt &lt;code&gt;ReadyToRunJitManager::JitCodeToMethodInfo &lt;/code&gt;&lt;a href="https://github.com/dotnet/runtimelab/blob/b3ce055008bcca56f9c13b8570d971418bbbb8ea/src/coreclr/vm/codeman.cpp#L4042"&gt;here&lt;/a&gt;. Right now, the &lt;code&gt;m_relOffset&lt;/code&gt; is computed simply by subtracting the current program counter from the beginning of the method, that will include space between the hot and cold code, we need to discount that.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The above is all that I am aware of, there is, obviously, the possibility of things that I am unaware of. We need to make sure we test and fix them all.&lt;/p&gt;
</description>
      <pubDate>Thu, 30 Jun 2022 01:24:19 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1913</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1913</link>
      <title>Issue: [Hot Cold Splitting] Ensure SOS works with hot/cold splitting - @BruceForstall</title>
      <description>&lt;p&gt;E.g., &lt;code&gt;u&lt;/code&gt; (unassemble).&lt;/p&gt;
</description>
      <pubDate>Mon, 20 Jun 2022 21:04:20 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1912</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1912</link>
      <title>Issue: [Hot Cold Splitting] Avoid relying on class code value  - @cshung</title>
      <description>&lt;p&gt;Right now, the code relies on class code value to ensure cold code blocks get generated after hot code, we should not rely on that. See &lt;a href="https://github.com/dotnet/runtimelab/pull/1900#discussion_r901216913"&gt;this comment&lt;/a&gt; for more details.&lt;/p&gt;
</description>
      <pubDate>Mon, 20 Jun 2022 16:53:21 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1911</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1911</link>
      <title>Issue: [Hot Cold Splitting] Performance measurement - @cshung</title>
      <description>&lt;p&gt;We should do some performance measurement to make sure hot-cold splitting does improve certain scenarios.&lt;/p&gt;
</description>
      <pubDate>Sat, 18 Jun 2022 19:51:20 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1910</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1910</link>
      <title>Issue: [Hot Cold Splitting] Fix ILSpy.ReadyToRun disassembling - @cshung</title>
      <description>&lt;p&gt;Right now, ILSpy is capable of disassembling ready-to-run code, but it is unaware of hot-cold splitting.&lt;/p&gt;
</description>
      <pubDate>Sat, 18 Jun 2022 19:50:28 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1909</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1909</link>
      <title>Issue: [Hot Cold Splitting] Fix R2RDump to dump the hot cold map - @cshung</title>
      <description>&lt;p&gt;Right now, R2RDump is unaware of the hot-cold map, it would be nice to provide a dump of the session, ideally in some human-readable fashion instead of just a pile of numbers.&lt;/p&gt;
</description>
      <pubDate>Sat, 18 Jun 2022 19:49:22 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1908</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1908</link>
      <title>Issue: [Hot Cold Splitting] Fix R2RDump to support dumping hot-cold parts together - @cshung</title>
      <description>&lt;p&gt;Right now, R2RDump will dump all the cold blocks as part of the last hot function, that is just wrong.&lt;/p&gt;
</description>
      <pubDate>Sat, 18 Jun 2022 19:48:05 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1907</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1907</link>
      <title>Issue: [Hot Cold Splitting] Make sure the debugger work under hot cold splitting - @cshung</title>
      <description>&lt;p&gt;Right now, we have some known test failures.&lt;/p&gt;
</description>
      <pubDate>Sat, 18 Jun 2022 19:47:08 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1906</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1906</link>
      <title>Issue: [Hot Cold Splitting] Conditional hot-cold mapping generation. - @cshung</title>
      <description>&lt;p&gt;Right now, the hot-cold mapping is generated unconditionally. We should not generate it if there are no cold blocks.&lt;/p&gt;
</description>
      <pubDate>Sat, 18 Jun 2022 19:46:28 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1905</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1905</link>
      <title>Issue: [Hot Cold Splitting] GCStress testing - @cshung</title>
      <description>&lt;p&gt;We should use the GCStress testing infrastructure to make sure our code is safe when GC is enabled.&lt;/p&gt;
</description>
      <pubDate>Sat, 18 Jun 2022 19:44:51 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1904</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1904</link>
      <title>Issue: [Hot Cold Splitting] Optimize the exception processing to avoid repeated hot-cold mapping lookup  - @cshung</title>
      <description>&lt;p&gt;Right now, when an exception happens, we perform the lookup a lot of times for the same frame. We should perform the lookup once only (or at least reduce the number of times)&lt;/p&gt;
</description>
      <pubDate>Sat, 18 Jun 2022 19:43:55 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1903</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1903</link>
      <title>Issue: [Hot Cold Splitting] Redesign the hot cold mapping data structure to allow fast lookup - @cshung</title>
      <description>&lt;p&gt;Right now, the data structure is simply a list of (cold runtime function index, hot runtime function index), this is not efficient for lookup. We need to redesign it so that it can be lookup fast.&lt;/p&gt;
</description>
      <pubDate>Sat, 18 Jun 2022 19:42:39 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1902</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1902</link>
      <title>Issue: [Hot Cold Splitting] Pack the cold unwind data together - @cshung</title>
      <description>&lt;p&gt;Right now, the unwind data for the cold code is placed right after the hot code GCInfo, clustering the cold code unwind info can lead to better page usage during the stack unwinding.&lt;/p&gt;
</description>
      <pubDate>Sat, 18 Jun 2022 19:40:42 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1901</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1901</link>
      <title>Issue: [Hot Cold Splitting] Generate the cold code in the proper session for Unix. - @cshung</title>
      <description>&lt;p&gt;Right now, the cold code for Unix is generated in &lt;code&gt;ObjectNodeSection.ManagedCodeWindowsContentSection&lt;/code&gt;, we need to put it in a proper place for Unix.&lt;/p&gt;
</description>
      <pubDate>Sat, 18 Jun 2022 19:38:35 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1897</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1897</link>
      <title>Issue: [NativeAOT] [Question] Build for Android Shared/Static Library - @An0nyMooUS</title>
      <description>&lt;p&gt;I followyed this tutorial:&lt;/p&gt;
&lt;p&gt;https://github.com/dotnet/runtimelab/tree/feature/NativeAOT/samples/NativeLibrary&lt;/p&gt;
&lt;p&gt;and change &lt;code&gt;-r win-x64&lt;/code&gt; to &lt;code&gt;-r android-arm64&lt;/code&gt;. On Windows produces:&lt;/p&gt;
&lt;p&gt;&amp;quot;error : Cross-OS native compilation is not supported&amp;quot;&lt;/p&gt;
&lt;p&gt;that's ok..., i tryed to use WSL2 + Ubuntu to do this. and produces:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
Microsoft (R) Build Engine version 17.2.0+41abc5629 for .NET
Copyright (C) Microsoft Corporation. All rights reserved.

  Determining projects to restore...
  Restored /mnt/c/wtf/nativelibrary/NativeLibrary.csproj (in 2.44 sec).
/usr/share/dotnet/sdk/6.0.300/Sdks/Microsoft.NET.Sdk/targets/Microsoft.NET.Sdk.targets(1114,5): warning NETSDK1179: One of '--self-contained' or '--no-self-contained' options are required when '--runtime' is used. [/mnt/c/wtf/nativelibrary/NativeLibrary.csproj]
  NativeLibrary -&amp;gt; /mnt/c/wtf/nativelibrary/bin/release/net6.0/android-arm64/NativeLibrary.dll
  Generating compatible native code. To optimize for size or speed, visit https://aka.ms/OptimizeCoreRT
  /usr/bin/ld: unrecognised emulation mode: aarch64linux
  Supported emulations: elf_x86_64 elf32_x86_64 elf_i386 elf_iamcu elf_l1om elf_k1om i386pep i386pe
clang : error : linker command failed with exit code 1 (use -v to see invocation) [/mnt/c/wtf/nativelibrary/NativeLibrary.csproj]
/root/.nuget/packages/microsoft.dotnet.ilcompiler/7.0.0-alpha.1.22074.1/build/Microsoft.NETCore.Native.targets(374,5): error MSB3073: The command &amp;quot;clang &amp;quot;obj/release/net6.0/android-arm64/native/NativeLibrary.o&amp;quot; -o &amp;quot;bin/release/net6.0/android-arm64/native/NativeLibrary.so&amp;quot; -Wl,--version-script=obj/release/net6.0/android-arm64/native/NativeLibrary.exports /root/.nuget/packages/runtime.linux-arm64.microsoft.dotnet.ilcompiler/7.0.0-alpha.1.22074.1/sdk/libbootstrapperdll.a /root/.nuget/packages/runtime.linux-arm64.microsoft.dotnet.ilcompiler/7.0.0-alpha.1.22074.1/sdk/libRuntime.WorkstationGC.a /root/.nuget/packages/runtime.linux-arm64.microsoft.dotnet.ilcompiler/7.0.0-alpha.1.22074.1/framework/libSystem.Native.a /root/.nuget/packages/runtime.linux-arm64.microsoft.dotnet.ilcompiler/7.0.0-alpha.1.22074.1/framework/libSystem.Globalization.Native.a /root/.nuget/packages/runtime.linux-arm64.microsoft.dotnet.ilcompiler/7.0.0-alpha.1.22074.1/framework/libSystem.IO.Compression.Native.a /root/.nuget/packages/runtime.linux-arm64.microsoft.dotnet.ilcompiler/7.0.0-alpha.1.22074.1/framework/libSystem.Net.Security.Native.a /root/.nuget/packages/runtime.linux-arm64.microsoft.dotnet.ilcompiler/7.0.0-alpha.1.22074.1/framework/libSystem.Security.Cryptography.Native.OpenSsl.a --target=aarch64-linux-gnu -g -Wl,-rpath,'$ORIGIN' -Wl,--as-needed -pthread -lstdc++ -ldl -lm -lz -lgssapi_krb5 -lrt -shared -Wl,-z,relro -Wl,-z,now -Wl,--require-defined,CoreRT_StaticInitialization -Wl,--discard-all -Wl,--gc-sections&amp;quot; exited with code 1. [/mnt/c/wtf/nativelibrary/NativeLibrary.csproj]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt; /usr/bin/ld: unrecognised emulation mode: aarch64linux&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Its possible to build for ARM/ARM64? i successfully build for &lt;code&gt;android-x86/x64&lt;/code&gt;. but i can't compile for ARM/ARM 64.&lt;/p&gt;
</description>
      <pubDate>Sun, 12 Jun 2022 19:15:38 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/runtimelab/issues/1896</guid>
      <link>https://github.com/dotnet/runtimelab/issues/1896</link>
      <title>Issue: [NativeAOT] Static class - @RoccoZero</title>
      <description>&lt;p&gt;is it possible to remove these calls?
it's just that in my project, optimization should be at the highest level like c++&lt;/p&gt;
&lt;p&gt;I myself immediately activate manually all static properties
I want to completely remove automatic activation of static classes
please give us this opportunity&lt;/p&gt;
&lt;img width="540" alt="image" src="https://user-images.githubusercontent.com/33149580/173237270-013423fa-1196-4da5-b63e-f3dc9f1a086c.png"&gt;
</description>
      <pubDate>Sun, 12 Jun 2022 14:10:40 Z</pubDate>
    </item>
  </channel>
</rss>