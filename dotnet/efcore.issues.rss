<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>dotnet/efcore Issues</title>
    <description>Issues from https://github.com/dotnet/efcore, generated by https://github.com/meziantou/IssuesToRss/</description>
    <managingEditor>meziantousite@outlook.com</managingEditor>
    <ttl>60</ttl>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29190</guid>
      <link>https://github.com/dotnet/efcore/issues/29190</link>
      <title>Issue: DbUpdateException Entries contain all items from AddRange when &gt; 3 - @mikeleigh1010</title>
      <description>&lt;p&gt;DbUpdateException Entries property inconsistent with returned values (and includes items which are not involved with exception).&lt;/p&gt;
&lt;p&gt;I'm seeming to observe that 3 items (one duplicate and two happy day) can fail and entries will return only the item failed but &amp;gt; 3 in an addrange seems to be where the exception entries includes all items attempted.&lt;/p&gt;
&lt;p&gt;`&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Index(nameof(Name), IsUnique = true)]
public class Cat
{
    public int Id { get; init; }
    public string Name { get; init; } = string.Empty;
    public int Age { get; init; }
}

public class AppDbContext : DbContext
{
    public DbSet&amp;lt;Cat&amp;gt; Cats { get; set; }

    public AppDbContext(DbContextOptions&amp;lt;PspDbContext&amp;gt; options) : base(options)
    {
    }
}

public class Processor
{

    private IDbContextFactory&amp;lt;AppDbContext&amp;gt; _contextFactory;
    public Processor(IDbContextFactory&amp;lt;AppDbContext&amp;gt; contextFactory)
    {
        _contextFactory = contextFactory;
    }

    public async Task ProcessCats()
    {
        await using var context = await _contextFactory.CreateDbContextAsync();
        var cat = new Cat
        {
            Name = &amp;quot;garfield&amp;quot;,
            Age = 10
        };

        context.Cats.Add(cat);
        await context.SaveChangesAsync();
        
        try
        {
            context.Cats.AddRange(new List&amp;lt;Cat&amp;gt;
            {
                cat,
                new()
                {
                    Name = &amp;quot;topcat&amp;quot;,
                    Age = 3
                },
                new()
                {
                    Name = &amp;quot;felix&amp;quot;,
                    Age = 2
                }
            });
            await context.SaveChangesAsync();
        }
        catch (DbUpdateException dbEx)
        {
            var entries = dbEx.Entries;
            // entries collection will only contain duplicate cat of &amp;quot;garfield&amp;quot;
        }
        
        try
        {
            context.Cats.AddRange(new List&amp;lt;Cat&amp;gt;
            {
                cat,
                new()
                {
                    Name = &amp;quot;topcat&amp;quot;,
                    Age = 3
                },
                new()
                {
                    Name = &amp;quot;felix&amp;quot;,
                    Age = 2
                },
                new()
                {
                    Name = &amp;quot;lucky&amp;quot;,
                    Age = 55
                }
            });
            await context.SaveChangesAsync();
        }
        catch (DbUpdateException dbEx)
        {
            var entries = dbEx.Entries;
            // entries collection will contain all cats attempted to be inserted
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;`&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Originally posted by @mikeleigh1010 in https://github.com/dotnet/efcore/issues/26530#issuecomment-1256289498&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;To give context, we are looking to capture offending items (duplicate cats of the same name) and disregard so we can continue to insert.&lt;/p&gt;
</description>
      <pubDate>Fri, 23 Sep 2022 15:16:38 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29189</guid>
      <link>https://github.com/dotnet/efcore/issues/29189</link>
      <title>Issue: .HasNoKey() and migrations creating tables - @dazinator</title>
      <description>&lt;p&gt;I am attempting to use EF Core to execute a stored procedure in sql server, and return me a list of entities. The entity type is essentially read only. (i.e I don't want it to be tracked and don't want to create, update, or delete these).
I have created the entity type with properties to match the stored procedure result set, and addedthis entity type to my dbcontext as a typical DbSet, but with &lt;code&gt;HasNoKey&lt;/code&gt; but when I add a migration, the migration still attempts to create a table for this entity. I can't do what this commenter suggests and map it to a view because this entity isn't backed by a view, its a stored procedure providing the data. Is this behaviour expected and if so what is the solution?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;for future readers, if adding .HasNoKey() didn't prevent the CodeFirst migration from creating a table for that view, try adding the following:
&lt;code&gt;modelBuilder.Entity&amp;lt;User&amp;gt;().ToView(&amp;quot;Users&amp;quot;).HasNoKey()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;as in my situation the migration kept creating a table for the view and using ToView fixed it&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;Originally posted by @MuhAssar in https://github.com/dotnet/efcore/issues/15656#issuecomment-536802455&lt;/em&gt;&lt;/p&gt;
</description>
      <pubDate>Fri, 23 Sep 2022 13:13:48 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29187</guid>
      <link>https://github.com/dotnet/efcore/issues/29187</link>
      <title>Issue: Can't get DbFunction to work with DateOnly - @lara-ec</title>
      <description>&lt;p&gt;Hi,&lt;/p&gt;
&lt;p&gt;I'm currently migrating to .NET 6, and given the introduction of &lt;code&gt;DateOnly&lt;/code&gt;, I want to create a variation of an existing DbFunction, &lt;code&gt;UtcToBerlinTimeZone()&lt;/code&gt;, that returns &lt;code&gt;DateOnly&lt;/code&gt; instead of &lt;code&gt;DateTime&lt;/code&gt;, called &lt;code&gt;UtcToBerlinDate()&lt;/code&gt;. But I can't get it to work, it always throws an exception.&lt;/p&gt;
&lt;p&gt;I have an implementation for both SQLite (Unit Tests) and MySQL (normal operation), and both fail in the same way.&lt;/p&gt;
&lt;p&gt;Any help in understanding the issue would be much appreciated :)&lt;/p&gt;
&lt;h3&gt;Function declaration&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;public static DateTime UtcToBerlinTimeZone(DateTime datetime)
{
    throw new NotImplementedException(&amp;quot;Only use in LINQ2SQL&amp;quot;);
}

public static DateOnly UtcToBerlinDate(DateTime datetime)
{
    throw new NotImplementedException(&amp;quot;Only use in LINQ2SQL&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Old function, that still works&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;if (Database.IsSqlite())
{
    modelBuilder
        .HasDbFunction(
            typeof(Functions.Functions).GetMethod(
                nameof(Functions.Functions.UtcToBerlinTimeZone)
            )!
        )
        .HasName(nameof(Functions.Functions.UtcToBerlinTimeZone))
        .HasTranslation(
            args =&amp;gt;
                new SqlFunctionExpression(
                    &amp;quot;utc_to_berlin_time&amp;quot;,
                    new[] { args[0] },
                    true,
                    new[] { true },
                    typeof(DateTime),
                    new DateTimeTypeMapping(&amp;quot;datetime&amp;quot;, DbType.DateTime)
                )
        );
}
else
{
    modelBuilder
        .HasDbFunction(
            typeof(Functions.Functions).GetMethod(
                nameof(Functions.Functions.UtcToBerlinTimeZone)
            )!
        )
        .HasName(nameof(Functions.Functions.UtcToBerlinTimeZone))
        .HasTranslation(
            args =&amp;gt;
                new SqlFunctionExpression(
                    &amp;quot;CONVERT_TZ&amp;quot;,
                    new[]
                    {
                        args[0],
                        new SqlConstantExpression(
                            Expression.Constant(&amp;quot;UTC&amp;quot;),
                            new StringTypeMapping(&amp;quot;varchar&amp;quot;, DbType.String)
                        ),
                        new SqlConstantExpression(
                            Expression.Constant(&amp;quot;Europe/Berlin&amp;quot;),
                            new StringTypeMapping(&amp;quot;varchar&amp;quot;, DbType.String)
                        ),
                    },
                    true,
                    new[] { true, false, false },
                    typeof(DateTime),
                    new DateTimeTypeMapping(&amp;quot;datetime&amp;quot;, DbType.DateTime)
                )
        );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;New modification, that doesn't work&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;if (Database.IsSqlite())
{
    modelBuilder
        .HasDbFunction(
            typeof(Functions.Functions).GetMethod(
                nameof(Functions.Functions.UtcToBerlinDate)
            )!
        )
        .HasName(nameof(Functions.Functions.UtcToBerlinDate))
        .HasTranslation(
            args =&amp;gt;
                new SqlFunctionExpression(
                    &amp;quot;date&amp;quot;,
                    new[]
                    {
                        new SqlFunctionExpression(
                            &amp;quot;utc_to_berlin_time&amp;quot;,
                            new[] { args[0] },
                            true,
                            new[] { true },
                            typeof(DateTime),
                            new DateTimeTypeMapping(&amp;quot;datetime&amp;quot;, DbType.DateTime)
                        ),
                    },
                    true,
                    new[] { true },
                    typeof(DateOnly),
                    new DateTimeTypeMapping(&amp;quot;date&amp;quot;, DbType.Date)
                )
        );
}
else
{
    modelBuilder
        .HasDbFunction(
            typeof(Functions.Functions).GetMethod(
                nameof(Functions.Functions.UtcToBerlinDate)
            )!
        )
        .HasName(nameof(Functions.Functions.UtcToBerlinDate))
        .HasTranslation(
            args =&amp;gt;
                new SqlFunctionExpression(
                    &amp;quot;DATE&amp;quot;,
                    new[]
                    {
                        new SqlFunctionExpression(
                            &amp;quot;CONVERT_TZ&amp;quot;,
                            new[]
                            {
                                args[0],
                                new SqlConstantExpression(
                                    Expression.Constant(&amp;quot;UTC&amp;quot;),
                                    new StringTypeMapping(&amp;quot;varchar&amp;quot;, DbType.String)
                                ),
                                new SqlConstantExpression(
                                    Expression.Constant(&amp;quot;Europe/Berlin&amp;quot;),
                                    new StringTypeMapping(&amp;quot;varchar&amp;quot;, DbType.String)
                                ),
                            },
                            true,
                            new[] { true, false, false },
                            typeof(DateTime),
                            new DateTimeTypeMapping(&amp;quot;datetime&amp;quot;, DbType.DateTime)
                        ),
                    },
                    true,
                    new[] { true },
                    typeof(DateOnly),
                    new DateTimeTypeMapping(&amp;quot;date&amp;quot;, DbType.Date)
                )
        );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;This is the error I always get&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;System.InvalidOperationException: No coercion operator is defined between types 'System.DateTime' and 'System.Nullable`1[System.DateOnly]'.
   at System.Linq.Expressions.Expression.GetUserDefinedCoercionOrThrow(ExpressionType coercionType, Expression expression, Type convertToType)
   at System.Linq.Expressions.Expression.Convert(Expression expression, Type type, MethodInfo method)
   at System.Linq.Expressions.Expression.Convert(Expression expression, Type type)
   at Microsoft.EntityFrameworkCore.Query.RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.CreateGetValueExpression(ParameterExpression dbDataReader, Int32 index, Boolean nullable, RelationalTypeMapping typeMapping, Type type, IPropertyBase property)
   at Microsoft.EntityFrameworkCore.Query.RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.VisitExtension(Expression extensionExpression)
   at System.Linq.Expressions.Expression.Accept(ExpressionVisitor visitor)
   at System.Linq.Expressions.ExpressionVisitor.Visit(Expression node)
   at System.Linq.Expressions.ExpressionVisitor.VisitUnary(UnaryExpression node)
   at System.Linq.Expressions.UnaryExpression.Accept(ExpressionVisitor visitor)
   at System.Linq.Expressions.ExpressionVisitor.Visit(Expression node)
   at System.Dynamic.Utils.ExpressionVisitorUtils.VisitArguments(ExpressionVisitor visitor, IArgumentProvider nodes)
   at System.Linq.Expressions.ExpressionVisitor.VisitNew(NewExpression node)
   at System.Linq.Expressions.NewExpression.Accept(ExpressionVisitor visitor)
   at System.Linq.Expressions.ExpressionVisitor.Visit(Expression node)
   at Microsoft.EntityFrameworkCore.Query.RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.ProcessShaper(Expression shaperExpression, RelationalCommandCache&amp;amp; relationalCommandCache, LambdaExpression&amp;amp; relatedDataLoaders, Int32&amp;amp; collectionId)
   at Microsoft.EntityFrameworkCore.Query.RelationalShapedQueryCompilingExpressionVisitor.VisitShapedQuery(ShapedQueryExpression shapedQueryExpression)
   at Microsoft.EntityFrameworkCore.Query.ShapedQueryCompilingExpressionVisitor.VisitExtension(Expression extensionExpression)
   at System.Linq.Expressions.Expression.Accept(ExpressionVisitor visitor)
   at System.Linq.Expressions.ExpressionVisitor.Visit(Expression node)
   at Microsoft.EntityFrameworkCore.Query.QueryCompilationContext.CreateQueryExecutor[TResult](Expression query)
   at Microsoft.EntityFrameworkCore.Storage.Database.CompileQuery[TResult](Expression query, Boolean async)
   at Microsoft.EntityFrameworkCore.Query.Internal.QueryCompiler.CompileQueryCore[TResult](IDatabase database, Expression query, IModel model, Boolean async)
   at Microsoft.EntityFrameworkCore.Query.Internal.QueryCompiler.&amp;lt;&amp;gt;c__DisplayClass12_0`1.&amp;lt;ExecuteAsync&amp;gt;b__0()
   at Microsoft.EntityFrameworkCore.Query.Internal.CompiledQueryCache.GetOrAddQuery[TResult](Object cacheKey, Func`1 compiler)
   at Microsoft.EntityFrameworkCore.Query.Internal.QueryCompiler.ExecuteAsync[TResult](Expression query, CancellationToken cancellationToken)
   at Microsoft.EntityFrameworkCore.Query.Internal.EntityQueryProvider.ExecuteAsync[TResult](Expression expression, CancellationToken cancellationToken)
   at Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.ExecuteAsync[TSource,TResult](MethodInfo operatorMethodInfo, IQueryable`1 source, Expression expression, CancellationToken cancellationToken)
   at Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.ExecuteAsync[TSource,TResult](MethodInfo operatorMethodInfo, IQueryable`1 source, CancellationToken cancellationToken)
   at Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.FirstAsync[TSource](IQueryable`1 source, CancellationToken cancellationToken)
   at Startup.Program.Main(String[] args) in Startup/Program.cs:line 52
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Include provider and version information&lt;/h3&gt;
&lt;p&gt;EF Core version: 6.0.9
Database provider: Pomelo.EntityFrameworkCore.MySql 6.0.2 and Microsoft.EntityFrameworkCore.Sqlite 6.0.9
Target framework: .NET 6.0
Operating system: Ubuntu 22.04
IDE: JetBrains Rider 2022.2.3&lt;/p&gt;
</description>
      <pubDate>Fri, 23 Sep 2022 11:35:51 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29186</guid>
      <link>https://github.com/dotnet/efcore/issues/29186</link>
      <title>Issue: Setting password in combination with other pragma fails - @rgroenewoudt</title>
      <description>&lt;p&gt;SQLite and SQLCipher have pragma's that need to be set before &amp;quot;normal&amp;quot; queries are executed.&lt;/p&gt;
&lt;p&gt;However when the password is set in the connection string, the &amp;quot;normal&amp;quot; query &lt;code&gt;SELECT COUNT(*) FROM sqlite_master;&lt;/code&gt; (SqliteConnectionInternal.cs:120) is executed, preventing execution of these special pragma.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;var builder = new SqliteConnectionStringBuilder
{
	DataSource = Path.GetTempFileName(),
	Cache = SqliteCacheMode.Private,
	Mode = SqliteOpenMode.ReadWriteCreate,
	Pooling = false,

	Password = Guid.NewGuid().ToString()
};

for(int i = 0; i &amp;lt; 2; i++)
{
	using var conn = new SqliteConnection(builder.ConnectionString);
	conn.Open(); // Fails 2nd time with Microsoft.Data.Sqlite.SqliteException: 'SQLite Error 26: 'file is not a database'.'

	using (var command = conn.CreateCommand())
	{
		command.CommandText = &amp;quot;PRAGMA cipher_kdf_algorithm = PBKDF2_HMAC_SHA256;&amp;quot;;
		command.ExecuteNonQuery();
	}

	using (var command = conn.CreateCommand())
	{
		command.CommandText = &amp;quot;PRAGMA journal_mode = WAL&amp;quot;;
		command.ExecuteNonQuery();
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/efcore/files/9633065/ConsoleApp11.zip"&gt;ConsoleApp11.zip&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A few pragma's need to be set before querying sqlite_master, for example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;journal_mode&lt;/li&gt;
&lt;li&gt;kdf_iter&lt;/li&gt;
&lt;li&gt;cipher_kdf_algorithm&lt;/li&gt;
&lt;li&gt;cipher_page_size&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It would be nicer if I can somehow define PRAGMAs in a SQLiteConnection before opening the connection. This would also work better with connection pooling because I don't have to manually execute the PRAGMA every time when opening a connection.&lt;/p&gt;
&lt;h3&gt;Include version information&lt;/h3&gt;
&lt;p&gt;Microsoft.Data.Sqlite version: 6.0.9
SQLitePCLRaw: 2.1.2
Target framework: .NET 6
Operating system: Windows &amp;amp; Android&lt;/p&gt;
</description>
      <pubDate>Fri, 23 Sep 2022 11:04:30 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29185</guid>
      <link>https://github.com/dotnet/efcore/issues/29185</link>
      <title>Issue: Calling SelectMay from VB throws InvalidOperationException - @kev160967</title>
      <description>&lt;p&gt;&lt;a href="https://github.com/dotnet/efcore/files/9632977/EFBug.zip"&gt;EFBug.zip&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;File a bug&lt;/h2&gt;
&lt;p&gt;There seems to be an issue with SelectMany when called from VB. The same queries work in C#. I've created an example using the Blogging database from &lt;a href="https://learn.microsoft.com/en-us/ef/core/get-started/overview/first-app?tabs=visual-studio"&gt;here&lt;/a&gt;. I've added a property Posts to the Blog object, which returns a collection of the posts associated with a blog&lt;/p&gt;
&lt;p&gt;I've attached a zipped solution that contains the VB project along with a file CreateDatabase.sql which will create the database and add a blog and two posts. The solution also contains a C# project that references the model defined in the VB project and executes the same query that fails in VB&lt;/p&gt;
&lt;p&gt;The following query gives an error in VB:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-VB"&gt;Dim posts = model.Blogs.Where(Function(x) x.BlogID = 1).SelectMany(Function(x) x.Posts).ToList()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The same query works in C#:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;var posts = session.Blogs.Where(x =&amp;gt; x.BlogID == 1).SelectMany(x =&amp;gt; x.Posts).ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Other variants on the query fail in the same way, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-VB"&gt;Dim posts = (From b In model.Blogs, p In b.Posts Where b.BlogID = 1 Select p).ToList()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The exception details are as follows&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.InvalidOperationException
  HResult=0x80131509
  Message=The LINQ expression 'x =&amp;gt; (IEnumerable&amp;lt;Post&amp;gt;)x.Posts' could not be translated. Either rewrite the query in a form that can be translated, or switch to client evaluation explicitly by inserting a call to 'AsEnumerable', 'AsAsyncEnumerable', 'ToList', or 'ToListAsync'. See https://go.microsoft.com/fwlink/?linkid=2101038 for more information.
  Source=Microsoft.EntityFrameworkCore
  StackTrace:
   at Microsoft.EntityFrameworkCore.Query.Internal.NavigationExpandingExpressionVisitor.ProcessSelectMany(NavigationExpansionExpression source, LambdaExpression collectionSelector, LambdaExpression resultSelector)
   at Microsoft.EntityFrameworkCore.Query.Internal.NavigationExpandingExpressionVisitor.VisitMethodCall(MethodCallExpression methodCallExpression)
   at System.Linq.Expressions.MethodCallExpression.Accept(ExpressionVisitor visitor)
   at System.Linq.Expressions.ExpressionVisitor.Visit(Expression node)
   at Microsoft.EntityFrameworkCore.Query.Internal.NavigationExpandingExpressionVisitor.Expand(Expression query)
   at Microsoft.EntityFrameworkCore.Query.QueryTranslationPreprocessor.Process(Expression query)
   at Microsoft.EntityFrameworkCore.Query.QueryCompilationContext.CreateQueryExecutor[TResult](Expression query)
   at Microsoft.EntityFrameworkCore.Query.Internal.QueryCompiler.&amp;lt;&amp;gt;c__DisplayClass9_0`1.&amp;lt;Execute&amp;gt;b__0()
   at Microsoft.EntityFrameworkCore.Query.Internal.CompiledQueryCache.GetOrAddQuery[TResult](Object cacheKey, Func`1 compiler)
   at Microsoft.EntityFrameworkCore.Query.Internal.QueryCompiler.Execute[TResult](Expression query)
   at Microsoft.EntityFrameworkCore.Query.Internal.EntityQueryable`1.GetEnumerator()
   at System.Collections.Generic.List`1..ctor(IEnumerable`1 collection)
   at System.Linq.Enumerable.ToList[TSource](IEnumerable`1 source)
   at EFBug.Program.Main(String[] args) in C:\Temp\Saturn\EFBug\Program.vb:line 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;EF Core version: 6.0
Database provider: Microsoft.EntityFrameworkCore.SqlServer
Target framework:  .NET 6.0
Operating system: Windows 10
IDE: Visual Studio 202 17.3.4&lt;/p&gt;
</description>
      <pubDate>Fri, 23 Sep 2022 10:48:06 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29183</guid>
      <link>https://github.com/dotnet/efcore/issues/29183</link>
      <title>Issue: One to many plus One to One with same entity - @dazinator</title>
      <description>&lt;p&gt;I'm having trouble working out if EF Core can do what I want. Basically I have defined a simple model, and queries seem to work, but when I try to insert the complete object graph in a single SaveChanges() call it fails. I can get the insert to work if I save changes first then update the nav property for the additional relationship, then save again.. but I can't do it all in one go.. let me explain..&lt;/p&gt;
&lt;p&gt;I have two entities and rather than just a &lt;code&gt;one to many relationship&lt;/code&gt; between them as is often the case, I have:&lt;/p&gt;
&lt;p&gt;An &lt;code&gt;Office&lt;/code&gt; can have many &lt;code&gt;Person&lt;/code&gt;s, &lt;code&gt;Person&lt;/code&gt;s must have an office (one to many)
An &lt;code&gt;Office&lt;/code&gt; can also have one of those &lt;code&gt;Person&lt;/code&gt;s be the important Office Person. (one to one)&lt;/p&gt;
&lt;p&gt;I'm using different noun's here, but the basic need for this type of model arose because, where there are several million offices, ,and offices have several hundred people, being able to mark one of those people as the &amp;quot;special office person&amp;quot; - means either having a flag at the person level (and means removing the flag and setting it on another person each time the special person changes) or involves storing the id of the special person on the office record itself as a nullable FK relationship - which is the route I chose to go - because that should also make it easier to query - i.e join from office to the special people directly on Office.PersonId rather than joining to all people at the office (based on Person.OfficeId) then filtering for the one person that is marked as special (e.g so these are performance concerns)&lt;/p&gt;
&lt;p&gt;Here is my fluent config for &lt;code&gt;Office&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt; builder.HasMany(d =&amp;gt; d.Persons) // office has persons (one to many)
              .WithOne(s =&amp;gt; s.Office) 
              .HasForeignKey(a =&amp;gt; a.OfficeId); 

            builder.HasOne(d =&amp;gt; d.Person) // the one person that is special for this office.
              .WithOne() // must avoid using nav property in more than one relationship else ef throws.
              .HasForeignKey&amp;lt;Office&amp;gt;(a =&amp;gt; a.PersonId);

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;public class Office
{
    public virtual int Id { get; set; }
    public virtual HashSet&amp;lt;Person&amp;gt; Persons { get; set; } = new HashSet&amp;lt;Person&amp;gt;();
    public Person? Person { get; set; }
    public int? PersonId { get; set; }    
}

public class Person
{
    public virtual int Id { get; set; }
    public int OfficeId { get; set; }
    public virtual Office Office { get; set; }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So the problem I have is that when I attempt to create  a new Office, new Person, and add that Person to the Office.Persons, as well as set that person as the Office.Person, then call SaveChanges() I get this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.InvalidOperationException : Unable to save changes because a circular dependency was detected in the data to be saved: 'Office { 'Id': -2147482647 } [Added] &amp;lt;-
Persons { 'OfficeId': -2147482647 } Person { 'Id': -2147482647 } [Added] &amp;lt;-
Person { 'PersonId': -2147482647 } Office { 'Id': -2147482647 } [Added]'.

  Stack Trace: 
Multigraph`2.ThrowCycle(List`1 cycle, Func`2 formatCycle, Func`2 formatException)
Multigraph`2.BatchingTopologicalSort(Func`4 tryBreakEdge, Func`2 formatCycle)
CommandBatchPreparer.TopologicalSort(IEnumerable`1 commands)
CommandBatchPreparer.BatchCommands(IList`1 entries, IUpdateAdapter updateAdapter)+MoveNext()
BatchExecutor.Execute(IEnumerable`1 commandBatches, IRelationalConnection connection)
RelationalDatabase.SaveChanges(IList`1 entries)
StateManager.SaveChanges(IList`1 entriesToSave)
StateManager.SaveChanges(StateManager stateManager, Boolean acceptAllChangesOnSuccess)
&amp;lt;&amp;gt;c.&amp;lt;SaveChanges&amp;gt;b__104_0(DbContext _, ValueTuple`2 t)
&amp;lt;&amp;gt;c__DisplayClass31_0`2.&amp;lt;Execute&amp;gt;b__0(DbContext context, TState state)
ExecutionStrategy.ExecuteImplementation[TState,TResult](Func`3 operation, Func`3 verifySucceeded, TState state)
ExecutionStrategy.Execute[TState,TResult](TState state, Func`3 operation, Func`3 verifySucceeded)
StateManager.SaveChanges(Boolean acceptAllChangesOnSuccess)
DbContext.SaveChanges(Boolean acceptAllChangesOnSuccess)
BaseMultitenantDbContext`3.SaveChanges(Boolean acceptAllChangesOnSuccess) line 52
DbContext.SaveChanges()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I get the same error even if I remove the navigation property &amp;quot;Office&amp;quot; from the &amp;quot;Person&amp;quot; class. (keeping the relationships configured exactly the same just without the explicit navigation property).&lt;/p&gt;
&lt;p&gt;I can work around this problem like so:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create the office, and the person, and add the Person to Office.Persons but don't set Office.Person. Call SaveChanges() - this inserts the office and the person, but Office.PersonId remains null. Then set Office.Person and call SaveChanges() again. This time it works.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So there is a need for me to call SaveChanges twice. I'm trying to insert a large amount of Offices here, so after the initial SaveChanges I basically have to loop back through all the data to set this nav property then call SaveChanges again - its not ideal.&lt;/p&gt;
&lt;p&gt;Is there a better way?&lt;/p&gt;
</description>
      <pubDate>Thu, 22 Sep 2022 22:07:07 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29182</guid>
      <link>https://github.com/dotnet/efcore/issues/29182</link>
      <title>Issue: Unnecessary joins in split queries causing performance issues - @stevendarby</title>
      <description>&lt;p&gt;If I include both reference navigations and collection navigations in a query and execute with &lt;code&gt;AsSplitQuery&lt;/code&gt; then joins to the reference navigations are present in all of the collection queries. This doesn't appear to be necessary and can slow down the query significantly if there are multiple reference navigations.&lt;/p&gt;
&lt;p&gt;Repro:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

{
    using var context = new MyContext();

    if (context.Database.EnsureCreated())
    {
        var blogType = new BlogType { Type = &amp;quot;Development&amp;quot; };
        var blog = new Blog { Name = &amp;quot;EF&amp;quot;, BlogType = blogType };
        var post = new Post { Title = &amp;quot;Split Query&amp;quot;, Blog = blog };

        context.AddRange(blogType, blog, post);
        context.SaveChanges();
    }
}
{
    using var context = new MyContext();
    var result = context.Blogs
        .Include(x =&amp;gt; x.BlogType)
        .Include(x =&amp;gt; x.Posts)
        .AsSplitQuery()
        .ToList();
}

public class MyContext : DbContext
{
    public DbSet&amp;lt;Blog&amp;gt; Blogs { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        =&amp;gt; optionsBuilder
            .UseSqlServer(&amp;quot;Server=.;Database=Split;Trusted_Connection=True;Encrypt=False&amp;quot;)
            .LogTo(Console.WriteLine, LogLevel.Information);
}

public class Blog
{
    public int Id { get; set; }
    public string Name { get; set; }
    public int BlogTypeId { get; set; }
    public BlogType BlogType { get; set; }
    public ICollection&amp;lt;Post&amp;gt; Posts { get; set; }
}

public class Post
{
    public int Id { get; set; }
    public string Title { get; set; }
    public int BlogId { get; set; }
    public Blog Blog { get; set; }
}

public class BlogType
{
    public int Id { get; set; }
    public string Type { get; set; }
    public ICollection&amp;lt;Blog&amp;gt; Blogs { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Produces this SQL:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-SQL"&gt;SELECT [b].[Id], [b].[BlogTypeId], [b].[Name], [b0].[Id], [b0].[Type]
FROM [Blogs] AS [b]
INNER JOIN [BlogType] AS [b0] ON [b].[BlogTypeId] = [b0].[Id]
ORDER BY [b].[Id], [b0].[Id]

SELECT [p].[Id], [p].[BlogId], [p].[Title], [b].[Id], [b0].[Id]
FROM [Blogs] AS [b]
INNER JOIN [BlogType] AS [b0] ON [b].[BlogTypeId] = [b0].[Id]
INNER JOIN [Post] AS [p] ON [b].[Id] = [p].[BlogId]
ORDER BY [b].[Id], [b0].[Id]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I believe the second query could simply be:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-SQL"&gt;SELECT [p].[Id], [p].[BlogId], [p].[Title], [b].[Id]
FROM [Blogs] AS [b]
INNER JOIN [Post] AS [p] ON [b].[Id] = [p].[BlogId]
ORDER BY [b].[Id]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The reduced joins, and reduced fields selected and in the order by, would improve the query plan. I don't think the BlogType ID is required to match the Posts up to the Blog.&lt;/p&gt;
&lt;p&gt;Note that in this example, I am just using a single reference navigation, but when multiple are included, joins to all of them are repeated in each collection query and this begins to really impact the performance.&lt;/p&gt;
&lt;p&gt;Same behaviour also occurs in non-entity projection and split query.&lt;/p&gt;
</description>
      <pubDate>Thu, 22 Sep 2022 19:26:39 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29177</guid>
      <link>https://github.com/dotnet/efcore/issues/29177</link>
      <title>Issue: Add FormattableString FromSql to Cosmos - @roji</title>
      <description>&lt;p&gt;We currently have only FromSqlRaw for Cosmos, because when we implemented Cosmos SQL queries we were skeptical of FormattableString. Since then, we've added a suffix-less FromSql that accepts FormattableString (#27831), we should do the same for Cosmos. That would make Cosmos align with relational, except for the lack of the now-redundant FromSqlInterpolated.&lt;/p&gt;
&lt;p&gt;We should consider doing this for 7.0.&lt;/p&gt;
</description>
      <pubDate>Wed, 21 Sep 2022 12:58:19 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29175</guid>
      <link>https://github.com/dotnet/efcore/issues/29175</link>
      <title>Issue: Query filter in including relation - @orlicekm</title>
      <description>&lt;p&gt;I tried to implement soft delete using query filter, but my query filters aren't applied in include relations. Multiple articles and Microsoft docs say that it should be.
&lt;a href="https://learn.microsoft.com/en-us/ef/core/querying/filters"&gt;https://learn.microsoft.com/en-us/ef/core/querying/filters&lt;/a&gt;
&lt;a href="https://www.thereformedprogrammer.net/ef-core-in-depth-soft-deleting-data-with-global-query-filters"&gt;https://www.thereformedprogrammer.net/ef-core-in-depth-soft-deleting-data-with-global-query-filters&lt;/a&gt;
&lt;a href="https://www.meziantou.net/entity-framework-core-soft-delete-using-query-filters.htm"&gt;https://www.meziantou.net/entity-framework-core-soft-delete-using-query-filters.htm&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Code sample&lt;/h3&gt;
&lt;p&gt;Here is simple test that fails:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;using Microsoft.Data.Sqlite;
using Microsoft.EntityFrameworkCore;
using Xunit;
using Xunit.Abstractions;

namespace TestSoftDelete.Tests;

public class SoftDeleteTest
{
    private readonly SqliteConnection _connection;
    private readonly DbContextOptions _options;
    private readonly ITestOutputHelper _testOutputHelper;

    public SoftDeleteTest(ITestOutputHelper testOutputHelper)
    {
        _testOutputHelper = testOutputHelper;
        _connection = new SqliteConnection(&amp;quot;datasource=:memory:&amp;quot;);
        _connection.Open();

        _options = new DbContextOptionsBuilder()
            .UseSqlite(_connection)
            .Options;

        using var context = new BloggingContext(_options);
        context.Database.EnsureCreated();
    }

    [Fact]
    public void Test()
    {
        using var dbContext = new BloggingContext(_options);

        var post = new Post();
        var blog = new Blog
        {
            Posts = new List&amp;lt;Post&amp;gt;
            {
                post
            }
        };

        dbContext.Blogs.Add(blog);
        dbContext.SaveChanges();

        _testOutputHelper.WriteLine(dbContext.Blogs.Include(_ =&amp;gt; _.Posts).ToQueryString());

        Assert.True(dbContext.Posts.Any()); //this is ok
        Assert.True(dbContext.Blogs.Include(_ =&amp;gt; _.Posts).First().Posts.Any()); //this is ok

        post.IsDeleted = true;
        dbContext.Posts.Update(post);
        dbContext.SaveChanges();
        
        Assert.False(dbContext.Posts.Any()); //this is ok
        Assert.False(dbContext.Blogs.Include(_ =&amp;gt; _.Posts).First().Posts.Any()); //this fails
    }
}

public class Blog
{
    public int BlogId { get; set; }
    public bool IsDeleted { get; set; }
    public List&amp;lt;Post&amp;gt; Posts { get; set; }
}

public class Post
{
    public int PostId { get; set; }
    public bool IsDeleted { get; set; }

    public int BlogId { get; set; }
    public Blog Blog { get; set; }
}

public class BloggingContext : DbContext
{
    public BloggingContext(DbContextOptions options) : base(options)
    {
    }

    public DbSet&amp;lt;Blog&amp;gt; Blogs { get; set; }
    public DbSet&amp;lt;Post&amp;gt; Posts { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity&amp;lt;Blog&amp;gt;().HasQueryFilter(p =&amp;gt; !p.IsDeleted);
        modelBuilder.Entity&amp;lt;Post&amp;gt;().HasQueryFilter(p =&amp;gt; !p.IsDeleted);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However when I run the SQL query from example manually, it works fine. Query:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-SQL"&gt;SELECT &amp;quot;b&amp;quot;.&amp;quot;BlogId&amp;quot;, &amp;quot;b&amp;quot;.&amp;quot;IsDeleted&amp;quot;, &amp;quot;t&amp;quot;.&amp;quot;PostId&amp;quot;, &amp;quot;t&amp;quot;.&amp;quot;BlogId&amp;quot;, &amp;quot;t&amp;quot;.&amp;quot;IsDeleted&amp;quot;
FROM &amp;quot;Blogs&amp;quot; AS &amp;quot;b&amp;quot;
LEFT JOIN (
    SELECT &amp;quot;p&amp;quot;.&amp;quot;PostId&amp;quot;, &amp;quot;p&amp;quot;.&amp;quot;BlogId&amp;quot;, &amp;quot;p&amp;quot;.&amp;quot;IsDeleted&amp;quot;
    FROM &amp;quot;Posts&amp;quot; AS &amp;quot;p&amp;quot;
    WHERE NOT (&amp;quot;p&amp;quot;.&amp;quot;IsDeleted&amp;quot;)
) AS &amp;quot;t&amp;quot; ON &amp;quot;b&amp;quot;.&amp;quot;BlogId&amp;quot; = &amp;quot;t&amp;quot;.&amp;quot;BlogId&amp;quot;
WHERE NOT (&amp;quot;b&amp;quot;.&amp;quot;IsDeleted&amp;quot;)
ORDER BY &amp;quot;b&amp;quot;.&amp;quot;BlogId&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Provider and version information&lt;/h3&gt;
&lt;p&gt;EF Core version: 6.0.9
Database provider: Microsoft.EntityFrameworkCore.Sqlite (also tried in-memory, mysql)
Target framework: .NET 6.0
Operating system: Windows 11
IDE: Visual Studio 2022&lt;/p&gt;
</description>
      <pubDate>Wed, 21 Sep 2022 10:02:11 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29174</guid>
      <link>https://github.com/dotnet/efcore/issues/29174</link>
      <title>Issue: Consider doing split query on a reference navigation if the other side is a collection - @roji</title>
      <description>&lt;p&gt;We currently support split query on collection navigations:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;_ = await ctx.Blogs.Include(b =&amp;gt; b.Posts).AsSplitQuery().ToListAsync();
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT [b].[Id], [b].[Name]
FROM [Blogs] AS [b]
ORDER BY [b].[Id]

SELECT [p].[PostId], [p].[BlogId], [p].[Title], [b].[Id]
FROM [Blogs] AS [b]
INNER JOIN [Posts] AS [p] ON [b].[Id] = [p].[BlogId]
ORDER BY [b].[Id]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, if the query is flipped around and starts with the Posts, we do not:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;_ = await ctx.Posts.Include(p =&amp;gt; p.Blog).AsSplitQuery().ToListAsync();
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT [p].[PostId], [p].[BlogId], [p].[Title], [b].[Id], [b].[Name]
FROM [Posts] AS [p]
LEFT JOIN [Blogs] AS [b] ON [p].[BlogId] = [b].[Id]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is because the Post.Blog navigation is a reference navigation. However, the single query we produce has the same &amp;quot;cartesian explosion&amp;quot; effect that split queries were designed to solve: each Post row contains and duplicates the details of the Blog.&lt;/p&gt;
&lt;p&gt;We could perform the above as a split query, doing so whenever either the navigation &lt;em&gt;or its reverse navigation&lt;/em&gt; is a collection navigation.&lt;/p&gt;
</description>
      <pubDate>Wed, 21 Sep 2022 09:04:15 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29171</guid>
      <link>https://github.com/dotnet/efcore/issues/29171</link>
      <title>Issue: Investigate single query related entity loading and orderings - @roji</title>
      <description>&lt;p&gt;When loading related entities in single query mode, our query pipeline currently injects orderings which make all related rows be grouped together. Our shaper relies on this ordering for assigning the related dependents to their correct principal. This issue is about investigating removing those orderings, and using client-side dictionary (or identity) lookups to find the principal instead.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Orderings generally impact query planning in a significant way, and require the database to do a lot of work. We've received quite a few user reports about these orderings; we still need to investigate this thoroughly, but it makes sense that the orderings would regress perf significantly in various scenarios.&lt;/li&gt;
&lt;li&gt;In general, we should strive to remove as much load from the database, even at the cost of running slower at the client, since the database tier is far harder to scale than the application tier. The orderings effectively do the opposite, pushing more work down to the database.&lt;/li&gt;
&lt;li&gt;One argument in favor of ordering is that it allows EF to stream the results, since all rows related to a principal are grouped together. If we remove the orderings, EF can't return a single principal before it consumes all rows, since there may be another dependent row at the end.&lt;/li&gt;
&lt;li&gt;However, orderings prevent the &lt;strong&gt;database&lt;/strong&gt; from streaming results back; we're basically pushing the buffering back to the server, increasing memory requirements there (as above, we should be doing the opposite and unloading the database).&lt;/li&gt;
&lt;li&gt;This also negatively affects the latency of results, as the database starts sending rows back later. Removing the orderings would allow the database to return rows earlier, allowing EF to return rows to the user earlier.&lt;/li&gt;
&lt;li&gt;We've &lt;a href="https://github.com/dotnet/efcore/issues/20076"&gt;raised the possibility&lt;/a&gt; of using identity resolution as a substitute for the orderings (but only if the queries are identified as buffering in some way). Depending on the perf impact, I think we should consider always doing this, in any case. This would effectively mean that NoTracking queries become NoTrackingWithIdentity.&lt;/li&gt;
&lt;li&gt;We may want to do the same for final GroupBy, which also injects orderings (&lt;a href="https://github.com/dotnet/efcore/issues/19929"&gt;#19929&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thanks @NinoFloris for the conversation around this.&lt;/p&gt;
&lt;p&gt;Issues on this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/efcore/issues/19571"&gt;#19571&lt;/a&gt;: previous issue where removing the orderings was discussed.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/efcore/issues/20076"&gt;#20076&lt;/a&gt;: discussed distinguishing between buffering and streaming queries, and proposes removing tracking only for queries which are both buffering and tracking (via identity resolution).&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/efcore/issues/19828"&gt;#19828&lt;/a&gt;: issue for removing only the last ordering (done)&lt;/li&gt;
&lt;/ul&gt;
</description>
      <pubDate>Tue, 20 Sep 2022 19:03:40 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29169</guid>
      <link>https://github.com/dotnet/efcore/issues/29169</link>
      <title>Issue: Explicit configuration of a TPT relationship causes the database constraint not to be created - @ajcvickers</title>
      <description>&lt;p&gt;Consider the simple TPT model:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;[Table(&amp;quot;FeaturedPosts&amp;quot;)]
public class FeaturedPost : Post
{
}

[Table(&amp;quot;Posts&amp;quot;)]
public class Post
{
    public int Id { get; set; }
    public string? Title { get; set; }
    public string? Content { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This results in the following tables:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;      CREATE TABLE [Posts] (
          [Id] int NOT NULL IDENTITY,
          [Title] nvarchar(max) NULL,
          [Content] nvarchar(max) NULL,
          CONSTRAINT [PK_Posts] PRIMARY KEY ([Id])
      );

      CREATE TABLE [FeaturedPosts] (
          [Id] int NOT NULL,
          CONSTRAINT [PK_FeaturedPosts] PRIMARY KEY ([Id]),
          CONSTRAINT [FK_FeaturedPosts_Posts_Id] FOREIGN KEY ([Id]) REFERENCES [Posts] ([Id]) ON DELETE CASCADE
      );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I want to change the cascade behavior for the FK constraint between the two tables, so I do this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;modelBuilder
    .Entity&amp;lt;Post&amp;gt;()
    .HasOne&amp;lt;FeaturedPost&amp;gt;()
    .WithOne()
    .HasForeignKey&amp;lt;FeaturedPost&amp;gt;(e =&amp;gt; e.Id)
    .OnDelete(DeleteBehavior.ClientCascade);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now the FK constraint disappears entirely!&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;      CREATE TABLE [FeaturedPosts] (
          [Id] int NOT NULL IDENTITY,
          CONSTRAINT [PK_FeaturedPosts] PRIMARY KEY ([Id])
      );

      CREATE TABLE [Posts] (
          [Id] int NOT NULL IDENTITY,
          [Title] nvarchar(max) NULL,
          [Content] nvarchar(max) NULL,
          CONSTRAINT [PK_Posts] PRIMARY KEY ([Id])
      );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Full code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;[Table(&amp;quot;FeaturedPosts&amp;quot;)]
public class FeaturedPost : Post
{
}

[Table(&amp;quot;Posts&amp;quot;)]
public class Post
{
    public int Id { get; set; }
    public string? Title { get; set; }
    public string? Content { get; set; }
}

public class SomeDbContext : DbContext
{
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        =&amp;gt; optionsBuilder
            .UseSqlServer(Your.ConnectionString)
            .LogTo(Console.WriteLine, LogLevel.Information)
            .EnableSensitiveDataLogging();

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder
            .Entity&amp;lt;Post&amp;gt;()
            .HasOne&amp;lt;FeaturedPost&amp;gt;()
            .WithOne()
            .HasForeignKey&amp;lt;FeaturedPost&amp;gt;(e =&amp;gt; e.Id)
            .OnDelete(DeleteBehavior.ClientCascade);
        
        modelBuilder.Entity&amp;lt;FeaturedPost&amp;gt;();
    }
}

public class Program
{
    public static void Main()
    {
        using (var context = new SomeDbContext())
        {
            context.Database.EnsureDeleted();
            context.Database.EnsureCreated();

            context.Add(new Post());
            context.Add(new FeaturedPost());
            
            context.SaveChanges();
        }
        
        using (var context = new SomeDbContext())
        {
            foreach (var post in context.Set&amp;lt;Post&amp;gt;().ToList())
            {
                Console.WriteLine(post.GetType());
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Tue, 20 Sep 2022 18:02:56 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29167</guid>
      <link>https://github.com/dotnet/efcore/issues/29167</link>
      <title>Issue: Running into Segmentation fault on Ubuntu 20.04.5 LTS when using NetTopology and Sqlite.  - @Procrastinatorhater</title>
      <description>&lt;p&gt;I cant seem to use the NetTopology package with Sqlite on newer Ubuntu versions. I have been using Ubuntu 18.04 LTS for some time, but a segmentation fault is preventing me from updating to 20.04 or 22.04.&lt;/p&gt;
&lt;p&gt;On the test machines I manually install the following package(s):
sudo apt-get install libc6-dev - used by another dependency in production systems, but not required for reproducing issue.
sudo apt-get install libsqlite3-mod-spatialite&lt;/p&gt;
&lt;p&gt;Without the libsqlite3-mod-spatialite I run into the following exception. AGAIN THIS IS NOT THE ERROR I AM TRYING TO FIX - INCLUDED ONLY FOR FULL DISCLOSURE. ONLY HAPPENS WHEN I DONT MANUALLY INSTALL PACKAGE .&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Unhandled exception. Microsoft.Data.Sqlite.SqliteException (0x80004005): SQLite Error 1: 'mod_spatialite.so: cannot open shared object file: No such file or directory'.
   at Microsoft.Data.Sqlite.SqliteException.ThrowExceptionForRC(Int32 rc, sqlite3 db)
   at Microsoft.Data.Sqlite.SqliteDataReader.NextResult()
   at Microsoft.Data.Sqlite.SqliteCommand.ExecuteReader(CommandBehavior behavior)
   at Microsoft.Data.Sqlite.SqliteCommand.ExecuteReader()
   at Microsoft.Data.Sqlite.SqliteCommand.ExecuteNonQuery()
   at Microsoft.Data.Sqlite.SqliteConnectionExtensions.ExecuteNonQuery(SqliteConnection connection, String commandText, SqliteParameter[] parameters)
   at Microsoft.Data.Sqlite.SqliteConnection.LoadExtensionCore(String file, String proc)
   at Microsoft.Data.Sqlite.SqliteConnection.Open()
   at Microsoft.EntityFrameworkCore.Storage.RelationalConnection.OpenDbConnection(Boolean errorsExpected)
   at Microsoft.EntityFrameworkCore.Storage.RelationalConnection.OpenInternal(Boolean errorsExpected)
   at Microsoft.EntityFrameworkCore.Storage.RelationalConnection.Open(Boolean errorsExpected)
   at Microsoft.EntityFrameworkCore.Storage.RelationalCommand.ExecuteScalar(RelationalCommandParameterObject parameterObject)
   at Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal.SqliteDatabaseCreator.HasTables()
   at Microsoft.EntityFrameworkCore.Storage.RelationalDatabaseCreator.EnsureCreated()
   at Microsoft.EntityFrameworkCore.Infrastructure.DatabaseFacade.EnsureCreated()
   at Program.&amp;lt;Main&amp;gt;$(String[] args)
Aborted (core dumped)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Have tested:
Ubuntu 18.04 (LTS) - success
Ubuntu 20.04 (LTS) - segmentation fault.
Ubuntu 22.04 (LTS) - segmenation fault.&lt;/p&gt;
&lt;p&gt;No errors, program just exits:
https://www.dropbox.com/s/w56t29we7erikhz/SegmentationFault.png?dl=0&lt;/p&gt;
&lt;p&gt;I have a simple .Net 6 console project setup for a reproducible test.&lt;/p&gt;
&lt;p&gt;Project has the following dependencies defined: Have tried all versions from 5.0.17 to 7.0.0-rc.1.22426.7&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;ItemGroup&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.EntityFrameworkCore.Design&amp;quot; Version=&amp;quot;7.0.0-rc.1.22426.7&amp;quot;&amp;gt;
      &amp;lt;PrivateAssets&amp;gt;all&amp;lt;/PrivateAssets&amp;gt;
      &amp;lt;IncludeAssets&amp;gt;runtime; build; native; contentfiles; analyzers; buildtransitive&amp;lt;/IncludeAssets&amp;gt;
    &amp;lt;/PackageReference&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.EntityFrameworkCore.Relational&amp;quot; Version=&amp;quot;7.0.0-rc.1.22426.7&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.EntityFrameworkCore.Sqlite&amp;quot; Version=&amp;quot;7.0.0-rc.1.22426.7&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.EntityFrameworkCore.Sqlite.NetTopologySuite&amp;quot; Version=&amp;quot;7.0.0-rc.1.22426.7&amp;quot; /&amp;gt;

    &amp;lt;!-- When testing packages before 6.0 the following is also required --&amp;gt;
    &amp;lt;!--&amp;lt;PackageReference Include=&amp;quot;SQLitePCLRaw.bundle_e_sqlite3&amp;quot; Version=&amp;quot;2.1.2&amp;quot; /&amp;gt; --&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Program.cs creates context via helper, ensures schema was created and inserts 50 dummy records into a basic table.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;using Microsoft.Data.Sqlite;

string filePath = &amp;quot;database.db&amp;quot;;

SqliteConnectionStringBuilder scb = new SqliteConnectionStringBuilder()
{
    Pooling = false,
    DataSource = filePath
};

using (TestDataContext context = LocalContextFactory.CreateContext&amp;lt;TestDataContext&amp;gt;(scb.ConnectionString))
{
    context.Database.EnsureCreated();

    for (int i = 0; i &amp;lt; 50; i++)
    {
        Guid id = Guid.NewGuid();
        context.ObjectData.Add(new ObjectData() { ObjectUniqueId = id, Name = $&amp;quot;{id}&amp;quot; });
    }

    context.SaveChanges();
}

Console.WriteLine(&amp;quot;Success&amp;quot;); //never gets here on newer Ubuntu versions. 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Context has 2 entities defined:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;using Microsoft.EntityFrameworkCore;

public class TestDataContext : DbContext
{
    public TestDataContext()
    {
    }

    public TestDataContext(DbContextOptions&amp;lt;TestDataContext&amp;gt; options) : base(options)
    {
    }

    public virtual DbSet&amp;lt;ObjectData&amp;gt; ObjectData { get; set; }
    public virtual DbSet&amp;lt;GeometryData&amp;gt; GeometryData { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity&amp;lt;ObjectData&amp;gt;(x =&amp;gt; {
            x.HasKey(e =&amp;gt; e.ObjectUniqueId);
            x.Property(p =&amp;gt; p.ObjectUniqueId)
                .HasConversion(s =&amp;gt; s.ToString(), s =&amp;gt; new System.Guid(s));
        });

        modelBuilder.Entity&amp;lt;GeometryData&amp;gt;(x =&amp;gt; {
            x.HasKey(e =&amp;gt; e.ObjectUniqueId);
            x.Property(p =&amp;gt; p.Geometry).HasSrid(4326);
            x.Property(p =&amp;gt; p.ObjectUniqueId)
                .HasConversion(s =&amp;gt; s.ToString(), s =&amp;gt; new System.Guid(s));
        });

        base.OnModelCreating(modelBuilder);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And those entities look like so:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;using System.ComponentModel.DataAnnotations.Schema;

[Table(&amp;quot;geometry_data&amp;quot;)]
public class GeometryData
{

    [Column(&amp;quot;object_unique_id&amp;quot;)]
    public System.Guid ObjectUniqueId { get; set; }

    [Column(&amp;quot;geometry_type_id&amp;quot;)]
    public System.Int32 GeometryTypeId { get; set; }

    [Column(&amp;quot;geometry&amp;quot;)]
    public NetTopologySuite.Geometries.Geometry Geometry { get; set; }

}

[Table(&amp;quot;object_data&amp;quot;)]
public class ObjectData
{

    [Column(&amp;quot;object_unique_id&amp;quot;)]
    public System.Guid ObjectUniqueId { get; set; }

    [Column(&amp;quot;object_name&amp;quot;)]
    public string Name { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I have a helper class for creating a local Sqlite dbContext with NetTopology enabled - This is only used in testing since I dont want to setup DI and bring in additional dependencies in test project:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static class LocalContextFactory
{
    public static TContext CreateContext&amp;lt;TContext&amp;gt;(string connectionString, bool useNetTopologyProvider = true) where TContext : DbContext
    {
        DbContextOptionsBuilder&amp;lt;TContext&amp;gt; optionsBuilder = new DbContextOptionsBuilder&amp;lt;TContext&amp;gt;();
        optionsBuilder.UseSqlite(connectionString, sqliteDbContextOptionBuilder =&amp;gt;
        {
            if (useNetTopologyProvider)
            {
                sqliteDbContextOptionBuilder.UseNetTopologySuite();
            }
        });

        TContext context = Activator.CreateInstance(typeof(TContext), optionsBuilder.Options) as TContext;

        return context;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Tue, 20 Sep 2022 17:18:07 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29166</guid>
      <link>https://github.com/dotnet/efcore/issues/29166</link>
      <title>Issue: Microsoft.EntityFrameworkCore.DbUpdateConcurrencyException - @LedgendODST</title>
      <description>&lt;p&gt;ok so my EF Core suddently stopped working when updating Microsoft.EntityFramework.Tools, Design to 7.0.0-rc.1.22426.7 and i am using the Postgres SQL provider which is updated to 7.0.0-rc.1...   i am using the same modals as i had on the lasted updated and i thought the DB was beging weird so i created a new Table and the problem is still, it seems to be working with some modal classes but not my main ones
My Modal Class https://pastebin.com/iHWN54Fh
i have a method directly into my Context that checks if the member is added or not&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;    public async Task&amp;lt;KurumiMember&amp;gt; GetOrAddMemberAsync(Snowflake guildId, Snowflake memberId)
    {
        KurumiMember? member = await GetMemberAsync(guildId, memberId);

        if (member is not null)
            return member;

        member = new(guildId, memberId);
        
        return member;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Microsoft.EntityFrameworkCore.DbUpdateConcurrencyException: The database operation was expected to affect 1 row(s), but actually affected 0 row(s); data may have been modified or deleted since entities were loaded. See http://go.microsoft.com/fwlink/?LinkId=527962 for information on understanding and handling optimistic concurrency exceptions.
   at Npgsql.EntityFrameworkCore.PostgreSQL.Update.Internal.NpgsqlModificationCommandBatch.ThrowAggregateUpdateConcurrencyExceptionAsync(RelationalDataReader reader, Int32 commandIndex, Int32 expectedRowsAffected, Int32 rowsAffected, CancellationToken cancellationToken)
   at Npgsql.EntityFrameworkCore.PostgreSQL.Update.Internal.NpgsqlModificationCommandBatch.ConsumeAsync(RelationalDataReader reader, CancellationToken cancellationToken)
   at Microsoft.EntityFrameworkCore.Update.ReaderModificationCommandBatch.ExecuteAsync(IRelationalConnection connection, CancellationToken cancellationToken)
   at Microsoft.EntityFrameworkCore.Update.ReaderModificationCommandBatch.ExecuteAsync(IRelationalConnection connection, CancellationToken cancellationToken)
   at Microsoft.EntityFrameworkCore.Update.Internal.BatchExecutor.ExecuteAsync(IEnumerable`1 commandBatches, IRelationalConnection connection, CancellationToken cancellationToken)
   at Microsoft.EntityFrameworkCore.Update.Internal.BatchExecutor.ExecuteAsync(IEnumerable`1 commandBatches, IRelationalConnection connection, CancellationToken cancellationToken)
   at Microsoft.EntityFrameworkCore.Update.Internal.BatchExecutor.ExecuteAsync(IEnumerable`1 commandBatches, IRelationalConnection connection, CancellationToken cancellationToken)
   at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.SaveChangesAsync(IList`1 entriesToSave, CancellationToken cancellationToken)
   at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.SaveChangesAsync(StateManager stateManager, Boolean acceptAllChangesOnSuccess, CancellationToken cancellationToken)
   at Npgsql.EntityFrameworkCore.PostgreSQL.Storage.Internal.NpgsqlExecutionStrategy.ExecuteAsync[TState,TResult](TState state, Func`4 operation, Func`4 verifySucceeded, CancellationToken cancellationToken)
   at Microsoft.EntityFrameworkCore.DbContext.SaveChangesAsync(Boolean acceptAllChangesOnSuccess, CancellationToken cancellationToken)
   at Microsoft.EntityFrameworkCore.DbContext.SaveChangesAsync(Boolean acceptAllChangesOnSuccess, CancellationToken cancellationToken)
   at KurumiBot.Services.InteractionsService.SetPartnerAsync(Snowflake guildId, Snowflake memberId, Snowflake partnerId) in C:\Users\Tim\RiderProjects\kurumi-bot\src\KurumiBot\Services\InteractionsService.cs:line 243
   at KurumiBot.Services.InteractionsService.SetPartnerAsync(Snowflake guildId, Snowflake memberId, Snowflake partnerId) in C:\Users\Tim\RiderProjects\kurumi-bot\src\KurumiBot\Services\InteractionsService.cs:line 244
   at KurumiBot.Services.InteractionsService.SetPartnerAsync(Snowflake guildId, Snowflake memberId, Snowflake partnerId) in C:\Users\Tim\RiderProjects\kurumi-bot\src\KurumiBot\Services\InteractionsService.cs:line 245
   at KurumiBot.Commands.Modules.TextModules.UserInteractionModule.MarryAsync(IMember partner) in C:\Users\Tim\RiderProjects\kurumi-bot\src\KurumiBot\Commands\Modules\TextModules\UserInteractionModule.cs:line 145
   at Qmmands.ReflectionCommandCallback.ExecuteAsync(ICommandContext context)
   at Qmmands.ReflectionCommandCallback.ExecuteAsync(ICommandContext context)
   at Qmmands.Default.DefaultExecutionSteps.ExecuteCommand.OnExecuted(ICommandContext context)

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;PS C:\Users\Tim\RiderProjects\kurumi-bot\src\KurumiBot&amp;gt; dotnet ef dbcontext list --verbose
Using project 'C:\Users\Tim\RiderProjects\kurumi-bot\src\KurumiBot\KurumiBot.csproj'.
Using startup project 'C:\Users\Tim\RiderProjects\kurumi-bot\src\KurumiBot\KurumiBot.csproj'.
Writing 'C:\Users\Tim\RiderProjects\kurumi-bot\src\KurumiBot\obj\KurumiBot.csproj.EntityFrameworkCore.targets'...
dotnet msbuild /target:GetEFProjectMetadata /property:EFProjectMetadataFile=C:\Users\Tim\AppData\Local\Temp\tmp12F1.tmp /verbosity:quiet /nologo C:\Users\Tim\RiderProjects\kurumi-bot\src\KurumiBot\KurumiBot.csproj
Writing 'C:\Users\Tim\RiderProjects\kurumi-bot\src\KurumiBot\obj\KurumiBot.csproj.EntityFrameworkCore.targets'...
dotnet msbuild /target:GetEFProjectMetadata /property:EFProjectMetadataFile=C:\Users\Tim\AppData\Local\Temp\tmp1553.tmp /verbosity:quiet /nologo C:\Users\Tim\RiderProjects\kurumi-bot\src\KurumiBot\KurumiBot.csproj
Build started...
dotnet build C:\Users\Tim\RiderProjects\kurumi-bot\src\KurumiBot\KurumiBot.csproj /verbosity:quiet /nologo

Der Buildvorgang wurde erfolgreich ausgeführt.
    0 Warning(s)
    0 Errors

Verstrichene Zeit 00:00:03.78
Build succeeded.
dotnet exec --depsfile C:\Users\Tim\RiderProjects\kurumi-bot\src\KurumiBot\bin\Debug\net6.0\KurumiBot.deps.json --additionalprobingpath C:\Users\Tim\.nuget\packages --runtimeconfig C:\Users\Tim\RiderProjects\kurumi-bot\src\KurumiBot\bin\Debug\net6.0\KurumiBot.runtimeconfig.json C:\Users\Tim\.dotnet\tools\.store\dotnet-ef\7.0.0-rc.1.22426.7\dotnet-ef\7.0.0-rc.1.22426.7\tools\net6.0\any\tools\netcoreapp2.0\any\ef.dll dbcontext list --assembly C:\Users\Tim\RiderProjects\kurumi-bot\
src\KurumiBot\bin\Debug\net6.0\KurumiBot.dll --project C:\Users\Tim\RiderProjects\kurumi-bot\src\KurumiBot\KurumiBot.csproj --startup-assembly C:\Users\Tim\RiderProjects\kurumi-bot\src\KurumiBot\bin\Debug\net6.0\KurumiBot.dll --startup-project C:\Users\Tim\RiderProjects\kurumi-bot\src\KurumiBot\KurumiBot.csproj --project-dir C:\Users\Tim\RiderProjects\kurumi-bot\src\KurumiBot\ --root-namespace KurumiBot --language C# --framework net6.0 --nullable --working-dir C:\Users\Tim\Rider
Projects\kurumi-bot\src\KurumiBot --verbose
Using assembly 'KurumiBot'.
Using startup assembly 'KurumiBot'.
Using application base 'C:\Users\Tim\RiderProjects\kurumi-bot\src\KurumiBot\bin\Debug\net6.0'.
Using working directory 'C:\Users\Tim\RiderProjects\kurumi-bot\src\KurumiBot'.
Using root namespace 'KurumiBot'.
Using project directory 'C:\Users\Tim\RiderProjects\kurumi-bot\src\KurumiBot\'.
Remaining arguments: .
Finding DbContext classes...
Finding IDesignTimeDbContextFactory implementations...
Finding application service provider in assembly 'KurumiBot'...
Finding Microsoft.Extensions.Hosting service provider...
Using environment 'Development'.
Microsoft.Extensions.Hosting.HostAbortedException: The host was aborted.
   at Microsoft.Extensions.Hosting.HostFactoryResolver.HostingListener.ThrowHostAborted()
   at Microsoft.Extensions.Hosting.HostFactoryResolver.HostingListener.OnNext(KeyValuePair`2 value)
   at System.Diagnostics.DiagnosticListener.Write(String name, Object value)
   at Microsoft.Extensions.Hosting.HostBuilder.Write[T](DiagnosticSource diagnosticSource, String name, T value)
   at Microsoft.Extensions.Hosting.HostBuilder.ResolveHost(IServiceProvider serviceProvider, DiagnosticListener diagnosticListener)
   at Microsoft.Extensions.Hosting.HostBuilder.Build()
   at Program.&amp;lt;Main&amp;gt;$(String[] args) in C:\Users\Tim\RiderProjects\kurumi-bot\src\KurumiBot\Program.cs:line 62
Using application service provider from Microsoft.Extensions.Hosting.
Found DbContext 'KurumiContext'.
Finding DbContext classes in the project...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;EF Core version:
Database provider: Npgsql.EntityFrameworkCore.PostgreSQL
Target framework:.NET6.0
Operating system:
IDE: JetBrains Rider newest version&lt;/p&gt;
&lt;p&gt;My Service code https://pastebin.com/p8FZgLPq&lt;/p&gt;
&lt;p&gt;Last one i am really new to this, and sorry for my bad english.&lt;/p&gt;
</description>
      <pubDate>Tue, 20 Sep 2022 17:17:41 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29164</guid>
      <link>https://github.com/dotnet/efcore/issues/29164</link>
      <title>Issue: Accessing DbSet.Local with context pooling causes a memory leak - @Lawlzee</title>
      <description>&lt;p&gt;&lt;code&gt;LocalViewListener._viewActions&lt;/code&gt; are not reset when a context is returned to the context pool. This means, every time &lt;code&gt;DbSet&amp;lt;T&amp;gt;.Local&lt;/code&gt; is called, a &amp;quot;viewAction&amp;quot; is inserted &lt;code&gt;LocalViewListener._viewActions&lt;/code&gt;, which causes a memory leak.&lt;/p&gt;
&lt;p&gt;.NET Interactive dib script to reproduce the leak&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;#!csharp

#r &amp;quot;nuget: Microsoft.EntityFrameworkCore.SqlServer, 6.0.9&amp;quot;

#!csharp

using Microsoft.EntityFrameworkCore;

public class Blog
{
    public int Id { get; set; }
}

public class BlogDbContext : DbContext
{
    public BlogDbContext(DbContextOptions&amp;lt;BlogDbContext&amp;gt; options) : base(options)
    {
    }

    public DbSet&amp;lt;Blog&amp;gt; Blogs { get; private set; }
}

#!csharp

using Microsoft.Extensions.DependencyInjection;

IServiceCollection serviceCollection = new ServiceCollection();
serviceCollection.AddDbContextPool&amp;lt;BlogDbContext&amp;gt;(opt =&amp;gt; opt.UseSqlServer(&amp;quot;connectionString&amp;quot;));

var serviceProvider = serviceCollection.BuildServiceProvider();
var scopeFactory = serviceProvider.GetRequiredService&amp;lt;IServiceScopeFactory&amp;gt;();

#!csharp

using System.Reflection;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;

var _viewActionsField = typeof(LocalViewListener).GetField(&amp;quot;_viewActions&amp;quot;, BindingFlags.NonPublic | BindingFlags.Instance);

for (int i = 0; i &amp;lt; 1000; i++)
{
    using var scope = scopeFactory.CreateScope();
    var context = scope.ServiceProvider.GetRequiredService&amp;lt;BlogDbContext&amp;gt;();

    //Force the creation a value in LocalViewListener._viewActions
    var _ = context.Blogs.Local;

    ILocalViewListener localViewListener = context.Blogs.GetService&amp;lt;ILocalViewListener&amp;gt;();
    var _viewActions = (List&amp;lt;Action&amp;lt;InternalEntityEntry, EntityState&amp;gt;&amp;gt;)_viewActionsField.GetValue(localViewListener);

    if (_viewActions.Count &amp;gt; 1)
    {
        return &amp;quot;Memory leak!&amp;quot;;
    }
}

&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Tue, 20 Sep 2022 15:48:14 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29163</guid>
      <link>https://github.com/dotnet/efcore/issues/29163</link>
      <title>Issue: Ability to change minimum log level per database context - @poke</title>
      <description>&lt;p&gt;Hey, is it possible to change the minimum log level that is being used when EF Core logs per database context?&lt;/p&gt;
&lt;p&gt;I have the following situation: Our application has two database contexts. A “normal“ one, and one that is &lt;em&gt;very busy&lt;/em&gt; and makes a lot of requests. Because of that, the latter database context creates a lot of logging noise that completely overshadows the other database context (and the rest of the application).&lt;/p&gt;
&lt;p&gt;Is there a way to configure the logging per database context in some way? There are the two methods &lt;code&gt;UseLoggerFactory()&lt;/code&gt; and &lt;code&gt;LogTo()&lt;/code&gt; that allow me to configure things as part of the database context options but I am not sure how to use these in a good way that allows me to reuse the existing logging infrastructure while changing the minimum logging level.&lt;/p&gt;
&lt;p&gt;What I considered is creating a custom LoggerFactory/Logger implementation that wraps around the standard logging infrastructure and just skips everything below a certain level. Something like this (not yet tested):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;services.AddDbContext&amp;lt;BusyContext&amp;gt;((sp, options) =&amp;gt; options
    .UseSqlServer(_configuration.GetConnectionString(&amp;quot;Busy&amp;quot;))
    .UseLoggerFactory(new WrappingLoggerFactory(sp.GetService&amp;lt;ILoggerFactory&amp;gt;(), LogLevel.Warning)));
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public class WrappingLoggerFactory : ILoggerFactory
{
    private readonly ILoggerFactory _parentFactory;
    private readonly LogLevel _minimumLevel;

    public WrappingLoggerFactory(ILoggerFactory parentFactory, LogLevel minimumLevel)
    {
        _parentFactory = parentFactory;
        _minimumLevel = minimumLevel;
    }
    public void AddProvider(ILoggerProvider provider)
        =&amp;gt; throw new NotImplementedException();
    public ILogger CreateLogger(string categoryName)
        =&amp;gt; new WrappingLogger(_parentFactory.CreateLogger(categoryName), _minimumLevel);
    public void Dispose()
    { }
}

public class WrappingLogger : ILogger
{
    private readonly ILogger _parentLogger;
    private readonly LogLevel _minimumLevel;

    public WrappingLogger(ILogger parentLogger, LogLevel minimumLevel)
    {
        _parentLogger = parentLogger;
        _minimumLevel = minimumLevel;
    }
    public IDisposable BeginScope&amp;lt;TState&amp;gt;(TState state)
        =&amp;gt; _parentLogger.BeginScope(state);
    public bool IsEnabled(LogLevel logLevel)
        =&amp;gt; logLevel &amp;gt;= _minimumLevel &amp;amp;&amp;amp; _parentLogger.IsEnabled(logLevel);
    public void Log&amp;lt;TState&amp;gt;(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func&amp;lt;TState, Exception, string&amp;gt; formatter)
    {
        if (logLevel &amp;gt;= _minimumLevel)
            _parentLogger.Log(logLevel, eventId, state, exception, formatter);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will probably work, in one way or another, but I am wondering if there was an easier way to do this. In particular the &lt;code&gt;LogTo()&lt;/code&gt; method seems to be a bit more flexible but I am not entirely sure if I can set it up in a way that allows me to reuse the existing logging infrastructure for this.&lt;/p&gt;
&lt;p&gt;Do you have any suggestions on how to approach this issue, without configuring both database contexts to be equally silent (using global category filters)?&lt;/p&gt;
</description>
      <pubDate>Tue, 20 Sep 2022 09:44:41 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29156</guid>
      <link>https://github.com/dotnet/efcore/issues/29156</link>
      <title>Issue: TemporalAll for temporal owned entities mapped to parent table. - @fiseni</title>
      <description>&lt;p&gt;Hi All,&lt;/p&gt;
&lt;p&gt;There are several related issues, but I couldn't find any issue on this specific topic. I apologize if it's a duplicate.
I read the conversations. I do see the point regarding data inconsistencies in cases where we have to include the navigations, especially from non-temporal tables. But, how about this scenario (which is very common)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I have defined an owned entity mapped to the same parent table.&lt;/li&gt;
&lt;li&gt;The parent entity is defined as temporal.&lt;/li&gt;
&lt;li&gt;The owned entity is defined as temporal.&lt;/li&gt;
&lt;li&gt;Both, the parent and owned entity have mapped the period properties to the same columns (it's an EF requirement actually).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Issues:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I can't use TemporalAll (with or without projection).&lt;/li&gt;
&lt;li&gt;I can't get correct data even with a raw query.&lt;/li&gt;
&lt;li&gt;I can't even exclude the navigation (since it's an owned entity).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It would be great if we can get any solution. I mean even some workaround. I'm open to any ideas from the team and community.&lt;/p&gt;
&lt;h3&gt;Environment&lt;/h3&gt;
&lt;p&gt;.NET SDK (reflecting any global.json):
Version:   6.0.400
Commit:    7771abd614&lt;/p&gt;
&lt;p&gt;Microsoft.EntityFrameworkCore.SqlServer
Version:   &amp;quot;7.0.0-rc.1.22426.7&amp;quot;&lt;/p&gt;
&lt;h3&gt;Full sample (ready to run). I listed 6 possible options.&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;using Microsoft.EntityFrameworkCore;
using System.Text.Json;

await SeedAsync();

//await Read_Version1(); // Throws
//await Read_Version2(); // Throws
//await Read_Version3(); // Throws
await Read_Version4();
await Read_Version5();
await Read_Version6();


/// Throws an exception.
/// Navigation expansion is only supported for 'AsOf' temporal operation. For other operations use join manually.
async Task Read_Version1()
{
    using var dbContext = new AppDbContext();

    var customers = await dbContext.Customers
        .TemporalAll()
        .ToListAsync();

    Print(customers);
}

/// Throws with projection too.
/// Navigation expansion is only supported for 'AsOf' temporal operation. For other operations use join manually.
async Task Read_Version2()
{
    using var dbContext = new AppDbContext();

    var customers = await dbContext.Customers
        .TemporalAll()
        .Select(x =&amp;gt; new
        {
            Id = x.Id,
            Name = x.Name,
            Email = x.Contact.Email,
            PeriodStart = EF.Property&amp;lt;DateTime&amp;gt;(x, &amp;quot;PeriodStart&amp;quot;),
            PeriodEnd = EF.Property&amp;lt;DateTime&amp;gt;(x, &amp;quot;PeriodEnd&amp;quot;)
        })
        .ToListAsync();

    Print(customers);
}

/// Throws an exception (since both the parent and the owned entity contain these columns).
/// The column 'PeriodEnd' was specified multiple times for 'c'.
async Task Read_Version3()
{
    var table = &amp;quot;Customers&amp;quot;;
    using var dbContext = new AppDbContext();

    var queryString = dbContext.Customers.ToQueryString();

    var sql = queryString.Replace($&amp;quot;[{table}]&amp;quot;, $&amp;quot;[{table}] FOR SYSTEM_TIME ALL&amp;quot;);
    var data = await dbContext.Customers
        .FromSqlRaw(sql)
        .AsNoTracking()
        .ToListAsync();

    Print(data);
}

/// Returns incorrect data. It return 3 records, and all of them have &amp;quot;Email1_Updated&amp;quot; value for Email.
/// It takes only the recent values of the owned type and assigns to all records.
/// Also, PeriodStart and PeriodEnd are omitted from the results. 
/// I assume since FromSqlRaw operates on Set&amp;lt;Customer&amp;gt;, and those are shadow fields only?
async Task Read_Version4()
{
    var table = &amp;quot;Customers&amp;quot;;
    using var dbContext = new AppDbContext();

    var queryString = dbContext.Customers
        .Select(x =&amp;gt; new
        {
            Id = x.Id,
            Name = x.Name,
            Email = x.Contact.Email,
            PeriodStart = EF.Property&amp;lt;DateTime&amp;gt;(x, &amp;quot;PeriodStart&amp;quot;),
            PeriodEnd = EF.Property&amp;lt;DateTime&amp;gt;(x, &amp;quot;PeriodEnd&amp;quot;)
        })
        .ToQueryString();

    var sql = queryString.Replace($&amp;quot;[{table}]&amp;quot;, $&amp;quot;[{table}] FOR SYSTEM_TIME ALL&amp;quot;);
    var data = await dbContext.Customers
        .FromSqlRaw(sql)
        .AsNoTracking()
        .ToListAsync();

    Print(data);
}

/// Same issues as version 4.
async Task Read_Version5()
{
    using var dbContext = new AppDbContext();

    var data = await dbContext.Customers
        .FromSqlRaw(&amp;quot;SELECT [c].[Id], [c].[Name], [c].[Contact_Email], [c].[PeriodStart], [c].[PeriodEnd] FROM [Customers] FOR SYSTEM_TIME ALL AS [c]&amp;quot;)
        .AsNoTracking()
        .ToListAsync();

    Print(data);
}

/// Finally PeriodStart and PeriodEnd are projected to the result.
/// The Email values are still incorrect.
async Task Read_Version6()
{
    using var dbContext = new AppDbContext();

    var data = await dbContext.Customers
        .FromSqlRaw(&amp;quot;SELECT [c].[Id], [c].[Name], [c].[Contact_Email], [c].[PeriodStart], [c].[PeriodEnd] FROM [Customers] FOR SYSTEM_TIME ALL AS [c]&amp;quot;)
        .Select(x =&amp;gt; new
        {
            Id = x.Id,
            Name = x.Name,
            Email = x.Contact.Email,
            PeriodStart = EF.Property&amp;lt;DateTime&amp;gt;(x, &amp;quot;PeriodStart&amp;quot;),
            PeriodEnd = EF.Property&amp;lt;DateTime&amp;gt;(x, &amp;quot;PeriodEnd&amp;quot;)
        })
        .ToListAsync();

    Print(data);
}


async Task SeedAsync()
{
    using var dbContext = new AppDbContext();
    await dbContext.Database.EnsureDeletedAsync();
    await dbContext.Database.EnsureCreatedAsync();
    var customer = new Customer
    {
        Name = &amp;quot;Customer1&amp;quot;,
        Contact = new Contact { Email = &amp;quot;Email1&amp;quot; }
    };
    dbContext.Customers.Add(customer);
    await dbContext.SaveChangesAsync();

    customer.Name = &amp;quot;Customer1_Updated&amp;quot;;
    await dbContext.SaveChangesAsync();

    customer.Contact.Email = &amp;quot;Email1_Updated&amp;quot;;
    await dbContext.SaveChangesAsync();
}

static void Print&amp;lt;T&amp;gt;(T data)
{
    var result = JsonSerializer.Serialize(data, new JsonSerializerOptions
    {
        WriteIndented = true
    });

    Console.WriteLine(result);
}

class AppDbContext : DbContext
{
    public DbSet&amp;lt;Customer&amp;gt; Customers =&amp;gt; Set&amp;lt;Customer&amp;gt;();

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer(&amp;quot;Data Source=(localdb)\\MSSQLLocalDB;Initial Catalog=EFTemporalDemo;Integrated Security=SSPI;ConnectRetryCount=0;&amp;quot;);
    }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity&amp;lt;Customer&amp;gt;().ToTable(x =&amp;gt; x.IsTemporal());
        modelBuilder.Entity&amp;lt;Customer&amp;gt;().Property&amp;lt;DateTime&amp;gt;(&amp;quot;PeriodStart&amp;quot;).HasColumnName(&amp;quot;PeriodStart&amp;quot;);
        modelBuilder.Entity&amp;lt;Customer&amp;gt;().Property&amp;lt;DateTime&amp;gt;(&amp;quot;PeriodEnd&amp;quot;).HasColumnName(&amp;quot;PeriodEnd&amp;quot;);

        modelBuilder.Entity&amp;lt;Customer&amp;gt;().OwnsOne(x =&amp;gt; x.Contact, cb =&amp;gt;
        {
            cb.ToTable(x =&amp;gt; x.IsTemporal());
            cb.Property&amp;lt;DateTime&amp;gt;(&amp;quot;PeriodStart&amp;quot;).HasColumnName(&amp;quot;PeriodStart&amp;quot;);
            cb.Property&amp;lt;DateTime&amp;gt;(&amp;quot;PeriodEnd&amp;quot;).HasColumnName(&amp;quot;PeriodEnd&amp;quot;);
        });
    }
}

class Customer
{
    public int Id { get; set; }
    public string? Name { get; set; }
    public Contact Contact { get; set; } = default!;
}

class Contact
{
    public string? Email { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Mon, 19 Sep 2022 21:24:28 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29152</guid>
      <link>https://github.com/dotnet/efcore/issues/29152</link>
      <title>Issue: AsNoTracking() performs partial identity resolution - @ComptonAlvaro</title>
      <description>&lt;p&gt;I want to do a query with no identity resolution, so I am trying to use AsNoTracking(), but it performs identity resolution.&lt;/p&gt;
&lt;p&gt;I am trying this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;            using (Context miDbContext = new Context(_optionsDbContext))
            {
                return await miDbContext.Orders
                    .AsNoTracking()
                    .Include(x =&amp;gt; x.IDCategoryNavigation)
                    .ToListAsync();
           }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Order has a property Category and category has a property that is a collection o orders, I mean, it is bidirectional navigation properties.&lt;/p&gt;
&lt;p&gt;Supose I have 2 orders of the category A. If I don't use AsNoTracking(), if i access the category through an order, in the colletion of the category I have 2 orders, it is the expected.&lt;/p&gt;
&lt;p&gt;But if I use AsNoTracking(), if I access to the category through and order, the category has only one order, that is the same instance than the order.&lt;/p&gt;
&lt;p&gt;Is this the expected behaviour? I mean, in the documentation, it is tell that if I use AsNoTracking, it  will be created two istances for the same ID.&lt;/p&gt;
&lt;p&gt;Thanks.&lt;/p&gt;
</description>
      <pubDate>Mon, 19 Sep 2022 19:06:37 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29151</guid>
      <link>https://github.com/dotnet/efcore/issues/29151</link>
      <title>Issue: Index incorrectly named in migration - @glen-84</title>
      <description>&lt;h2&gt;File a bug&lt;/h2&gt;
&lt;h3&gt;Include your code&lt;/h3&gt;
&lt;p&gt;Configuration:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;builder
    .HasIndex(u =&amp;gt; u.Username, &amp;quot;UNIQ_1483A5E9F85E0677&amp;quot;)
    .IsUnique();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Initial migration:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;migrationBuilder.CreateIndex(
    name: &amp;quot;ix_users_username&amp;quot;,
    table: &amp;quot;users&amp;quot;,
    column: &amp;quot;username&amp;quot;,
    unique: true);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Shouldn't the index name in the migration also be &lt;code&gt;UNIQ_1483A5E9F85E0677&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;If this is unexpected behaviour I can create a reproduction repository, if it helps.&lt;/p&gt;
&lt;h3&gt;Include stack traces&lt;/h3&gt;
&lt;p&gt;n/a&lt;/p&gt;
&lt;h3&gt;Include verbose output&lt;/h3&gt;
&lt;p&gt;n/a&lt;/p&gt;
&lt;h3&gt;Include provider and version information&lt;/h3&gt;
&lt;p&gt;EF Core version: 6.0.9
Database provider: Pomelo.EntityFrameworkCore.MySql
Target framework: .NET 6.0
Operating system: Windows 11 Home
IDE: VS Code&lt;/p&gt;
</description>
      <pubDate>Mon, 19 Sep 2022 17:07:42 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29144</guid>
      <link>https://github.com/dotnet/efcore/issues/29144</link>
      <title>Issue: Database.EnsureCreated() force create multiple schemas - @aleksvujic</title>
      <description>&lt;p&gt;We are using .NET Core 3.1, &lt;a href="https://www.nuget.org/packages/Microsoft.EntityFrameworkCore/3.1.9"&gt;Microsoft.EntityFrameworkCore v3.1.9&lt;/a&gt; and &lt;a href="https://www.nuget.org/packages/Npgsql.EntityFrameworkCore.PostgreSQL/3.1.4"&gt;Npgsql.EntityFrameworkCore.PostgreSQL v3.1.4&lt;/a&gt;. We have 2 database schemas and corresponding &lt;code&gt;DbContext&lt;/code&gt; files:&lt;/p&gt;
&lt;p&gt;| &lt;strong&gt;schema&lt;/strong&gt;   | &lt;strong&gt;DbContext&lt;/strong&gt;       |
|--------------|---------------------|
| &lt;code&gt;test1&lt;/code&gt;      | &lt;code&gt;Test1DbContext.cs&lt;/code&gt; |
| &lt;code&gt;test2&lt;/code&gt;      | &lt;code&gt;Test2DbContext.cs&lt;/code&gt; |&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Test1DbContext.cs&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;public partial class Test1DbContext : DbContext
{
	public virtual DbSet&amp;lt;AppModules&amp;gt; AppModules { get; set; }
	public virtual DbSet&amp;lt;AppOffice&amp;gt; AppOffice { get; set; }
	public virtual DbSet&amp;lt;AppRoles&amp;gt; AppRoles { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Test2DbContext.cs&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;public partial class Test2DbContext : DbContext
{
	public virtual DbSet&amp;lt;CacuInter&amp;gt; CacuInter { get; set; }
	public virtual DbSet&amp;lt;Caseevents&amp;gt; Caseevents { get; set; }
	public virtual DbSet&amp;lt;Caseftpses&amp;gt; Caseftpses { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Database models are defined like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;[Table(&amp;quot;app_modules&amp;quot;, Schema = &amp;quot;test1&amp;quot;)]
public partial class AppModules
{
	[Key]
	[Column(&amp;quot;id&amp;quot;)]
	public int Id { get; set; }
	
	[Required]
	[Column(&amp;quot;name&amp;quot;)]
	[StringLength(25)]
	public string Name { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we start integration tests, we want to delete the database and recreate both schemas (&lt;code&gt;test1&lt;/code&gt; and &lt;code&gt;test2&lt;/code&gt;). This is the code snippet that we have currently:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;private void PrepareDatabase(Test1DbContext test1DbContext, Test2DbContext test2DbContext)
{
	// this drops the *whole* database, not just the `test1` schema
	test1DbContext.Database.EnsureDeleted();
	
	// create `test1` schema
	test1DbContext.Database.EnsureCreated();
	
	// nothing happens here because EF Core thinks that the database has already been created
	test2DbContext.Database.EnsureCreated();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We start with &lt;code&gt;test1DbContext.Database.EnsureDeleted()&lt;/code&gt; which drops the whole database. Then, we create schema &lt;code&gt;test1&lt;/code&gt; with &lt;code&gt;test1DbContext.Database.EnsureCreated()&lt;/code&gt;. At the end, we also want to create schema &lt;code&gt;test2&lt;/code&gt; with &lt;code&gt;test2DbContext.Database.EnsureCreated()&lt;/code&gt;, but nothing happens because EF Core thinks that the database has already been created.&lt;/p&gt;
&lt;p&gt;How can I force EF Core to create &lt;strong&gt;both&lt;/strong&gt; schemas?&lt;/p&gt;
</description>
      <pubDate>Mon, 19 Sep 2022 13:36:13 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29143</guid>
      <link>https://github.com/dotnet/efcore/issues/29143</link>
      <title>Issue: Support using a single sproc per concrete type regardless of the inheritance mapping strategy - @ajcvickers</title>
      <description>&lt;p&gt;The sproc itself would be responsible for writing to multiple tables, using a discriminator, etc.&lt;/p&gt;
</description>
      <pubDate>Mon, 19 Sep 2022 12:58:37 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29142</guid>
      <link>https://github.com/dotnet/efcore/issues/29142</link>
      <title>Issue: Owned Entity throws InvalidOperationException inside RelationalSqlTranslatingExpressionVisitor.TryRewriteEntityEquality - @andygjp</title>
      <description>&lt;h2&gt;File a bug&lt;/h2&gt;
&lt;p&gt;A query that ran in v6.0.9 now fails with RC1.&lt;/p&gt;
&lt;h3&gt;Code sample&lt;/h3&gt;
&lt;p&gt;I've recreated the issue in a repo: https://github.com/andygjp/OwnedTypesError.&lt;/p&gt;
&lt;p&gt;If I have the following model:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;internal class Context : DbContext
{
    public Context(DbContextOptions&amp;lt;Context&amp;gt; options) : base(options)
    {
    }

    public DbSet&amp;lt;Entity&amp;gt; Entities { get; set; }
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity&amp;lt;Entity&amp;gt;().HasKey(x =&amp;gt; x.EntityID);
        modelBuilder.Entity&amp;lt;Entity&amp;gt;().OwnsOne(x =&amp;gt; x.OwnedOne);
    }
}

internal class Entity
{
    public int EntityID { get; set; }
    public string? Value { get; set; }
    public OwnedOne? OwnedOne { get; set; }
}

internal class OwnedOne
{
    public string? Value { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I get an exception if I have a second where clause and I use the RC1 version of EF Core.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;new Context(dbContextOptions).Entities
    .AsNoTracking()
     // 1st
    .Where(x =&amp;gt; x.EntityID == existingEntity.EntityID)
    .Select(x =&amp;gt; x.OwnedOne)
    // 2nd
    .Where(x =&amp;gt; x != null)
    .ToList();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Version 6.0.9 does not raise any exceptions.&lt;/p&gt;
&lt;p&gt;You can run the program in the repo as is and it will complete without error. Then edit the package references in the csproj and run it again and it will throw.&lt;/p&gt;
&lt;h3&gt;Stack traces&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-text"&gt;Unhandled exception. System.InvalidOperationException: Sequence contains no elements
at System.Linq.ThrowHelper.ThrowNoElementsException()
at System.Linq.Enumerable.Aggregate[TSource](IEnumerable`1 source, Func`3 func)
at Microsoft.EntityFrameworkCore.Query.RelationalSqlTranslatingExpressionVisitor.TryRewriteEntityEquality(ExpressionType nodeType, Expression left, Expression right, Boolean equalsMethod, Expression&amp;amp; result)
at Microsoft.EntityFrameworkCore.Query.RelationalSqlTranslatingExpressionVisitor.VisitBinary(BinaryExpression binaryExpression)
at Microsoft.EntityFrameworkCore.SqlServer.Query.Internal.SqlServerSqlTranslatingExpressionVisitor.VisitBinary(BinaryExpression binaryExpression)
at Microsoft.EntityFrameworkCore.Query.RelationalSqlTranslatingExpressionVisitor.TranslateInternal(Expression expression)
at Microsoft.EntityFrameworkCore.Query.RelationalSqlTranslatingExpressionVisitor.Translate(Expression expression)
at Microsoft.EntityFrameworkCore.Query.RelationalQueryableMethodTranslatingExpressionVisitor.TranslateExpression(Expression expression)
at Microsoft.EntityFrameworkCore.Query.RelationalQueryableMethodTranslatingExpressionVisitor.TranslateLambdaExpression(ShapedQueryExpression shapedQueryExpression, LambdaExpression lambdaExpression)
at Microsoft.EntityFrameworkCore.Query.RelationalQueryableMethodTranslatingExpressionVisitor.TranslateWhere(ShapedQueryExpression source, LambdaExpression predicate)
at Microsoft.EntityFrameworkCore.Query.QueryableMethodTranslatingExpressionVisitor.VisitMethodCall(MethodCallExpression methodCallExpression)
at Microsoft.EntityFrameworkCore.Query.RelationalQueryableMethodTranslatingExpressionVisitor.VisitMethodCall(MethodCallExpression methodCallExpression)
at Microsoft.EntityFrameworkCore.Query.QueryableMethodTranslatingExpressionVisitor.VisitMethodCall(MethodCallExpression methodCallExpression)
at Microsoft.EntityFrameworkCore.Query.RelationalQueryableMethodTranslatingExpressionVisitor.VisitMethodCall(MethodCallExpression methodCallExpression)
at Microsoft.EntityFrameworkCore.Query.QueryCompilationContext.CreateQueryExecutor[TResult](Expression query)
at Microsoft.EntityFrameworkCore.Storage.Database.CompileQuery[TResult](Expression query, Boolean async)
at Microsoft.EntityFrameworkCore.Query.Internal.QueryCompiler.CompileQueryCore[TResult](IDatabase database, Expression query, IModel model, Boolean async)
at Microsoft.EntityFrameworkCore.Query.Internal.QueryCompiler.&amp;lt;&amp;gt;c__DisplayClass9_0`1.&amp;lt;Execute&amp;gt;b__0()
at Microsoft.EntityFrameworkCore.Query.Internal.CompiledQueryCache.GetOrAddQuery[TResult](Object cacheKey, Func`1 compiler)
at Microsoft.EntityFrameworkCore.Query.Internal.QueryCompiler.Execute[TResult](Expression query)
at Microsoft.EntityFrameworkCore.Query.Internal.EntityQueryProvider.Execute[TResult](Expression expression)
at Microsoft.EntityFrameworkCore.Query.Internal.EntityQueryable`1.GetEnumerator()
at System.Collections.Generic.List`1..ctor(IEnumerable`1 collection)
at System.Linq.Enumerable.ToList[TSource](IEnumerable`1 source)
at Program.&amp;lt;&amp;lt;Main&amp;gt;$&amp;gt;g__GetEntity|0_7(DbContextOptions`1 dbContextOptions, Entity existingEntity, Expression`1 predicate)
at Program.&amp;lt;Main&amp;gt;$(String[] args)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Versions&lt;/h3&gt;
&lt;p&gt;EF Core version: 7.0.0-rc.1.22426.7
Database provider: Microsoft.EntityFrameworkCore.Sqlite v7.0.0-rc.1.22426.7 (or Microsoft.EntityFrameworkCore.SqlServer)
Target framework: .NET 7.0
Operating system: MacOS&lt;/p&gt;
</description>
      <pubDate>Mon, 19 Sep 2022 12:18:44 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29137</guid>
      <link>https://github.com/dotnet/efcore/issues/29137</link>
      <title>Issue: Synapse database first approach - FUNCTION OBJECT_SCHEMA_NAME not supported - @mrzenca</title>
      <description>&lt;p&gt;Hi,&lt;/p&gt;
&lt;p&gt;When will a version be available that allows model generation based on Azure Synapse (SQL connection)?&lt;/p&gt;
&lt;p&gt;EF Version 7.0.0-rc.1.22426.7
dotnet ef dbcontext scaffold &amp;quot;...&amp;quot; Microsoft.EntityFrameworkCore.SqlServer -o Model
Error message: FUNCTION OBJECT_SCHEMA_NAME not supported&lt;/p&gt;
&lt;p&gt;Thanks,
Michał&lt;/p&gt;
</description>
      <pubDate>Mon, 19 Sep 2022 07:28:09 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29136</guid>
      <link>https://github.com/dotnet/efcore/issues/29136</link>
      <title>Issue: How to use EF Core in applications targeting .NET Framework 4.8 after EF Core 3.1 end of support? - @bairog</title>
      <description>&lt;p&gt;In &lt;strong&gt;December 2022&lt;/strong&gt; EF Core 3.1 will &lt;a href="https://learn.microsoft.com/en-us/ef/core/what-is-new/"&gt;reach EOL&lt;/a&gt;. It is the only EF Core version available for applications targeting .NET Framework 4.8.
.NET Framework 4.8 is still supported (since its lifecycle is tied to Windows) and ironically EF 6.4.4 is still supported (since &lt;a href="https://learn.microsoft.com/en-us/ef/efcore-and-ef6/support#entity-framework-60-61-62-63-and-64"&gt;there are currently no plans to end support&lt;/a&gt;).
It is &lt;a href="https://learn.microsoft.com/en-us/ef/efcore-and-ef6/support#entity-framework-60-61-62-63-and-64"&gt;strongly encouraged&lt;/a&gt; that new applications and existing applications that are in active development use EF Core.
@ajcvickers How it is planned to use EF Core (in a supported manner of course) in applications targeting .NET Framework 4.8 after EF Core 3.1 end of support (December 3, 2022)?&lt;/p&gt;
</description>
      <pubDate>Mon, 19 Sep 2022 03:20:50 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29135</guid>
      <link>https://github.com/dotnet/efcore/issues/29135</link>
      <title>Issue: Optimistic concurrency exception from stored procedure logs error - @ajcvickers</title>
      <description>&lt;p&gt;Test with https://github.com/dotnet/EntityFramework.Docs/blob/274255cff5c7d38045ad0d15a6454e199e072f2c/samples/core/Miscellaneous/NewInEFCore7/DocumentsContext.cs#L74&lt;/p&gt;
&lt;p&gt;Normally, a &lt;code&gt;DbUpdateConcurrencyException&lt;/code&gt; does not result in an error being logged.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Optimistic concurrency test 1...

info: 9/18/2022 22:27:03.209 RelationalEventId.CommandExecuted[20101] (Microsoft.EntityFrameworkCore.Database.Command)
      Executed DbCommand (2ms) [Parameters=[@p1='4', @p0=NULL (Size = 4000), @p2='0x00000000000007D9' (Size = 8)], CommandType='Text', CommandTimeout='30']
      SET IMPLICIT_TRANSACTIONS OFF;
      SET NOCOUNT ON;
      UPDATE [Documents] SET [Isbn] = @p0
      OUTPUT INSERTED.[RetrievedOn], INSERTED.[RowVersion]
      WHERE [Id] = @p1 AND [RowVersion] = @p2;
Caught expected: The database operation was expected to affect 1 row(s), but actually affected 0 row(s); data may have been modified or deleted since entities were loaded. See http://go.microsoft.com/fwlink/?LinkId=527962 for information on understanding and handling optimistic concurrency exceptions.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But when using stored procedures, a &amp;quot;fail&amp;quot; message is logged:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Optimistic concurrency test 1...

info: 9/18/2022 22:30:57.117 RelationalEventId.CommandExecuted[20101] (Microsoft.EntityFrameworkCore.Database.Command)
      Executed DbCommand (0ms) [Parameters=[@p0='4', @p1='0x00000000000007D4' (Size = 8), @p2='Test-Driven Development By Example (New Edition!)' (Nullable = false) (Size = 4000), @p3='220', @p4='2003-01-01T00:00:00.0000000', @p5=NULL (Size = 8000) (DbType = Binary), @p6=NULL (Size = 4000), @p7=NULL (Precision = 18) (Scale = 2) (DbType = Decimal), @p8=NULL (DbType = Int32), @p9=NULL (DbType = Int32), @p10='2022-09-18T21:30:56.6400000', @p11=NULL (Nullable = false) (Direction = Output) (DbType = DateTime2), @p12=NULL (Size = 8) (Direction = Output) (DbType = Binary)], CommandType='Text', CommandTimeout='30']
      SET NOCOUNT ON;
      EXEC [Documents_Update] @p0, @p1, @p2, @p3, @p4, @p5, @p6, @p7, @p8, @p9, @p10, @p11 OUTPUT, @p12 OUTPUT;
fail: 9/18/2022 22:30:57.133 CoreEventId.SaveChangesFailed[10000] (Microsoft.EntityFrameworkCore.Update)
      An exception occurred in the database while saving changes for context type 'NewInEfCore7.TphDocumentsContext'.
      Microsoft.EntityFrameworkCore.DbUpdateConcurrencyException: The database operation was expected to affect 1 row(s), but actually affected 0 row(s); data may have been modified or deleted since entities were loaded. See http://go.microsoft.com/fwlink/?LinkId=527962 for information on understanding and handling optimistic concurrency exceptions.
         at Microsoft.EntityFrameworkCore.Update.AffectedCountModificationCommandBatch.ThrowAggregateUpdateConcurrencyExceptionAsync(RelationalDataReader reader, Int32 commandIndex, Int32 expectedRowsAffected, Int32 rowsAffected, CancellationToken cancellationToken)
         at Microsoft.EntityFrameworkCore.Update.AffectedCountModificationCommandBatch.ConsumeResultSetWithRowsAffectedOnlyAsync(Int32 commandIndex, RelationalDataReader reader, CancellationToken cancellationToken)
         at Microsoft.EntityFrameworkCore.Update.AffectedCountModificationCommandBatch.ConsumeAsync(RelationalDataReader reader, CancellationToken cancellationToken)
         at Microsoft.EntityFrameworkCore.Update.ReaderModificationCommandBatch.ExecuteAsync(IRelationalConnection connection, CancellationToken cancellationToken)
         at Microsoft.EntityFrameworkCore.Update.ReaderModificationCommandBatch.ExecuteAsync(IRelationalConnection connection, CancellationToken cancellationToken)
         at Microsoft.EntityFrameworkCore.SqlServer.Update.Internal.SqlServerModificationCommandBatch.ExecuteAsync(IRelationalConnection connection, CancellationToken cancellationToken)
         at Microsoft.EntityFrameworkCore.Update.Internal.BatchExecutor.ExecuteAsync(IEnumerable`1 commandBatches, IRelationalConnection connection, CancellationToken cancellationToken)
         at Microsoft.EntityFrameworkCore.Update.Internal.BatchExecutor.ExecuteAsync(IEnumerable`1 commandBatches, IRelationalConnection connection, CancellationToken cancellationToken)
         at Microsoft.EntityFrameworkCore.Update.Internal.BatchExecutor.ExecuteAsync(IEnumerable`1 commandBatches, IRelationalConnection connection, CancellationToken cancellationToken)
         at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.SaveChangesAsync(IList`1 entriesToSave, CancellationToken cancellationToken)
         at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.SaveChangesAsync(StateManager stateManager, Boolean acceptAllChangesOnSuccess, CancellationToken cancellationToken)
         at Microsoft.EntityFrameworkCore.SqlServer.Storage.Internal.SqlServerExecutionStrategy.ExecuteAsync[TState,TResult](TState state, Func`4 operation, Func`4 verifySucceeded, CancellationToken cancellationToken)
         at Microsoft.EntityFrameworkCore.DbContext.SaveChangesAsync(Boolean acceptAllChangesOnSuccess, CancellationToken cancellationToken)
Caught expected: The database operation was expected to affect 1 row(s), but actually affected 0 row(s); data may have been modified or deleted since entities were loaded. See http://go.microsoft.com/fwlink/?LinkId=527962 for information on understanding and handling optimistic concurrency exceptions.
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Sun, 18 Sep 2022 21:32:33 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29123</guid>
      <link>https://github.com/dotnet/efcore/issues/29123</link>
      <title>Issue: When EF7 RC is referenced from a Function App, the app throws a runtime error on startup - @elninoisback</title>
      <description>&lt;p&gt;A minimal reproduceable repo is here: https://github.com/elninoisback/ef7rc-fnapp-issue&lt;/p&gt;
&lt;p&gt;The following error is thrown in the console when the function app startsup. It goes away when you remove the ef core dependancy,&lt;/p&gt;
&lt;p&gt;&lt;code&gt;The 'Function1' function is in error: Could not load file or assembly 'Microsoft.Extensions.Logging.Abstractions, Version=7.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60'. The system cannot find the file specified.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The following is my .csproj file of the function app.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;Project Sdk=&amp;quot;Microsoft.NET.Sdk&amp;quot;&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;TargetFramework&amp;gt;net6.0&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;AzureFunctionsVersion&amp;gt;v4&amp;lt;/AzureFunctionsVersion&amp;gt;
    &amp;lt;RootNamespace&amp;gt;ef7rc_fnapp_issue&amp;lt;/RootNamespace&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.EntityFrameworkCore.SqlServer&amp;quot; Version=&amp;quot;7.0.0-rc.1.22426.7&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.NET.Sdk.Functions&amp;quot; Version=&amp;quot;4.1.1&amp;quot; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;
  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;None Update=&amp;quot;host.json&amp;quot;&amp;gt;
      &amp;lt;CopyToOutputDirectory&amp;gt;PreserveNewest&amp;lt;/CopyToOutputDirectory&amp;gt;
    &amp;lt;/None&amp;gt;
    &amp;lt;None Update=&amp;quot;local.settings.json&amp;quot;&amp;gt;
      &amp;lt;CopyToOutputDirectory&amp;gt;PreserveNewest&amp;lt;/CopyToOutputDirectory&amp;gt;
      &amp;lt;CopyToPublishDirectory&amp;gt;Never&amp;lt;/CopyToPublishDirectory&amp;gt;
    &amp;lt;/None&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;EF Core version: 7.0.0-rc.1.22426.7
Database provider: (e.g. Microsoft.EntityFrameworkCore.SqlServer)
Target framework: (e.g. .NET 6.0)
Operating system: Windows 10 Pro
IDE: Visual Studio Enterprise 2022&lt;/p&gt;
</description>
      <pubDate>Fri, 16 Sep 2022 14:11:29 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29121</guid>
      <link>https://github.com/dotnet/efcore/issues/29121</link>
      <title>Issue: Reverse engineer Synapse Serverless SQL Pool and Dynamics 365 TDS Endpoint - @ErikEJ</title>
      <description>&lt;p&gt;&lt;strong&gt;Why&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As a EF Core developer I would like to be able to use my familiar API to query a Synapse Server SQL Pool and Dynamics 365 TDS Endpoint and get the model generated for me by the EF Core tooling, so I can do read-only queries against theses data sources.&lt;/p&gt;
&lt;p&gt;(This currently breaks with the EF Core tooling)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I recently enabled this in EF Core Power Tools, and can port my tweaks to SqlServerDatabasemodelFactory to the product, if this has any traction.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;More info&lt;/strong&gt;
&lt;a href="https://docs.microsoft.com/en-us/power-apps/developer/data-platform/dataverse-sql-query"&gt;Dynamics 365 CRM TDS Endpoint&lt;/a&gt;  - EngineEdition = 1000&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/azure/synapse-analytics/sql/on-demand-workspace-overview"&gt;Azure Synapse Analytics Serverless SQL pool&lt;/a&gt; - EngineEdition = 11&lt;/p&gt;
</description>
      <pubDate>Fri, 16 Sep 2022 07:10:24 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29120</guid>
      <link>https://github.com/dotnet/efcore/issues/29120</link>
      <title>Issue: EF 7 RC1 - The binary operator Equal is not defined for the types 'System.Guid' and 'System.Nullable`1[System.Guid]' - @gabynevada</title>
      <description>&lt;h2&gt;File a bug&lt;/h2&gt;
&lt;p&gt;Updated one of our project to EF 7 RC1, it works as expected until we hit any path that utilizes UserManager from Microsoft.AspNetCore.Identity&lt;/p&gt;
&lt;p&gt;As soon as we use one of the methods, the code fails with the message &lt;strong&gt;&amp;quot;The binary operator Equal is not defined for the types 'System.Guid' and 'System.Nullable`1[System.Guid]'&amp;quot;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Any help or insight is appreciated.&lt;/p&gt;
&lt;h3&gt;Include your code&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;var user = await _userManager.FindByIdAsync(userId.ToString());
// Fails
// Other code from method
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Model&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt;public class User : IdentityUser&amp;lt;Guid&amp;gt;
{
// Additional fields
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DbContext&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c#"&gt; public class AppContext : IdentityDbContext&amp;lt;User, Role, Guid, UserClaim, UserRole, UserLogin, RoleClaim, UserToken&amp;gt;
{
  public BioportalContext(DbContextOptions&amp;lt;BioportalContext&amp;gt; options) : base(options)
  {
  }
  public DbSet&amp;lt;User&amp;gt; User =&amp;gt; Set&amp;lt;User&amp;gt;();
  // More...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Include stack traces&lt;/h3&gt;
&lt;p&gt;Include the full exception message and stack trace for any exception you encounter.&lt;/p&gt;
&lt;p&gt;Use triple-tick fences for stack traces. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (160ms) [Parameters=[@__get_Item_0='?' (DbType = Guid)], CommandType='Text', CommandTimeout='90']
      SELECT TOP(1) [u].[Id], [u].[AccessFailedCount], [u].[BirthDate], [u].[ClusterId], [u].[ConcurrencyStamp], [u].[Email], [u].[EmailConfirmed], [u].[FirstName], [u].[FullName], [u].[FullNameForSearch], [u].[LastName], [u].[LockoutEnabled], [u].[LockoutEnd], [u].[MiddleName], [u].[NormalizedEmail], [u].[NormalizedUserName], [u].[PasswordHash], [u].[PatientId], [u].[PhoneNumber], [u].[PhoneNumberConfirmed], [u].[SecondLastName], [u].[SecurityStamp], [u].[Sex], [u].[Ssn], [u].[Suffix], [u].[Title], [u].[TwoFactorEnabled], [u].[UserName]
      FROM [authentication].[User] AS [u]
      WHERE [u].[Id] = @__get_Item_0
fail: Microsoft.EntityFrameworkCore.Query[10100]
      An exception occurred while iterating over the results of a query for context type 'App.Infrastructure.AppContext'.
      System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation.
       ---&amp;gt; System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation.
       ---&amp;gt; System.InvalidOperationException: The binary operator Equal is not defined for the types 'System.Guid' and 'System.Nullable`1[System.Guid]'.
         at System.Linq.Expressions.Expression.GetEqualityComparisonOperator(ExpressionType binaryType, String opName, Expression left, Expression right, Boolean liftToNull)
         at Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer.DefaultValueComparer`1.ExtractEqualsBody(Expression leftExpression, Expression rightExpression)
         at Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessorsFactory.CreateCurrentValueGetter[TProperty](IPropertyBase propertyBase, Boolean useStoreGeneratedValues)
         at Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessorsFactory.CreateGeneric[TProperty](IPropertyBase propertyBase)
         at InvokeStub_PropertyAccessorsFactory.CreateGeneric(Object, Object, IntPtr*)
         at System.Reflection.MethodInvoker.Invoke(Object obj, IntPtr* args, BindingFlags invokeAttr)
         --- End of inner exception stack trace ---
         at System.Reflection.MethodInvoker.Invoke(Object obj, IntPtr* args, BindingFlags invokeAttr)
         at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
         at Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessorsFactory.Create(IPropertyBase propertyBase)
         at Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase.&amp;lt;&amp;gt;c.&amp;lt;Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimePropertyBase.get_Accessors&amp;gt;b__29_0(RuntimePropertyBase property)
         at Microsoft.EntityFrameworkCore.Internal.NonCapturingLazyInitializer.EnsureInitialized[TParam,TValue](TValue&amp;amp; target, TParam param, Func`2 valueFactory)
         at Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase.Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimePropertyBase.get_Accessors()
         at Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBaseExtensions.GetPropertyAccessors(IPropertyBase propertyBase)
         at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.DependentKeyValueFactoryFactory.CreateSimple[TKey](IForeignKey foreignKey)
         at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.KeyValueFactoryFactory.CreateSimpleFactory[TKey](IKey key)
         at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.KeyValueFactoryFactory.Create[TKey](IKey key)
         at Microsoft.EntityFrameworkCore.Metadata.RuntimeKey.&amp;lt;&amp;gt;c__24`1.&amp;lt;Microsoft.EntityFrameworkCore.Metadata.IKey.GetPrincipalKeyValueFactory&amp;gt;b__24_0(RuntimeKey key)
         at Microsoft.EntityFrameworkCore.Internal.NonCapturingLazyInitializer.EnsureInitialized[TParam,TValue](TValue&amp;amp; target, TParam param, Func`2 valueFactory)
         at Microsoft.EntityFrameworkCore.Metadata.RuntimeKey.Microsoft.EntityFrameworkCore.Metadata.IKey.GetPrincipalKeyValueFactory[TKey]()
         at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IdentityMapFactoryFactory.CreateFactory[TKey](IKey key)
         at InvokeStub_IdentityMapFactoryFactory.CreateFactory(Object, Object, IntPtr*)
         at System.Reflection.MethodInvoker.Invoke(Object obj, IntPtr* args, BindingFlags invokeAttr)
         --- End of inner exception stack trace ---
         at System.Reflection.MethodInvoker.Invoke(Object obj, IntPtr* args, BindingFlags invokeAttr)
         at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
         at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IdentityMapFactoryFactory.Create(IKey key)
         at Microsoft.EntityFrameworkCore.Metadata.RuntimeKey.&amp;lt;&amp;gt;c.&amp;lt;Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeKey.GetIdentityMapFactory&amp;gt;b__25_0(RuntimeKey key)
         at Microsoft.EntityFrameworkCore.Internal.NonCapturingLazyInitializer.EnsureInitialized[TParam,TValue](TValue&amp;amp; target, TParam param, Func`2 valueFactory)
         at Microsoft.EntityFrameworkCore.Metadata.RuntimeKey.Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeKey.GetIdentityMapFactory()
         at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.GetOrCreateIdentityMap(IKey key)
         at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.TryGetEntry(IKey key, Object[] keyValues, Boolean throwOnNullKey, Boolean&amp;amp; hasNullKey)
         at Microsoft.EntityFrameworkCore.Query.QueryContext.TryGetEntry(IKey key, Object[] keyValues, Boolean throwOnNullKey, Boolean&amp;amp; hasNullKey)
         at lambda_method43(Closure, QueryContext, DbDataReader, ResultContext, SingleQueryResultCoordinator)
         at Microsoft.EntityFrameworkCore.Query.Internal.SingleQueryingEnumerable`1.AsyncEnumerator.MoveNextAsync()
      System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation.
       ---&amp;gt; System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation.
       ---&amp;gt; System.InvalidOperationException: The binary operator Equal is not defined for the types 'System.Guid' and 'System.Nullable`1[System.Guid]'.
         at System.Linq.Expressions.Expression.GetEqualityComparisonOperator(ExpressionType binaryType, String opName, Expression left, Expression right, Boolean liftToNull)
         at Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer.DefaultValueComparer`1.ExtractEqualsBody(Expression leftExpression, Expression rightExpression)
         at Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessorsFactory.CreateCurrentValueGetter[TProperty](IPropertyBase propertyBase, Boolean useStoreGeneratedValues)
         at Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessorsFactory.CreateGeneric[TProperty](IPropertyBase propertyBase)
         at InvokeStub_PropertyAccessorsFactory.CreateGeneric(Object, Object, IntPtr*)
         at System.Reflection.MethodInvoker.Invoke(Object obj, IntPtr* args, BindingFlags invokeAttr)
         --- End of inner exception stack trace ---
         at System.Reflection.MethodInvoker.Invoke(Object obj, IntPtr* args, BindingFlags invokeAttr)
         at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
         at Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyAccessorsFactory.Create(IPropertyBase propertyBase)
         at Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase.&amp;lt;&amp;gt;c.&amp;lt;Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimePropertyBase.get_Accessors&amp;gt;b__29_0(RuntimePropertyBase property)
         at Microsoft.EntityFrameworkCore.Internal.NonCapturingLazyInitializer.EnsureInitialized[TParam,TValue](TValue&amp;amp; target, TParam param, Func`2 valueFactory)
         at Microsoft.EntityFrameworkCore.Metadata.RuntimePropertyBase.Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimePropertyBase.get_Accessors()
         at Microsoft.EntityFrameworkCore.Metadata.Internal.PropertyBaseExtensions.GetPropertyAccessors(IPropertyBase propertyBase)
         at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.DependentKeyValueFactoryFactory.CreateSimple[TKey](IForeignKey foreignKey)
         at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.KeyValueFactoryFactory.CreateSimpleFactory[TKey](IKey key)
         at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.KeyValueFactoryFactory.Create[TKey](IKey key)
         at Microsoft.EntityFrameworkCore.Metadata.RuntimeKey.&amp;lt;&amp;gt;c__24`1.&amp;lt;Microsoft.EntityFrameworkCore.Metadata.IKey.GetPrincipalKeyValueFactory&amp;gt;b__24_0(RuntimeKey key)
         at Microsoft.EntityFrameworkCore.Internal.NonCapturingLazyInitializer.EnsureInitialized[TParam,TValue](TValue&amp;amp; target, TParam param, Func`2 valueFactory)
         at Microsoft.EntityFrameworkCore.Metadata.RuntimeKey.Microsoft.EntityFrameworkCore.Metadata.IKey.GetPrincipalKeyValueFactory[TKey]()
         at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IdentityMapFactoryFactory.CreateFactory[TKey](IKey key)
         at InvokeStub_IdentityMapFactoryFactory.CreateFactory(Object, Object, IntPtr*)
         at System.Reflection.MethodInvoker.Invoke(Object obj, IntPtr* args, BindingFlags invokeAttr)
         --- End of inner exception stack trace ---
         at System.Reflection.MethodInvoker.Invoke(Object obj, IntPtr* args, BindingFlags invokeAttr)
         at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
         at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.IdentityMapFactoryFactory.Create(IKey key)
         at Microsoft.EntityFrameworkCore.Metadata.RuntimeKey.&amp;lt;&amp;gt;c.&amp;lt;Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeKey.GetIdentityMapFactory&amp;gt;b__25_0(RuntimeKey key)
         at Microsoft.EntityFrameworkCore.Internal.NonCapturingLazyInitializer.EnsureInitialized[TParam,TValue](TValue&amp;amp; target, TParam param, Func`2 valueFactory)
         at Microsoft.EntityFrameworkCore.Metadata.RuntimeKey.Microsoft.EntityFrameworkCore.Metadata.Internal.IRuntimeKey.GetIdentityMapFactory()
         at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.GetOrCreateIdentityMap(IKey key)
         at Microsoft.EntityFrameworkCore.ChangeTracking.Internal.StateManager.TryGetEntry(IKey key, Object[] keyValues, Boolean throwOnNullKey, Boolean&amp;amp; hasNullKey)
         at Microsoft.EntityFrameworkCore.Query.QueryContext.TryGetEntry(IKey key, Object[] keyValues, Boolean throwOnNullKey, Boolean&amp;amp; hasNullKey)
         at lambda_method43(Closure, QueryContext, DbDataReader, ResultContext, SingleQueryResultCoordinator)
         at Microsoft.EntityFrameworkCore.Query.Internal.SingleQueryingEnumerable`1.AsyncEnumerator.MoveNextAsync()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Include provider and version information&lt;/h3&gt;
&lt;p&gt;EF Core version: 7.0.0-rc.1.22426.7
Database provider: Microsoft.EntityFrameworkCore.SqlServer
Target framework: net7.0
Operating system: MacOS Monterey V12.6
IDE: Rider 2022.2.3&lt;/p&gt;
</description>
      <pubDate>Fri, 16 Sep 2022 02:20:04 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29117</guid>
      <link>https://github.com/dotnet/efcore/issues/29117</link>
      <title>Issue: Test: Entity splitting and split query - @smitpatel</title>
      <description>&lt;p&gt;As always works in theory (and in practice)&lt;/p&gt;
</description>
      <pubDate>Thu, 15 Sep 2022 19:31:56 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29116</guid>
      <link>https://github.com/dotnet/efcore/issues/29116</link>
      <title>Issue: Add resource removal to ChangeTracking - @Mr0N</title>
      <description>&lt;!-- What problem are you trying to solve? --&gt;
&lt;p&gt;I suggest adding such a pattern to EF Core to remove unnecessary resources from ChangeTracker&lt;/p&gt;
&lt;!-- Describe the solution you'd like --&gt;
&lt;pre&gt;&lt;code&gt;using System;
using Microsoft.EntityFrameworkCore;

//Example Use
var myDb = new MyDbContext();
using var info = new Info();
myDb.AddInfo(info);
myDb.SaveChanges();

class MyDbContext:DbContext 
{
    public DbSet&amp;lt;Info&amp;gt; information { set; get; }
    public void AddInfo(Info info)
    {
        if(info is IChangeTrackingDispose&amp;lt;Info&amp;gt; change)
        {
            change.SetDbSet(information);
        }
        information.Add(info);
    }
}
public class Info : IChangeTrackingDispose&amp;lt;Info&amp;gt;
{
    public int Id {set;get;}
    public DbSet&amp;lt;Info&amp;gt; _dbSet { set; get; }

    public void Dispose()
    {
        (this as IChangeTrackingDispose&amp;lt;Info&amp;gt;).Close();
    }
}

interface IChangeTrackingDispose&amp;lt;T&amp;gt;:IDisposable where T : class
{

    DbSet&amp;lt;T&amp;gt; _dbSet { set; get; }
    public void SetDbSet(DbSet&amp;lt;T&amp;gt; dbSet)
    {
        _dbSet = dbSet;
    }
    private void RemoveFromChangeTraking()
    {
        ///The logic for removing this instance from Change Tracking
    }
    public void Close()
    {
        RemoveFromChangeTraking();
    }

}
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Thu, 15 Sep 2022 18:35:15 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29115</guid>
      <link>https://github.com/dotnet/efcore/issues/29115</link>
      <title>Issue: DRY opportunities in weak entity projection generation in SelectExpression - @smitpatel</title>
      <description />
      <pubDate>Thu, 15 Sep 2022 17:20:42 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29113</guid>
      <link>https://github.com/dotnet/efcore/issues/29113</link>
      <title>Issue: Prune main table in entity splitting if not used - @smitpatel</title>
      <description>&lt;p&gt;Considerations&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Optional dependents #29079 we currently check main table for figuring out property condition for materialization, if we drop main fragment we need to see how to generate that condition.&lt;/li&gt;
&lt;li&gt;Optional fragments, when additional tables won't have row so we would need to join with main fragment to make sure we identify null data vs no data. #27974&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;From implementation perspective,
Multiple columns coming from different fragment mapped to same IProperty will have same value. Currently we pick the first column in that list (which is like to be coming from main table which we don't remove yet). In order to prune in best way, we would need to understand at the time of pruning what are the column values we need and how to generate those columns by utilizing least number of tables participating in the entity splitting. #29035 may be necessary for it.&lt;/p&gt;
</description>
      <pubDate>Thu, 15 Sep 2022 16:01:16 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29112</guid>
      <link>https://github.com/dotnet/efcore/issues/29112</link>
      <title>Issue: Still no bulk update with  EF Core 7 RC? - @niltor</title>
      <description>&lt;p&gt;I have read a lot of blogs about ef 7 support &lt;code&gt;bulk update&lt;/code&gt;, and the  #27185  show that this feature had been completed.&lt;/p&gt;
&lt;p&gt;But when I try to use ef 7 preview7 and RC, there is no &lt;code&gt;ExecuteDeleteAsync&lt;/code&gt; method. This is so confusing！&lt;/p&gt;
</description>
      <pubDate>Thu, 15 Sep 2022 10:28:04 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29109</guid>
      <link>https://github.com/dotnet/efcore/issues/29109</link>
      <title>Issue: .NET 6 SQLite Not Working on Raspberry PI (ARM64) - @VAapps</title>
      <description>&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/53390746/190332884-a3261174-cfa1-4cc2-ac45-0e5244291a64.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;POC Source Code is placed &lt;a href="https://github.com/anandnandagiri/MyPOC/tree/master/.NET%20Core/.NET%206/issue491"&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Raspberry PI OS Details below its 64 Bit
&lt;img src="https://user-images.githubusercontent.com/53390746/190333799-d9ba335d-f6e0-4d4a-8efc-a8180510363b.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;I use this command to compile
dotnet publish -c Release -r linux-arm64 --self-contained false&lt;/p&gt;
&lt;p&gt;using docker file
FROM mcr.microsoft.com/dotnet/aspnet:6.0-alpine3.14 AS runtime
WORKDIR /app
COPY . .
ENTRYPOINT [&amp;quot;dotnet&amp;quot;, &amp;quot;issue491.dll&amp;quot;]&lt;/p&gt;
</description>
      <pubDate>Thu, 15 Sep 2022 06:48:42 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29108</guid>
      <link>https://github.com/dotnet/efcore/issues/29108</link>
      <title>Issue: Auto migrations with GenerateScript - @datnt97</title>
      <description>&lt;h3&gt;THE SITUATION:&lt;/h3&gt;
&lt;p&gt;I am working on a project that has multiple Tenant that has its database.
And I have to update the database when it has new migrations for every tenant.
I also look through &lt;a href="https://github.com/dotnet/efcore/issues/6214#issuecomment-332980580"&gt;issue &amp;quot;Automatic migrations&amp;quot;&lt;/a&gt;, but I dont' really understand it @@&lt;/p&gt;
&lt;h3&gt;MY SOLUTION:&lt;/h3&gt;
&lt;p&gt;I found a solution &lt;a href="https://docs.microsoft.com/en-us/ef/core/managing-schemas/migrations/applying"&gt;here&lt;/a&gt;.
I get the pending migrations of context, and update if it contains in the pending list.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cs"&gt;private Task Test()
{
	using (var context = new SampleContext())
	{
		var migrationStart = nameof(F5_RemoveUnnecessaryProperty);
		var migrationEnd = nameof(F6_Refactor_Topic_V3);

		var migrator = context.GetService&amp;lt;IMigrator&amp;gt;();

		// Error with transaction
		//await migrator.MigrateAsync(migration);

		var scripts = migrator.GenerateScript(migrationStart, migrationEnd, MigrationsSqlGenerationOptions.NoTransaction);
		var lines = scripts.Split($&amp;quot;{Environment.NewLine}GO{Environment.NewLine}&amp;quot;).ToList();
		lines = lines.Take(lines.Count - 1).ToList();
		
                foreach (var line in lines)
		{
			using (var trans = context.Database.BeginTransaction(System.Data.IsolationLevel.ReadUncommitted))
			{
				await context.Database.ExecuteSqlRawAsync(line);
				await trans.CommitAsync();
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;THE ERROR:&lt;/h3&gt;
&lt;p&gt;Sometimes I encounter problems with transaction. If I use &lt;code&gt;await migrator.MigrateAsync(migration);&lt;/code&gt;
&lt;img src="https://user-images.githubusercontent.com/59597401/190312041-76e1a6c2-9be1-4124-90a8-42bf1684641b.png" alt="image" /&gt;&lt;/p&gt;
&lt;h3&gt;ASP.NET CORE VERSION:&lt;/h3&gt;
&lt;p&gt;I am using &lt;code&gt;net5.0&lt;/code&gt; and EntityFramework Core:  &lt;code&gt;5.0.3&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;QUESTIONS:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Has any solutions better than my solution?&lt;/li&gt;
&lt;/ul&gt;
</description>
      <pubDate>Thu, 15 Sep 2022 04:28:50 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29104</guid>
      <link>https://github.com/dotnet/efcore/issues/29104</link>
      <title>Issue: Reverse split mapping for owned type throws cycle error in save changes - @smitpatel</title>
      <description>&lt;pre&gt;&lt;code&gt;mb.Entity&amp;lt;EntityOne&amp;gt;(
    b =&amp;gt;
    {
        b.ToTable(&amp;quot;SplitEntityOnePart1&amp;quot;);

        b.SplitToTable(&amp;quot;SplitEntityOnePart2&amp;quot;,
            tb =&amp;gt;
            {
                tb.Property(e =&amp;gt; e.IntValue3);
                tb.Property(e =&amp;gt; e.StringValue3);
            });

        b.SplitToTable(&amp;quot;SplitEntityOnePart3&amp;quot;,
            tb =&amp;gt;
            {
                tb.Property(e =&amp;gt; e.IntValue4);
                tb.Property(e =&amp;gt; e.StringValue4);
            });

        b.OwnsOne(e =&amp;gt; e.OwnedReference,
            o =&amp;gt;
            {
                o.ToTable(&amp;quot;SplitEntityOnePart2&amp;quot;);

                o.SplitToTable(&amp;quot;SplitEntityOnePart1&amp;quot;,
                    t =&amp;gt;
                    {
                        t.Property(e =&amp;gt; e.OwnedIntValue3);
                        t.Property(e =&amp;gt; e.OwnedStringValue3);
                    });

                o.SplitToTable(&amp;quot;OwnedReferencePart3&amp;quot;,
                    t =&amp;gt;
                    {
                        t.Property(e =&amp;gt; e.OwnedIntValue4);
                        t.Property(e =&amp;gt; e.OwnedStringValue4);
                    });
            });
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;throws&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.InvalidOperationException : Unable to save changes because a circular dependency was detected in the data to be saved: 'EntityOne { 'Id': 1 } [Added] &amp;lt;-
ForeignKeyConstraint { 'Id': 1 } EntityOne { 'Id': 1 } [Added] &amp;lt;-
ForeignKeyConstraint { 'Id': 1 } EntityOne { 'Id': 1 } [Added]'.

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Any variation of model where split fragment of owned type tries to use earlier (or main fragment) of owner type throws cycle error. While discussing with @AndriySvyryd , he had mentioned it was valid model (hence no model validation error).&lt;/p&gt;
</description>
      <pubDate>Wed, 14 Sep 2022 23:10:38 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29103</guid>
      <link>https://github.com/dotnet/efcore/issues/29103</link>
      <title>Issue: delete me (sorry!) - @awdorrin</title>
      <description>&lt;p&gt;please delete - issue on my end not in efcore...&lt;/p&gt;
</description>
      <pubDate>Wed, 14 Sep 2022 22:38:11 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29101</guid>
      <link>https://github.com/dotnet/efcore/issues/29101</link>
      <title>Issue: CLI dbscaffold not correctly scaffolding many-to-many relationships - @cbrenberg</title>
      <description>&lt;p&gt;I'm in the process of upgrading a project from EF5 to EFCore 6.0.9. According to the &lt;a href="https://docs.microsoft.com/en-us/ef/core/what-is-new/ef-core-6.0/breaking-changes#many-to-many"&gt;docs &lt;/a&gt; and &lt;a href="https://github.com/dotnet/efcore/issues/22475"&gt;Issue #22475&lt;/a&gt;, simple join tables should be mapped directly as a many to many relationship between the two tables being joined. This is not the behavior I'm seeing. Instead, all navigation/join tables are being scaffolded as their own entity types. Why is the scaffolding tool creating a separate entity type for the LicensedUserModules join table in the example below?&lt;/p&gt;
&lt;p&gt;For example, we have a table 'LicensedUsers' with a many to many relationship to an 'ApplicationModules' table that's defined by a simple join table 'LicensedUserModules' that contains two columns: 'LicensedUserID' (FK to LicensedUsers) and 'ApplicationModuleID' (FK to ApplicationModules). Both columns comprise the PK for this join table.&lt;/p&gt;
&lt;p&gt;After running the 'dotnet ef dbscaffold' command, I would expect the LicensedUser type to have a collection of ApplicationModules, but instead it has a collection of LicensedUserModules.&lt;/p&gt;
&lt;p&gt;Here's the scaffolded context for the LicensedUser table:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;modelBuilder.Entity&amp;lt;LicensedUser&amp;gt;(entity =&amp;gt;
            {
                entity.Property(e =&amp;gt; e.LicensedUserId).HasColumnName(&amp;quot;LicensedUserID&amp;quot;);

                entity.Property(e =&amp;gt; e.LastActivityTimeUtc).HasColumnType(&amp;quot;datetime&amp;quot;);

                entity.Property(e =&amp;gt; e.LicenseId).HasColumnName(&amp;quot;LicenseID&amp;quot;);

                entity.Property(e =&amp;gt; e.SeatActivityTimeUtc).HasColumnType(&amp;quot;datetime&amp;quot;);

                entity.Property(e =&amp;gt; e.UserId)
                    .IsRequired()
                    .HasMaxLength(128)
                    .HasColumnName(&amp;quot;UserID&amp;quot;);

                entity.Property(e =&amp;gt; e.UserTypeId)
                    .HasColumnName(&amp;quot;UserTypeID&amp;quot;)
                    .HasDefaultValueSql(&amp;quot;((1))&amp;quot;);

                entity.HasOne(d =&amp;gt; d.License)
                    .WithMany(p =&amp;gt; p.LicensedUsers)
                    .HasForeignKey(d =&amp;gt; d.LicenseId)
                    .OnDelete(DeleteBehavior.ClientSetNull)
                    .HasConstraintName(&amp;quot;FK_LicensedUsers_Licenses&amp;quot;);

                entity.HasOne(d =&amp;gt; d.UserType)
                    .WithMany(p =&amp;gt; p.LicensedUsers)
                    .HasForeignKey(d =&amp;gt; d.UserTypeId)
                    .OnDelete(DeleteBehavior.ClientSetNull)
                    .HasConstraintName(&amp;quot;FK_LicensedUsers_UserTypes&amp;quot;);
            });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the LicensedUser entity type:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public partial class LicensedUser
    {
        public LicensedUser()
        {
            LicensedUserModules = new HashSet&amp;lt;LicensedUserModule&amp;gt;();
            LicensedUserPermissions = new HashSet&amp;lt;LicensedUserPermission&amp;gt;();
            SubscriptionAllocations = new HashSet&amp;lt;SubscriptionAllocation&amp;gt;();
        }

        public Guid LicenseId { get; set; }
        public string UserId { get; set; }
        public DateTime? LastActivityTimeUtc { get; set; }
        public int LicensedUserId { get; set; }
        public int UserTypeId { get; set; }
        public DateTime? SeatActivityTimeUtc { get; set; }

        public virtual License License { get; set; }
        public virtual UserType UserType { get; set; }
        public virtual ICollection&amp;lt;LicensedUserModule&amp;gt; LicensedUserModules { get; set; }
        public virtual ICollection&amp;lt;LicensedUserPermission&amp;gt; LicensedUserPermissions { get; set; }
        public virtual ICollection&amp;lt;SubscriptionAllocation&amp;gt; SubscriptionAllocations { get; set; }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;EF Core version: 6.0.9
Database provider: Microsoft.EntityFrameworkCore.SqlServer 6.0.9
Entity Framework Core .NET Command-line Tools version: 6.0.9
Target framework: .NET 6.0
Operating system: Windows 10&lt;/p&gt;
</description>
      <pubDate>Wed, 14 Sep 2022 20:40:02 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29098</guid>
      <link>https://github.com/dotnet/efcore/issues/29098</link>
      <title>Issue: IdentityMap still referenced in StateManager after DbContexts has been returned to DbContextPool  - @jonnybee</title>
      <description>&lt;p&gt;Using EF Core 7.0.0-rc.2.22464.4
Database provider: Microsoft.EntityFrameworkCore.SqlServer
IDE: VisualStudio 2022 v17.3.4
OS: Windows 11&lt;/p&gt;
&lt;p&gt;Memory is still referenced for IdentityMap in StateManager after DbContexts have been returned to DbContextPool using DbContextFactory:
&lt;img src="https://user-images.githubusercontent.com/3512406/190218149-bc9e8195-29ac-4354-9cf7-2fd7da2a317f.png" alt="image" /&gt;&lt;/p&gt;
&lt;p&gt;After testing the same issue in release/6.0 this will change in StateManager.Clear  method will fix the issue:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;public virtual void Clear()
{
    Unsubscribe();
    ChangedCount = 0;
    _entityReferenceMap.Clear();
    _referencedUntrackedEntities = null;
 
    _identityMaps?.Clear();
    _identityMaps = null!;
    _identityMap0 = null!;
    _identityMap1 = null!;

    .....
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Wed, 14 Sep 2022 17:09:39 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29096</guid>
      <link>https://github.com/dotnet/efcore/issues/29096</link>
      <title>Issue: Bulk delete with join - @petrkasnal</title>
      <description>&lt;p&gt;Hello,&lt;/p&gt;
&lt;p&gt;i have question about Bulk Delete. Will be possible add include (inner join)?&lt;/p&gt;
&lt;p&gt;Thank you&lt;/p&gt;
</description>
      <pubDate>Wed, 14 Sep 2022 15:35:18 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29094</guid>
      <link>https://github.com/dotnet/efcore/issues/29094</link>
      <title>Issue: The supplied value is not a valid instance of data type geography - @mrpmorris</title>
      <description>&lt;p&gt;When trying to insert a row that has a property of type NetTopologySuite.Point I get the exception &amp;quot;The supplied value is not a valid instance of data type geography&amp;quot;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create a new console app.&lt;/li&gt;
&lt;li&gt;Add the following references&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;    &amp;lt;PackageReference Include=&amp;quot;Microsoft.EntityFrameworkCore.SqlServer&amp;quot; Version=&amp;quot;6.0.9&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.EntityFrameworkCore.SqlServer.NetTopologySuite&amp;quot; Version=&amp;quot;6.0.9&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.Extensions.DependencyInjection&amp;quot; Version=&amp;quot;6.0.0&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="3"&gt;
&lt;li&gt;Create the following domain class&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;public class SomewhereNice
{
    public int Id { get; set; }
    public string Name { get; set; } = &amp;quot;The sea&amp;quot;;
    public Point Location { get; set; } = new Point(0, 0, 4326);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="4"&gt;
&lt;li&gt;Add a DbContext descendant&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;public class ApplicationDbContext : DbContext
{
    public DbSet&amp;lt;SomewhereNice&amp;gt; NicePlaces { get; set; } = null!;
    public ApplicationDbContext(DbContextOptions&amp;lt;ApplicationDbContext&amp;gt; options) : base(options) {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="5"&gt;
&lt;li&gt;Update the &lt;code&gt;Program.cs&lt;/code&gt; file as follows and then run the app....&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;using EFGeography;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;

Console.WriteLine(&amp;quot;Hello, World!&amp;quot;);

var services = new ServiceCollection();


services.AddDbContext&amp;lt;ApplicationDbContext&amp;gt;(options =&amp;gt;
{
    options.UseSqlServer(
        connectionString: &amp;quot;Server=.\\SQLExpress;Database=EFGeography;Trusted_Connection=True;MultipleActiveResultSets=true&amp;quot;,
        x =&amp;gt; x.UseNetTopologySuite());
});

IServiceProvider serviceProvider = services.BuildServiceProvider();

using var context = serviceProvider.GetRequiredService&amp;lt;ApplicationDbContext&amp;gt;();
context.Database.EnsureCreated();

var theSea = new SomewhereNice();
context.NicePlaces.Add(theSea);
context.SaveChanges();
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Wed, 14 Sep 2022 15:13:36 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29093</guid>
      <link>https://github.com/dotnet/efcore/issues/29093</link>
      <title>Issue: Two left outer join break server side evaluation - @noe555</title>
      <description>&lt;p&gt;Hi.&lt;/p&gt;
&lt;p&gt;In our database model, we have two possible 'paths' from a base table to a target table.&lt;/p&gt;
&lt;p&gt;Thus, we perform two outer joins, one one the first path (the main one), another one on the second, and then in a  .Select() we pick one which is not null, if any.&lt;/p&gt;
&lt;p&gt;But after that '.Select()', the IQueryable&amp;lt;&amp;gt; which is returned does not represent a server view which can accept additional statements which are evaluated on the server side.
Instead, it looks like all the fields from that target table are returned in memory (meaning we reached client evaluation). Thus we cannot fetch additional data like from a navigation property within the same query.&lt;/p&gt;
&lt;p&gt;But both of the individual outer join work by themselves, see ine the example below the Select statement marked as (a) or (b) in the code, assuming the path (1) or (2) are selected respectively.&lt;/p&gt;
&lt;p&gt;I have seen several issues related to left outer join summarized in (#17068), and my understanding is that we use the right outer join pattern, and I could not find any ticket which was related to very performing of two outer joins at the same time (versus a single one), I apologize if there is already such an issue.&lt;/p&gt;
&lt;h3&gt;Steps to reproduce&lt;/h3&gt;
&lt;p&gt;Please see use case below and run the test, most of the comments are in the code.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using Microsoft.Data.Sqlite;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.Extensions.DependencyInjection;
using Xunit.Abstractions;

namespace IssueTwoJoinEF;

public class ReproTwoLeftOuterJoinsTest
{
    protected readonly ITestOutputHelper Output;

    public ReproTwoLeftOuterJoinsTest(ITestOutputHelper output)
    {
        Output = output;
    }
    
    // Elements of our 'base' table, which may have two 'paths' through outer join towards the 'target' table 
    private class Base
    {
        [Key, Required] public Guid Id { get; private init; } = Guid.NewGuid();


        public Guid TargetIdO { get; private init; } // This field may have a matching, or not, in the 'Target' table (the quicker path)

        public Guid SecondaryPathOId { get; private init; } // This field may have a matching, or not, in the 'SecondaryPaths' table, which will have a reference to the Target

        private Base() { }

        public Base(Guid targetIdOIdO, Guid secondaryPathOId)
        {
            TargetIdO = targetIdOIdO;
            SecondaryPathOId = secondaryPathOId;
        }
    }
    
    // A 'secondary' path towards the target
    private class SecondaryPath
    {
        [Key, Required] public Guid Id { get; private init; } = Guid.NewGuid();

        [ForeignKey(&amp;quot;Target&amp;quot;)] public Guid TargetId { get; private init; }
        public virtual Target Target { get; private init; } = null!;

        private SecondaryPath() { }

        public SecondaryPath(Guid targetId)
        {
            TargetId = targetId;
        }
    }
    
    // Elements from our 'target' table
    private class Target
    {
        [Key, Required] public Guid Id { get; private init; } = Guid.NewGuid();
        
        
        // A navigation property to illustrate the fact that we switched to client-side evaluation
        [ForeignKey(&amp;quot;TargetOuter&amp;quot;)] public Guid TargetOuterId { get; private init; }
        public virtual TargetOuter TargetOuter { get; private init; } = null!;

        private Target() { }

        public Target(TargetOuter targetOuter)
        {
            TargetOuter = targetOuter;
        }
    }
    
    private class TargetOuter
    {
        [Key, Required] public Guid Id { get; private init; } = Guid.NewGuid();

        public string Name { get; init; } = null!; // Simply store a name here

        private TargetOuter() { }

        public TargetOuter(string name)
        {
            Name = name;
        }
    }
    
    private class TestDbContext: DbContext
    {
        public TestDbContext(DbContextOptions options) : base(options) { }

        public DbSet&amp;lt;Base&amp;gt; Bases { get; set; } = null!;
        public DbSet&amp;lt;SecondaryPath&amp;gt; SecondariesPaths { get; set; } = null!;
        public DbSet&amp;lt;Target&amp;gt; Targets { get; set; } = null!;
        public DbSet&amp;lt;TargetOuter&amp;gt; TargetOuters { get; set; } = null!;
    }

    private class BaseWithMainTargetO
    {
        public Base Base { get; init; } = null!;
        public Target? MainTargetO { get; init; }
    }
    
    public class SQLiteConnectionWrapper: IDisposable
    {
        public SqliteConnection SqliteConnection { get; }

        public SQLiteConnectionWrapper()
        {
            SqliteConnection = new SqliteConnection(&amp;quot;DataSource=:memory:&amp;quot;);
            SqliteConnection.Open();
        }

        public void Dispose()
        {
            SqliteConnection.Dispose();
        }
    }

    private class OuterJoinModel&amp;lt;TOuter, TInner&amp;gt;
    {
        public TOuter BaseOuter { get; init; } = default!;

        public IEnumerable&amp;lt;TInner&amp;gt; Inners { get; init; } = default!;
    }
    
    [Fact]
    public async Task TestRepro()
    {
        ServiceCollection services = new();

        // Register basic services
        
        services.AddLogging();

        services.AddSingleton&amp;lt;SQLiteConnectionWrapper&amp;gt;();
        services.AddDbContext&amp;lt;TestDbContext&amp;gt;((sp, options) =&amp;gt;
        {
            options.UseSqlite(sp.GetRequiredService&amp;lt;SQLiteConnectionWrapper&amp;gt;().SqliteConnection);
            options.LogTo(Output.WriteLine); // Add logging to see that we miss the join to the TargetOuter table
        });

        await using ServiceProvider serviceProvider = services.BuildServiceProvider(
            new ServiceProviderOptions
            {
                ValidateOnBuild = true,
                ValidateScopes = true
            }
        );

        const string targetOuterName = &amp;quot;name&amp;quot;;

        using (IServiceScope scope = serviceProvider.CreateScope())
        {
            // Setup the db
            
            TestDbContext ctx = scope.ServiceProvider.GetRequiredService&amp;lt;TestDbContext&amp;gt;();
            DatabaseFacade databaseFacade = ctx.Database;
            await databaseFacade.EnsureCreatedAsync();

            // We add one target
            Target target = ctx.Targets.Add(new Target(ctx.TargetOuters.Add(new TargetOuter(targetOuterName)).Entity)).Entity;
            
            // We add one base element, with either path
            ctx.Bases.Add(
                // 'direct' path from 'base' to 'target', without the secondary path
                new Base(target.Id, Guid.NewGuid() /* unmatched */) // (1)
                
                // path from 'base' to 'target' through the secondary path 
                // new Base(Guid.NewGuid() /* unmatched */, ctx.SecondariesPaths.Add(new SecondaryPath(target.Id)).Entity.Id) // (2)
            );
            await ctx.SaveChangesAsync();
        }

        using (IServiceScope scope = serviceProvider.CreateScope())
        {
            TestDbContext ctx = scope.ServiceProvider.GetRequiredService&amp;lt;TestDbContext&amp;gt;();
            // Sample test using a navigation property on the target
            Assert.Equal(
                targetOuterName,
                await ctx.Bases
                        
                        // The first left join
                        .GroupJoin&amp;lt;Base, Target, Guid, OuterJoinModel&amp;lt;Base, Target&amp;gt;&amp;gt;(
                            ctx.Targets,
                            b =&amp;gt; b.TargetIdO,
                            p =&amp;gt; p.Id,
                            (bu, bis) =&amp;gt; new OuterJoinModel&amp;lt;Base, Target&amp;gt;
                            {
                                BaseOuter = bu,
                                Inners = bis
                            }
                        )
                        .SelectMany&amp;lt;OuterJoinModel&amp;lt;Base, Target&amp;gt;, Target?, BaseWithMainTargetO&amp;gt;(
                            i =&amp;gt; i.Inners.DefaultIfEmpty(),
                            (b, mainTargetO) =&amp;gt; new BaseWithMainTargetO
                            {
                                Base = b.BaseOuter,
                                MainTargetO = mainTargetO
                            }
                        )
                        
                        // The second left join
                        .GroupJoin&amp;lt;BaseWithMainTargetO, SecondaryPath, Guid, OuterJoinModel&amp;lt;BaseWithMainTargetO, SecondaryPath&amp;gt;&amp;gt;(
                            ctx.SecondariesPaths,
                            b =&amp;gt; b.Base.SecondaryPathOId,
                            p =&amp;gt; p.Id,
                            (bu, bis) =&amp;gt; new OuterJoinModel&amp;lt;BaseWithMainTargetO, SecondaryPath&amp;gt;
                            {
                                BaseOuter = bu,
                                Inners = bis
                            }
                        )
                        .SelectMany&amp;lt;OuterJoinModel&amp;lt;BaseWithMainTargetO, SecondaryPath&amp;gt;, SecondaryPath?, Target?&amp;gt;(
                            i =&amp;gt; i.Inners.DefaultIfEmpty(),
                            // (b, po) =&amp;gt; b.BaseOuter.MainTargetO // This one works (a), make sure path (1) is selected, which is the initial state
                            // (b, po) =&amp;gt; po!.Target // This one works (b), make sure path (2) is selected, from initial state you need to comment line (1) / uncomment line (2)
                            
                            // The combination of both expressions just above does not work, whichever path (1) or (2)
                            (b, po) =&amp;gt; b.BaseOuter.MainTargetO ?? po!.Target
                            // A minor alternative (which does not work neither)
                            // (b, po) =&amp;gt; b.BaseOuter.TargetO != null ? b.BaseOuter.TargetO : po!.Target
                        )
                        
                        // Now we would like to run some server-side selections on Target
                        .Select(p =&amp;gt; p!.TargetOuter.Name) // Example of navigation property
                        .FirstAsync()
            );   
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I just created a test XUnit Project from Visual Studio, and installed Microsoft.EntityFrameworkCore.Sqlite, and ended up with the following config in my csproj file.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-XML"&gt;  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.EntityFrameworkCore.Sqlite&amp;quot; Version=&amp;quot;6.0.9&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;Microsoft.NET.Test.Sdk&amp;quot; Version=&amp;quot;17.3.1&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;xunit&amp;quot; Version=&amp;quot;2.4.2&amp;quot; /&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;xunit.runner.visualstudio&amp;quot; Version=&amp;quot;2.4.5&amp;quot;&amp;gt;
      &amp;lt;IncludeAssets&amp;gt;runtime; build; native; contentfiles; analyzers; buildtransitive&amp;lt;/IncludeAssets&amp;gt;
      &amp;lt;PrivateAssets&amp;gt;all&amp;lt;/PrivateAssets&amp;gt;
    &amp;lt;/PackageReference&amp;gt;
    &amp;lt;PackageReference Include=&amp;quot;coverlet.collector&amp;quot; Version=&amp;quot;3.1.2&amp;quot;&amp;gt;
      &amp;lt;IncludeAssets&amp;gt;runtime; build; native; contentfiles; analyzers; buildtransitive&amp;lt;/IncludeAssets&amp;gt;
      &amp;lt;PrivateAssets&amp;gt;all&amp;lt;/PrivateAssets&amp;gt;
    &amp;lt;/PackageReference&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I also have the 'using.cs' file, with content : global using Xunit;&lt;/p&gt;
&lt;h3&gt;Include provider and version information&lt;/h3&gt;
&lt;p&gt;EF Core version: 6.0.9
Database provider: Microsoft.EntityFrameworkCore.Sqlite
Target framework: .NET 6.0
Operating system:
IDE: Visual Studio 2022 17.3.3&lt;/p&gt;
&lt;p&gt;Thanks a lot.&lt;/p&gt;
</description>
      <pubDate>Wed, 14 Sep 2022 15:00:29 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29092</guid>
      <link>https://github.com/dotnet/efcore/issues/29092</link>
      <title>Issue: Make basic EF scenarios work under aggressive trimming - @roji</title>
      <description>&lt;p&gt;.NET 7.0 is &lt;a href="https://docs.microsoft.com/en-us/dotnet/core/compatibility/deployment/7.0/trim-all-assemblies"&gt;enabling&lt;/a&gt; aggressive trimming mode for console applications (but not for other workloads, e.g. ASP.NET). This makes all EF console applications break immediately when published as trimmed.&lt;/p&gt;
&lt;p&gt;This issue is about ensuring minimal functionality of EF console apps with aggressive trimming. Some caveats:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Some specific patterns may be necessary in user code in order to ensure that certain user types/members in the model aren't trimmed away. We will document these caveats.&lt;/li&gt;
&lt;li&gt;EF will by no means be fully trimming-compatible, and no guarantees are given to the correct working of user applications. This is a best-effort work item; full compatibility with trimming will be explored in future versions of EF.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;/cc @DamianEdwards @davidfowl @vitek-karas&lt;/p&gt;
</description>
      <pubDate>Wed, 14 Sep 2022 14:44:12 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29090</guid>
      <link>https://github.com/dotnet/efcore/issues/29090</link>
      <title>Issue: Is there anyway to debug Add-Migrations? - @huang-tianwen</title>
      <description>&lt;p&gt;I refactor my code to inherit my entities from an abstract generic type.
If I Add-Migrations from Existing migrations it give me error.&lt;br /&gt;
But, If I delete all previous Migrations and run Add-Migrations. It will create a new successful migration file.
The error is the following:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;System.ArgumentException: An item with the same key has already been added. Key: System.Object Item [System.String]
   at System.Collections.Generic.Dictionary`2.TryInsert(TKey key, TValue value, InsertionBehavior behavior)
   at Microsoft.EntityFrameworkCore.Migrations.Internal.MigrationsModelDiffer.GetSortedProperties(IEntityType entityType, ITable table)
   at Microsoft.EntityFrameworkCore.Migrations.Internal.MigrationsModelDiffer.GetSortedColumns(ITable table)
   at Microsoft.EntityFrameworkCore.Migrations.Internal.MigrationsModelDiffer.Add(ITable target, DiffContext diffContext)+MoveNext()
   at Microsoft.EntityFrameworkCore.Migrations.Internal.MigrationsModelDiffer.DiffCollection[T](IEnumerable`1 sources, IEnumerable`1 targets, DiffContext diffContext, Func`4 diff, Func`3 add, Func`3 remove, Func`4[] predicates)+MoveNext()
   at System.Linq.Enumerable.ConcatIterator`1.MoveNext()
   at Microsoft.EntityFrameworkCore.Migrations.Internal.MigrationsModelDiffer.Sort(IEnumerable`1 operations, DiffContext diffContext)
   at Microsoft.EntityFrameworkCore.Migrations.Internal.MigrationsModelDiffer.GetDifferences(IRelationalModel source, IRelationalModel target)
   at Microsoft.EntityFrameworkCore.Migrations.Design.MigrationsScaffolder.ScaffoldMigration(String migrationName, String rootNamespace, String subNamespace, String language)
   at Microsoft.EntityFrameworkCore.Design.Internal.MigrationsOperations.AddMigration(String name, String outputDir, String contextType, String namespace)
   at Microsoft.EntityFrameworkCore.Design.OperationExecutor.AddMigrationImpl(String name, String outputDir, String contextType, String namespace)
   at Microsoft.EntityFrameworkCore.Design.OperationExecutor.AddMigration.&amp;lt;&amp;gt;c__DisplayClass0_0.&amp;lt;.ctor&amp;gt;b__0()
   at Microsoft.EntityFrameworkCore.Design.OperationExecutor.OperationBase.&amp;lt;&amp;gt;c__DisplayClass3_0`1.&amp;lt;Execute&amp;gt;b__0()
   at Microsoft.EntityFrameworkCore.Design.OperationExecutor.OperationBase.Execute(Action action)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Is there anyway to debug the Add-Migrations process? because the error message with &amp;quot;Key: System.Object Item [System.String]&amp;quot; is not helpful. I cannot know which part of my code might have conflicted key.&lt;/p&gt;
&lt;p&gt;EF Core version:
Database provider: (e.g. Microsoft.EntityFrameworkCore.SqlServer)
Target framework: (e.g. .NET 6.0)
Operating system:
IDE: (e.g. Visual Studio 2022 17.3.4)&lt;/p&gt;
</description>
      <pubDate>Wed, 14 Sep 2022 13:36:21 Z</pubDate>
    </item>
    <item>
      <guid isPermaLink="true">https://github.com/dotnet/efcore/issues/29089</guid>
      <link>https://github.com/dotnet/efcore/issues/29089</link>
      <title>Issue: SplitQuery per-table definition - @gdoron</title>
      <description>&lt;p&gt;Currently (AFAIK) it's only possible to either have SingleQuery or SplitQuery defined globally for all queries, or per-query.
Would have been really helpful being able to set the default split query mode per table.
Consider a blogs -&amp;gt; posts relation, our blog has a logo column with max 4MB of data per row.
Joining the blog with its 10K posts can be devastating.&lt;/p&gt;
&lt;p&gt;I think it should also be possible to set the mode by entity:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BlogConfiguration IEntityTypeConfiguration&amp;lt;BlogEntity&amp;gt;
{
    public void Configure(EntityTypeBuilder&amp;lt;BlogEntity&amp;gt; builder)
    {
        builder.Property(entity =&amp;gt; entity.Logo).HasMaxLength(1024 * 1024 * 4);
        builder.WithSplitQuery(true);
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      <pubDate>Wed, 14 Sep 2022 13:23:30 Z</pubDate>
    </item>
  </channel>
</rss>